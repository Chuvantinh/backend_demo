// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  activity: (where?: ActivityWhereInput) => Promise<boolean>;
  award: (where?: AwardWhereInput) => Promise<boolean>;
  bot: (where?: BotWhereInput) => Promise<boolean>;
  botSettings: (where?: BotSettingsWhereInput) => Promise<boolean>;
  buddy: (where?: BuddyWhereInput) => Promise<boolean>;
  buddyRequest: (where?: BuddyRequestWhereInput) => Promise<boolean>;
  calendarEntry: (where?: CalendarEntryWhereInput) => Promise<boolean>;
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  challenge: (where?: ChallengeWhereInput) => Promise<boolean>;
  challengeCategory: (where?: ChallengeCategoryWhereInput) => Promise<boolean>;
  challengeGroup: (where?: ChallengeGroupWhereInput) => Promise<boolean>;
  chat: (where?: ChatWhereInput) => Promise<boolean>;
  chatMessage: (where?: ChatMessageWhereInput) => Promise<boolean>;
  chatMessageAttachment: (
    where?: ChatMessageAttachmentWhereInput
  ) => Promise<boolean>;
  contribution: (where?: ContributionWhereInput) => Promise<boolean>;
  favoriteActivity: (where?: FavoriteActivityWhereInput) => Promise<boolean>;
  globalSettings: (where?: GlobalSettingsWhereInput) => Promise<boolean>;
  group: (where?: GroupWhereInput) => Promise<boolean>;
  groupColor: (where?: GroupColorWhereInput) => Promise<boolean>;
  initiator: (where?: InitiatorWhereInput) => Promise<boolean>;
  ipaq: (where?: IpaqWhereInput) => Promise<boolean>;
  ipaqAnswers: (where?: IpaqAnswersWhereInput) => Promise<boolean>;
  joinedChallenges: (where?: JoinedChallengesWhereInput) => Promise<boolean>;
  patient: (where?: PatientWhereInput) => Promise<boolean>;
  patientProfileInfo: (
    where?: PatientProfileInfoWhereInput
  ) => Promise<boolean>;
  phq9: (where?: Phq9WhereInput) => Promise<boolean>;
  profileActivity: (where?: ProfileActivityWhereInput) => Promise<boolean>;
  questionnaires: (where?: QuestionnairesWhereInput) => Promise<boolean>;
  scheduledTask: (where?: ScheduledTaskWhereInput) => Promise<boolean>;
  sensorData: (where?: SensorDataWhereInput) => Promise<boolean>;
  timeSpan: (where?: TimeSpanWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userSettings: (where?: UserSettingsWhereInput) => Promise<boolean>;
  voting: (where?: VotingWhereInput) => Promise<boolean>;
  webPushNotification: (
    where?: WebPushNotificationWhereInput
  ) => Promise<boolean>;
  webPushSettings: (where?: WebPushSettingsWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  activity: (where: ActivityWhereUniqueInput) => ActivityNullablePromise;
  activities: (args?: {
    where?: ActivityWhereInput;
    orderBy?: ActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Activity>;
  activitiesConnection: (args?: {
    where?: ActivityWhereInput;
    orderBy?: ActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActivityConnectionPromise;
  award: (where: AwardWhereUniqueInput) => AwardNullablePromise;
  awards: (args?: {
    where?: AwardWhereInput;
    orderBy?: AwardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Award>;
  awardsConnection: (args?: {
    where?: AwardWhereInput;
    orderBy?: AwardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AwardConnectionPromise;
  bot: (where: BotWhereUniqueInput) => BotNullablePromise;
  bots: (args?: {
    where?: BotWhereInput;
    orderBy?: BotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Bot>;
  botsConnection: (args?: {
    where?: BotWhereInput;
    orderBy?: BotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BotConnectionPromise;
  botSettings: (
    where: BotSettingsWhereUniqueInput
  ) => BotSettingsNullablePromise;
  botSettingses: (args?: {
    where?: BotSettingsWhereInput;
    orderBy?: BotSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BotSettings>;
  botSettingsesConnection: (args?: {
    where?: BotSettingsWhereInput;
    orderBy?: BotSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BotSettingsConnectionPromise;
  buddy: (where: BuddyWhereUniqueInput) => BuddyNullablePromise;
  buddies: (args?: {
    where?: BuddyWhereInput;
    orderBy?: BuddyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Buddy>;
  buddiesConnection: (args?: {
    where?: BuddyWhereInput;
    orderBy?: BuddyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BuddyConnectionPromise;
  buddyRequest: (
    where: BuddyRequestWhereUniqueInput
  ) => BuddyRequestNullablePromise;
  buddyRequests: (args?: {
    where?: BuddyRequestWhereInput;
    orderBy?: BuddyRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BuddyRequest>;
  buddyRequestsConnection: (args?: {
    where?: BuddyRequestWhereInput;
    orderBy?: BuddyRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BuddyRequestConnectionPromise;
  calendarEntry: (
    where: CalendarEntryWhereUniqueInput
  ) => CalendarEntryNullablePromise;
  calendarEntries: (args?: {
    where?: CalendarEntryWhereInput;
    orderBy?: CalendarEntryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CalendarEntry>;
  calendarEntriesConnection: (args?: {
    where?: CalendarEntryWhereInput;
    orderBy?: CalendarEntryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CalendarEntryConnectionPromise;
  category: (where: CategoryWhereUniqueInput) => CategoryNullablePromise;
  categories: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Category>;
  categoriesConnection: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CategoryConnectionPromise;
  challenge: (where: ChallengeWhereUniqueInput) => ChallengeNullablePromise;
  challenges: (args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Challenge>;
  challengesConnection: (args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChallengeConnectionPromise;
  challengeCategory: (
    where: ChallengeCategoryWhereUniqueInput
  ) => ChallengeCategoryNullablePromise;
  challengeCategories: (args?: {
    where?: ChallengeCategoryWhereInput;
    orderBy?: ChallengeCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ChallengeCategory>;
  challengeCategoriesConnection: (args?: {
    where?: ChallengeCategoryWhereInput;
    orderBy?: ChallengeCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChallengeCategoryConnectionPromise;
  challengeGroup: (
    where: ChallengeGroupWhereUniqueInput
  ) => ChallengeGroupNullablePromise;
  challengeGroups: (args?: {
    where?: ChallengeGroupWhereInput;
    orderBy?: ChallengeGroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ChallengeGroup>;
  challengeGroupsConnection: (args?: {
    where?: ChallengeGroupWhereInput;
    orderBy?: ChallengeGroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChallengeGroupConnectionPromise;
  chat: (where: ChatWhereUniqueInput) => ChatNullablePromise;
  chats: (args?: {
    where?: ChatWhereInput;
    orderBy?: ChatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Chat>;
  chatsConnection: (args?: {
    where?: ChatWhereInput;
    orderBy?: ChatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChatConnectionPromise;
  chatMessage: (
    where: ChatMessageWhereUniqueInput
  ) => ChatMessageNullablePromise;
  chatMessages: (args?: {
    where?: ChatMessageWhereInput;
    orderBy?: ChatMessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ChatMessage>;
  chatMessagesConnection: (args?: {
    where?: ChatMessageWhereInput;
    orderBy?: ChatMessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChatMessageConnectionPromise;
  chatMessageAttachment: (
    where: ChatMessageAttachmentWhereUniqueInput
  ) => ChatMessageAttachmentNullablePromise;
  chatMessageAttachments: (args?: {
    where?: ChatMessageAttachmentWhereInput;
    orderBy?: ChatMessageAttachmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ChatMessageAttachment>;
  chatMessageAttachmentsConnection: (args?: {
    where?: ChatMessageAttachmentWhereInput;
    orderBy?: ChatMessageAttachmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChatMessageAttachmentConnectionPromise;
  contribution: (
    where: ContributionWhereUniqueInput
  ) => ContributionNullablePromise;
  contributions: (args?: {
    where?: ContributionWhereInput;
    orderBy?: ContributionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Contribution>;
  contributionsConnection: (args?: {
    where?: ContributionWhereInput;
    orderBy?: ContributionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContributionConnectionPromise;
  favoriteActivity: (
    where: FavoriteActivityWhereUniqueInput
  ) => FavoriteActivityNullablePromise;
  favoriteActivities: (args?: {
    where?: FavoriteActivityWhereInput;
    orderBy?: FavoriteActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FavoriteActivity>;
  favoriteActivitiesConnection: (args?: {
    where?: FavoriteActivityWhereInput;
    orderBy?: FavoriteActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FavoriteActivityConnectionPromise;
  globalSettings: (
    where: GlobalSettingsWhereUniqueInput
  ) => GlobalSettingsNullablePromise;
  globalSettingses: (args?: {
    where?: GlobalSettingsWhereInput;
    orderBy?: GlobalSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GlobalSettings>;
  globalSettingsesConnection: (args?: {
    where?: GlobalSettingsWhereInput;
    orderBy?: GlobalSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GlobalSettingsConnectionPromise;
  group: (where: GroupWhereUniqueInput) => GroupNullablePromise;
  groups: (args?: {
    where?: GroupWhereInput;
    orderBy?: GroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Group>;
  groupsConnection: (args?: {
    where?: GroupWhereInput;
    orderBy?: GroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GroupConnectionPromise;
  groupColor: (where: GroupColorWhereUniqueInput) => GroupColorNullablePromise;
  groupColors: (args?: {
    where?: GroupColorWhereInput;
    orderBy?: GroupColorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GroupColor>;
  groupColorsConnection: (args?: {
    where?: GroupColorWhereInput;
    orderBy?: GroupColorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GroupColorConnectionPromise;
  initiator: (where: InitiatorWhereUniqueInput) => InitiatorNullablePromise;
  initiators: (args?: {
    where?: InitiatorWhereInput;
    orderBy?: InitiatorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Initiator>;
  initiatorsConnection: (args?: {
    where?: InitiatorWhereInput;
    orderBy?: InitiatorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InitiatorConnectionPromise;
  ipaq: (where: IpaqWhereUniqueInput) => IpaqNullablePromise;
  ipaqs: (args?: {
    where?: IpaqWhereInput;
    orderBy?: IpaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Ipaq>;
  ipaqsConnection: (args?: {
    where?: IpaqWhereInput;
    orderBy?: IpaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => IpaqConnectionPromise;
  ipaqAnswers: (
    where: IpaqAnswersWhereUniqueInput
  ) => IpaqAnswersNullablePromise;
  ipaqAnswerses: (args?: {
    where?: IpaqAnswersWhereInput;
    orderBy?: IpaqAnswersOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<IpaqAnswers>;
  ipaqAnswersesConnection: (args?: {
    where?: IpaqAnswersWhereInput;
    orderBy?: IpaqAnswersOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => IpaqAnswersConnectionPromise;
  joinedChallenges: (
    where: JoinedChallengesWhereUniqueInput
  ) => JoinedChallengesNullablePromise;
  joinedChallengeses: (args?: {
    where?: JoinedChallengesWhereInput;
    orderBy?: JoinedChallengesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<JoinedChallenges>;
  joinedChallengesesConnection: (args?: {
    where?: JoinedChallengesWhereInput;
    orderBy?: JoinedChallengesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => JoinedChallengesConnectionPromise;
  patient: (where: PatientWhereUniqueInput) => PatientNullablePromise;
  patients: (args?: {
    where?: PatientWhereInput;
    orderBy?: PatientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Patient>;
  patientsConnection: (args?: {
    where?: PatientWhereInput;
    orderBy?: PatientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PatientConnectionPromise;
  patientProfileInfo: (
    where: PatientProfileInfoWhereUniqueInput
  ) => PatientProfileInfoNullablePromise;
  patientProfileInfoes: (args?: {
    where?: PatientProfileInfoWhereInput;
    orderBy?: PatientProfileInfoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PatientProfileInfo>;
  patientProfileInfoesConnection: (args?: {
    where?: PatientProfileInfoWhereInput;
    orderBy?: PatientProfileInfoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PatientProfileInfoConnectionPromise;
  phq9: (where: Phq9WhereUniqueInput) => Phq9NullablePromise;
  phq9s: (args?: {
    where?: Phq9WhereInput;
    orderBy?: Phq9OrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Phq9>;
  phq9sConnection: (args?: {
    where?: Phq9WhereInput;
    orderBy?: Phq9OrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => Phq9ConnectionPromise;
  profileActivity: (
    where: ProfileActivityWhereUniqueInput
  ) => ProfileActivityNullablePromise;
  profileActivities: (args?: {
    where?: ProfileActivityWhereInput;
    orderBy?: ProfileActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProfileActivity>;
  profileActivitiesConnection: (args?: {
    where?: ProfileActivityWhereInput;
    orderBy?: ProfileActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProfileActivityConnectionPromise;
  questionnaires: (
    where: QuestionnairesWhereUniqueInput
  ) => QuestionnairesNullablePromise;
  questionnaireses: (args?: {
    where?: QuestionnairesWhereInput;
    orderBy?: QuestionnairesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Questionnaires>;
  questionnairesesConnection: (args?: {
    where?: QuestionnairesWhereInput;
    orderBy?: QuestionnairesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuestionnairesConnectionPromise;
  scheduledTask: (
    where: ScheduledTaskWhereUniqueInput
  ) => ScheduledTaskNullablePromise;
  scheduledTasks: (args?: {
    where?: ScheduledTaskWhereInput;
    orderBy?: ScheduledTaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ScheduledTask>;
  scheduledTasksConnection: (args?: {
    where?: ScheduledTaskWhereInput;
    orderBy?: ScheduledTaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ScheduledTaskConnectionPromise;
  sensorData: (where: SensorDataWhereUniqueInput) => SensorDataNullablePromise;
  sensorDatas: (args?: {
    where?: SensorDataWhereInput;
    orderBy?: SensorDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SensorData>;
  sensorDatasConnection: (args?: {
    where?: SensorDataWhereInput;
    orderBy?: SensorDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SensorDataConnectionPromise;
  timeSpan: (where: TimeSpanWhereUniqueInput) => TimeSpanNullablePromise;
  timeSpans: (args?: {
    where?: TimeSpanWhereInput;
    orderBy?: TimeSpanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TimeSpan>;
  timeSpansConnection: (args?: {
    where?: TimeSpanWhereInput;
    orderBy?: TimeSpanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TimeSpanConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  userSettings: (
    where: UserSettingsWhereUniqueInput
  ) => UserSettingsNullablePromise;
  userSettingses: (args?: {
    where?: UserSettingsWhereInput;
    orderBy?: UserSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserSettings>;
  userSettingsesConnection: (args?: {
    where?: UserSettingsWhereInput;
    orderBy?: UserSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserSettingsConnectionPromise;
  voting: (where: VotingWhereUniqueInput) => VotingNullablePromise;
  votings: (args?: {
    where?: VotingWhereInput;
    orderBy?: VotingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Voting>;
  votingsConnection: (args?: {
    where?: VotingWhereInput;
    orderBy?: VotingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VotingConnectionPromise;
  webPushNotification: (
    where: WebPushNotificationWhereUniqueInput
  ) => WebPushNotificationNullablePromise;
  webPushNotifications: (args?: {
    where?: WebPushNotificationWhereInput;
    orderBy?: WebPushNotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<WebPushNotification>;
  webPushNotificationsConnection: (args?: {
    where?: WebPushNotificationWhereInput;
    orderBy?: WebPushNotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WebPushNotificationConnectionPromise;
  webPushSettings: (
    where: WebPushSettingsWhereUniqueInput
  ) => WebPushSettingsNullablePromise;
  webPushSettingses: (args?: {
    where?: WebPushSettingsWhereInput;
    orderBy?: WebPushSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<WebPushSettings>;
  webPushSettingsesConnection: (args?: {
    where?: WebPushSettingsWhereInput;
    orderBy?: WebPushSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WebPushSettingsConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createActivity: (data: ActivityCreateInput) => ActivityPromise;
  updateActivity: (args: {
    data: ActivityUpdateInput;
    where: ActivityWhereUniqueInput;
  }) => ActivityPromise;
  updateManyActivities: (args: {
    data: ActivityUpdateManyMutationInput;
    where?: ActivityWhereInput;
  }) => BatchPayloadPromise;
  upsertActivity: (args: {
    where: ActivityWhereUniqueInput;
    create: ActivityCreateInput;
    update: ActivityUpdateInput;
  }) => ActivityPromise;
  deleteActivity: (where: ActivityWhereUniqueInput) => ActivityPromise;
  deleteManyActivities: (where?: ActivityWhereInput) => BatchPayloadPromise;
  createAward: (data: AwardCreateInput) => AwardPromise;
  updateAward: (args: {
    data: AwardUpdateInput;
    where: AwardWhereUniqueInput;
  }) => AwardPromise;
  updateManyAwards: (args: {
    data: AwardUpdateManyMutationInput;
    where?: AwardWhereInput;
  }) => BatchPayloadPromise;
  upsertAward: (args: {
    where: AwardWhereUniqueInput;
    create: AwardCreateInput;
    update: AwardUpdateInput;
  }) => AwardPromise;
  deleteAward: (where: AwardWhereUniqueInput) => AwardPromise;
  deleteManyAwards: (where?: AwardWhereInput) => BatchPayloadPromise;
  createBot: (data: BotCreateInput) => BotPromise;
  updateBot: (args: {
    data: BotUpdateInput;
    where: BotWhereUniqueInput;
  }) => BotPromise;
  updateManyBots: (args: {
    data: BotUpdateManyMutationInput;
    where?: BotWhereInput;
  }) => BatchPayloadPromise;
  upsertBot: (args: {
    where: BotWhereUniqueInput;
    create: BotCreateInput;
    update: BotUpdateInput;
  }) => BotPromise;
  deleteBot: (where: BotWhereUniqueInput) => BotPromise;
  deleteManyBots: (where?: BotWhereInput) => BatchPayloadPromise;
  createBotSettings: (data: BotSettingsCreateInput) => BotSettingsPromise;
  updateBotSettings: (args: {
    data: BotSettingsUpdateInput;
    where: BotSettingsWhereUniqueInput;
  }) => BotSettingsPromise;
  updateManyBotSettingses: (args: {
    data: BotSettingsUpdateManyMutationInput;
    where?: BotSettingsWhereInput;
  }) => BatchPayloadPromise;
  upsertBotSettings: (args: {
    where: BotSettingsWhereUniqueInput;
    create: BotSettingsCreateInput;
    update: BotSettingsUpdateInput;
  }) => BotSettingsPromise;
  deleteBotSettings: (where: BotSettingsWhereUniqueInput) => BotSettingsPromise;
  deleteManyBotSettingses: (
    where?: BotSettingsWhereInput
  ) => BatchPayloadPromise;
  createBuddy: (data: BuddyCreateInput) => BuddyPromise;
  updateBuddy: (args: {
    data: BuddyUpdateInput;
    where: BuddyWhereUniqueInput;
  }) => BuddyPromise;
  upsertBuddy: (args: {
    where: BuddyWhereUniqueInput;
    create: BuddyCreateInput;
    update: BuddyUpdateInput;
  }) => BuddyPromise;
  deleteBuddy: (where: BuddyWhereUniqueInput) => BuddyPromise;
  deleteManyBuddies: (where?: BuddyWhereInput) => BatchPayloadPromise;
  createBuddyRequest: (data: BuddyRequestCreateInput) => BuddyRequestPromise;
  updateBuddyRequest: (args: {
    data: BuddyRequestUpdateInput;
    where: BuddyRequestWhereUniqueInput;
  }) => BuddyRequestPromise;
  updateManyBuddyRequests: (args: {
    data: BuddyRequestUpdateManyMutationInput;
    where?: BuddyRequestWhereInput;
  }) => BatchPayloadPromise;
  upsertBuddyRequest: (args: {
    where: BuddyRequestWhereUniqueInput;
    create: BuddyRequestCreateInput;
    update: BuddyRequestUpdateInput;
  }) => BuddyRequestPromise;
  deleteBuddyRequest: (
    where: BuddyRequestWhereUniqueInput
  ) => BuddyRequestPromise;
  deleteManyBuddyRequests: (
    where?: BuddyRequestWhereInput
  ) => BatchPayloadPromise;
  createCalendarEntry: (data: CalendarEntryCreateInput) => CalendarEntryPromise;
  updateCalendarEntry: (args: {
    data: CalendarEntryUpdateInput;
    where: CalendarEntryWhereUniqueInput;
  }) => CalendarEntryPromise;
  updateManyCalendarEntries: (args: {
    data: CalendarEntryUpdateManyMutationInput;
    where?: CalendarEntryWhereInput;
  }) => BatchPayloadPromise;
  upsertCalendarEntry: (args: {
    where: CalendarEntryWhereUniqueInput;
    create: CalendarEntryCreateInput;
    update: CalendarEntryUpdateInput;
  }) => CalendarEntryPromise;
  deleteCalendarEntry: (
    where: CalendarEntryWhereUniqueInput
  ) => CalendarEntryPromise;
  deleteManyCalendarEntries: (
    where?: CalendarEntryWhereInput
  ) => BatchPayloadPromise;
  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (args: {
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
  }) => CategoryPromise;
  updateManyCategories: (args: {
    data: CategoryUpdateManyMutationInput;
    where?: CategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertCategory: (args: {
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
  }) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createChallenge: (data: ChallengeCreateInput) => ChallengePromise;
  updateChallenge: (args: {
    data: ChallengeUpdateInput;
    where: ChallengeWhereUniqueInput;
  }) => ChallengePromise;
  updateManyChallenges: (args: {
    data: ChallengeUpdateManyMutationInput;
    where?: ChallengeWhereInput;
  }) => BatchPayloadPromise;
  upsertChallenge: (args: {
    where: ChallengeWhereUniqueInput;
    create: ChallengeCreateInput;
    update: ChallengeUpdateInput;
  }) => ChallengePromise;
  deleteChallenge: (where: ChallengeWhereUniqueInput) => ChallengePromise;
  deleteManyChallenges: (where?: ChallengeWhereInput) => BatchPayloadPromise;
  createChallengeCategory: (
    data: ChallengeCategoryCreateInput
  ) => ChallengeCategoryPromise;
  updateChallengeCategory: (args: {
    data: ChallengeCategoryUpdateInput;
    where: ChallengeCategoryWhereUniqueInput;
  }) => ChallengeCategoryPromise;
  upsertChallengeCategory: (args: {
    where: ChallengeCategoryWhereUniqueInput;
    create: ChallengeCategoryCreateInput;
    update: ChallengeCategoryUpdateInput;
  }) => ChallengeCategoryPromise;
  deleteChallengeCategory: (
    where: ChallengeCategoryWhereUniqueInput
  ) => ChallengeCategoryPromise;
  deleteManyChallengeCategories: (
    where?: ChallengeCategoryWhereInput
  ) => BatchPayloadPromise;
  createChallengeGroup: (
    data: ChallengeGroupCreateInput
  ) => ChallengeGroupPromise;
  updateChallengeGroup: (args: {
    data: ChallengeGroupUpdateInput;
    where: ChallengeGroupWhereUniqueInput;
  }) => ChallengeGroupPromise;
  upsertChallengeGroup: (args: {
    where: ChallengeGroupWhereUniqueInput;
    create: ChallengeGroupCreateInput;
    update: ChallengeGroupUpdateInput;
  }) => ChallengeGroupPromise;
  deleteChallengeGroup: (
    where: ChallengeGroupWhereUniqueInput
  ) => ChallengeGroupPromise;
  deleteManyChallengeGroups: (
    where?: ChallengeGroupWhereInput
  ) => BatchPayloadPromise;
  createChat: (data: ChatCreateInput) => ChatPromise;
  updateChat: (args: {
    data: ChatUpdateInput;
    where: ChatWhereUniqueInput;
  }) => ChatPromise;
  upsertChat: (args: {
    where: ChatWhereUniqueInput;
    create: ChatCreateInput;
    update: ChatUpdateInput;
  }) => ChatPromise;
  deleteChat: (where: ChatWhereUniqueInput) => ChatPromise;
  deleteManyChats: (where?: ChatWhereInput) => BatchPayloadPromise;
  createChatMessage: (data: ChatMessageCreateInput) => ChatMessagePromise;
  updateChatMessage: (args: {
    data: ChatMessageUpdateInput;
    where: ChatMessageWhereUniqueInput;
  }) => ChatMessagePromise;
  updateManyChatMessages: (args: {
    data: ChatMessageUpdateManyMutationInput;
    where?: ChatMessageWhereInput;
  }) => BatchPayloadPromise;
  upsertChatMessage: (args: {
    where: ChatMessageWhereUniqueInput;
    create: ChatMessageCreateInput;
    update: ChatMessageUpdateInput;
  }) => ChatMessagePromise;
  deleteChatMessage: (where: ChatMessageWhereUniqueInput) => ChatMessagePromise;
  deleteManyChatMessages: (
    where?: ChatMessageWhereInput
  ) => BatchPayloadPromise;
  createChatMessageAttachment: (
    data: ChatMessageAttachmentCreateInput
  ) => ChatMessageAttachmentPromise;
  updateChatMessageAttachment: (args: {
    data: ChatMessageAttachmentUpdateInput;
    where: ChatMessageAttachmentWhereUniqueInput;
  }) => ChatMessageAttachmentPromise;
  updateManyChatMessageAttachments: (args: {
    data: ChatMessageAttachmentUpdateManyMutationInput;
    where?: ChatMessageAttachmentWhereInput;
  }) => BatchPayloadPromise;
  upsertChatMessageAttachment: (args: {
    where: ChatMessageAttachmentWhereUniqueInput;
    create: ChatMessageAttachmentCreateInput;
    update: ChatMessageAttachmentUpdateInput;
  }) => ChatMessageAttachmentPromise;
  deleteChatMessageAttachment: (
    where: ChatMessageAttachmentWhereUniqueInput
  ) => ChatMessageAttachmentPromise;
  deleteManyChatMessageAttachments: (
    where?: ChatMessageAttachmentWhereInput
  ) => BatchPayloadPromise;
  createContribution: (data: ContributionCreateInput) => ContributionPromise;
  updateContribution: (args: {
    data: ContributionUpdateInput;
    where: ContributionWhereUniqueInput;
  }) => ContributionPromise;
  updateManyContributions: (args: {
    data: ContributionUpdateManyMutationInput;
    where?: ContributionWhereInput;
  }) => BatchPayloadPromise;
  upsertContribution: (args: {
    where: ContributionWhereUniqueInput;
    create: ContributionCreateInput;
    update: ContributionUpdateInput;
  }) => ContributionPromise;
  deleteContribution: (
    where: ContributionWhereUniqueInput
  ) => ContributionPromise;
  deleteManyContributions: (
    where?: ContributionWhereInput
  ) => BatchPayloadPromise;
  createFavoriteActivity: (
    data: FavoriteActivityCreateInput
  ) => FavoriteActivityPromise;
  updateFavoriteActivity: (args: {
    data: FavoriteActivityUpdateInput;
    where: FavoriteActivityWhereUniqueInput;
  }) => FavoriteActivityPromise;
  updateManyFavoriteActivities: (args: {
    data: FavoriteActivityUpdateManyMutationInput;
    where?: FavoriteActivityWhereInput;
  }) => BatchPayloadPromise;
  upsertFavoriteActivity: (args: {
    where: FavoriteActivityWhereUniqueInput;
    create: FavoriteActivityCreateInput;
    update: FavoriteActivityUpdateInput;
  }) => FavoriteActivityPromise;
  deleteFavoriteActivity: (
    where: FavoriteActivityWhereUniqueInput
  ) => FavoriteActivityPromise;
  deleteManyFavoriteActivities: (
    where?: FavoriteActivityWhereInput
  ) => BatchPayloadPromise;
  createGlobalSettings: (
    data: GlobalSettingsCreateInput
  ) => GlobalSettingsPromise;
  updateGlobalSettings: (args: {
    data: GlobalSettingsUpdateInput;
    where: GlobalSettingsWhereUniqueInput;
  }) => GlobalSettingsPromise;
  updateManyGlobalSettingses: (args: {
    data: GlobalSettingsUpdateManyMutationInput;
    where?: GlobalSettingsWhereInput;
  }) => BatchPayloadPromise;
  upsertGlobalSettings: (args: {
    where: GlobalSettingsWhereUniqueInput;
    create: GlobalSettingsCreateInput;
    update: GlobalSettingsUpdateInput;
  }) => GlobalSettingsPromise;
  deleteGlobalSettings: (
    where: GlobalSettingsWhereUniqueInput
  ) => GlobalSettingsPromise;
  deleteManyGlobalSettingses: (
    where?: GlobalSettingsWhereInput
  ) => BatchPayloadPromise;
  createGroup: (data: GroupCreateInput) => GroupPromise;
  updateGroup: (args: {
    data: GroupUpdateInput;
    where: GroupWhereUniqueInput;
  }) => GroupPromise;
  updateManyGroups: (args: {
    data: GroupUpdateManyMutationInput;
    where?: GroupWhereInput;
  }) => BatchPayloadPromise;
  upsertGroup: (args: {
    where: GroupWhereUniqueInput;
    create: GroupCreateInput;
    update: GroupUpdateInput;
  }) => GroupPromise;
  deleteGroup: (where: GroupWhereUniqueInput) => GroupPromise;
  deleteManyGroups: (where?: GroupWhereInput) => BatchPayloadPromise;
  createGroupColor: (data: GroupColorCreateInput) => GroupColorPromise;
  updateGroupColor: (args: {
    data: GroupColorUpdateInput;
    where: GroupColorWhereUniqueInput;
  }) => GroupColorPromise;
  updateManyGroupColors: (args: {
    data: GroupColorUpdateManyMutationInput;
    where?: GroupColorWhereInput;
  }) => BatchPayloadPromise;
  upsertGroupColor: (args: {
    where: GroupColorWhereUniqueInput;
    create: GroupColorCreateInput;
    update: GroupColorUpdateInput;
  }) => GroupColorPromise;
  deleteGroupColor: (where: GroupColorWhereUniqueInput) => GroupColorPromise;
  deleteManyGroupColors: (where?: GroupColorWhereInput) => BatchPayloadPromise;
  createInitiator: (data: InitiatorCreateInput) => InitiatorPromise;
  updateInitiator: (args: {
    data: InitiatorUpdateInput;
    where: InitiatorWhereUniqueInput;
  }) => InitiatorPromise;
  updateManyInitiators: (args: {
    data: InitiatorUpdateManyMutationInput;
    where?: InitiatorWhereInput;
  }) => BatchPayloadPromise;
  upsertInitiator: (args: {
    where: InitiatorWhereUniqueInput;
    create: InitiatorCreateInput;
    update: InitiatorUpdateInput;
  }) => InitiatorPromise;
  deleteInitiator: (where: InitiatorWhereUniqueInput) => InitiatorPromise;
  deleteManyInitiators: (where?: InitiatorWhereInput) => BatchPayloadPromise;
  createIpaq: (data: IpaqCreateInput) => IpaqPromise;
  updateIpaq: (args: {
    data: IpaqUpdateInput;
    where: IpaqWhereUniqueInput;
  }) => IpaqPromise;
  updateManyIpaqs: (args: {
    data: IpaqUpdateManyMutationInput;
    where?: IpaqWhereInput;
  }) => BatchPayloadPromise;
  upsertIpaq: (args: {
    where: IpaqWhereUniqueInput;
    create: IpaqCreateInput;
    update: IpaqUpdateInput;
  }) => IpaqPromise;
  deleteIpaq: (where: IpaqWhereUniqueInput) => IpaqPromise;
  deleteManyIpaqs: (where?: IpaqWhereInput) => BatchPayloadPromise;
  createIpaqAnswers: (data: IpaqAnswersCreateInput) => IpaqAnswersPromise;
  updateIpaqAnswers: (args: {
    data: IpaqAnswersUpdateInput;
    where: IpaqAnswersWhereUniqueInput;
  }) => IpaqAnswersPromise;
  updateManyIpaqAnswerses: (args: {
    data: IpaqAnswersUpdateManyMutationInput;
    where?: IpaqAnswersWhereInput;
  }) => BatchPayloadPromise;
  upsertIpaqAnswers: (args: {
    where: IpaqAnswersWhereUniqueInput;
    create: IpaqAnswersCreateInput;
    update: IpaqAnswersUpdateInput;
  }) => IpaqAnswersPromise;
  deleteIpaqAnswers: (where: IpaqAnswersWhereUniqueInput) => IpaqAnswersPromise;
  deleteManyIpaqAnswerses: (
    where?: IpaqAnswersWhereInput
  ) => BatchPayloadPromise;
  createJoinedChallenges: (
    data: JoinedChallengesCreateInput
  ) => JoinedChallengesPromise;
  updateJoinedChallenges: (args: {
    data: JoinedChallengesUpdateInput;
    where: JoinedChallengesWhereUniqueInput;
  }) => JoinedChallengesPromise;
  upsertJoinedChallenges: (args: {
    where: JoinedChallengesWhereUniqueInput;
    create: JoinedChallengesCreateInput;
    update: JoinedChallengesUpdateInput;
  }) => JoinedChallengesPromise;
  deleteJoinedChallenges: (
    where: JoinedChallengesWhereUniqueInput
  ) => JoinedChallengesPromise;
  deleteManyJoinedChallengeses: (
    where?: JoinedChallengesWhereInput
  ) => BatchPayloadPromise;
  createPatient: (data: PatientCreateInput) => PatientPromise;
  updatePatient: (args: {
    data: PatientUpdateInput;
    where: PatientWhereUniqueInput;
  }) => PatientPromise;
  updateManyPatients: (args: {
    data: PatientUpdateManyMutationInput;
    where?: PatientWhereInput;
  }) => BatchPayloadPromise;
  upsertPatient: (args: {
    where: PatientWhereUniqueInput;
    create: PatientCreateInput;
    update: PatientUpdateInput;
  }) => PatientPromise;
  deletePatient: (where: PatientWhereUniqueInput) => PatientPromise;
  deleteManyPatients: (where?: PatientWhereInput) => BatchPayloadPromise;
  createPatientProfileInfo: (
    data: PatientProfileInfoCreateInput
  ) => PatientProfileInfoPromise;
  updatePatientProfileInfo: (args: {
    data: PatientProfileInfoUpdateInput;
    where: PatientProfileInfoWhereUniqueInput;
  }) => PatientProfileInfoPromise;
  updateManyPatientProfileInfoes: (args: {
    data: PatientProfileInfoUpdateManyMutationInput;
    where?: PatientProfileInfoWhereInput;
  }) => BatchPayloadPromise;
  upsertPatientProfileInfo: (args: {
    where: PatientProfileInfoWhereUniqueInput;
    create: PatientProfileInfoCreateInput;
    update: PatientProfileInfoUpdateInput;
  }) => PatientProfileInfoPromise;
  deletePatientProfileInfo: (
    where: PatientProfileInfoWhereUniqueInput
  ) => PatientProfileInfoPromise;
  deleteManyPatientProfileInfoes: (
    where?: PatientProfileInfoWhereInput
  ) => BatchPayloadPromise;
  createPhq9: (data: Phq9CreateInput) => Phq9Promise;
  updatePhq9: (args: {
    data: Phq9UpdateInput;
    where: Phq9WhereUniqueInput;
  }) => Phq9Promise;
  updateManyPhq9s: (args: {
    data: Phq9UpdateManyMutationInput;
    where?: Phq9WhereInput;
  }) => BatchPayloadPromise;
  upsertPhq9: (args: {
    where: Phq9WhereUniqueInput;
    create: Phq9CreateInput;
    update: Phq9UpdateInput;
  }) => Phq9Promise;
  deletePhq9: (where: Phq9WhereUniqueInput) => Phq9Promise;
  deleteManyPhq9s: (where?: Phq9WhereInput) => BatchPayloadPromise;
  createProfileActivity: (
    data: ProfileActivityCreateInput
  ) => ProfileActivityPromise;
  updateProfileActivity: (args: {
    data: ProfileActivityUpdateInput;
    where: ProfileActivityWhereUniqueInput;
  }) => ProfileActivityPromise;
  updateManyProfileActivities: (args: {
    data: ProfileActivityUpdateManyMutationInput;
    where?: ProfileActivityWhereInput;
  }) => BatchPayloadPromise;
  upsertProfileActivity: (args: {
    where: ProfileActivityWhereUniqueInput;
    create: ProfileActivityCreateInput;
    update: ProfileActivityUpdateInput;
  }) => ProfileActivityPromise;
  deleteProfileActivity: (
    where: ProfileActivityWhereUniqueInput
  ) => ProfileActivityPromise;
  deleteManyProfileActivities: (
    where?: ProfileActivityWhereInput
  ) => BatchPayloadPromise;
  createQuestionnaires: (
    data: QuestionnairesCreateInput
  ) => QuestionnairesPromise;
  updateQuestionnaires: (args: {
    data: QuestionnairesUpdateInput;
    where: QuestionnairesWhereUniqueInput;
  }) => QuestionnairesPromise;
  upsertQuestionnaires: (args: {
    where: QuestionnairesWhereUniqueInput;
    create: QuestionnairesCreateInput;
    update: QuestionnairesUpdateInput;
  }) => QuestionnairesPromise;
  deleteQuestionnaires: (
    where: QuestionnairesWhereUniqueInput
  ) => QuestionnairesPromise;
  deleteManyQuestionnaireses: (
    where?: QuestionnairesWhereInput
  ) => BatchPayloadPromise;
  createScheduledTask: (data: ScheduledTaskCreateInput) => ScheduledTaskPromise;
  updateScheduledTask: (args: {
    data: ScheduledTaskUpdateInput;
    where: ScheduledTaskWhereUniqueInput;
  }) => ScheduledTaskPromise;
  updateManyScheduledTasks: (args: {
    data: ScheduledTaskUpdateManyMutationInput;
    where?: ScheduledTaskWhereInput;
  }) => BatchPayloadPromise;
  upsertScheduledTask: (args: {
    where: ScheduledTaskWhereUniqueInput;
    create: ScheduledTaskCreateInput;
    update: ScheduledTaskUpdateInput;
  }) => ScheduledTaskPromise;
  deleteScheduledTask: (
    where: ScheduledTaskWhereUniqueInput
  ) => ScheduledTaskPromise;
  deleteManyScheduledTasks: (
    where?: ScheduledTaskWhereInput
  ) => BatchPayloadPromise;
  createSensorData: (data: SensorDataCreateInput) => SensorDataPromise;
  updateSensorData: (args: {
    data: SensorDataUpdateInput;
    where: SensorDataWhereUniqueInput;
  }) => SensorDataPromise;
  updateManySensorDatas: (args: {
    data: SensorDataUpdateManyMutationInput;
    where?: SensorDataWhereInput;
  }) => BatchPayloadPromise;
  upsertSensorData: (args: {
    where: SensorDataWhereUniqueInput;
    create: SensorDataCreateInput;
    update: SensorDataUpdateInput;
  }) => SensorDataPromise;
  deleteSensorData: (where: SensorDataWhereUniqueInput) => SensorDataPromise;
  deleteManySensorDatas: (where?: SensorDataWhereInput) => BatchPayloadPromise;
  createTimeSpan: (data: TimeSpanCreateInput) => TimeSpanPromise;
  updateTimeSpan: (args: {
    data: TimeSpanUpdateInput;
    where: TimeSpanWhereUniqueInput;
  }) => TimeSpanPromise;
  updateManyTimeSpans: (args: {
    data: TimeSpanUpdateManyMutationInput;
    where?: TimeSpanWhereInput;
  }) => BatchPayloadPromise;
  upsertTimeSpan: (args: {
    where: TimeSpanWhereUniqueInput;
    create: TimeSpanCreateInput;
    update: TimeSpanUpdateInput;
  }) => TimeSpanPromise;
  deleteTimeSpan: (where: TimeSpanWhereUniqueInput) => TimeSpanPromise;
  deleteManyTimeSpans: (where?: TimeSpanWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserSettings: (data: UserSettingsCreateInput) => UserSettingsPromise;
  updateUserSettings: (args: {
    data: UserSettingsUpdateInput;
    where: UserSettingsWhereUniqueInput;
  }) => UserSettingsPromise;
  updateManyUserSettingses: (args: {
    data: UserSettingsUpdateManyMutationInput;
    where?: UserSettingsWhereInput;
  }) => BatchPayloadPromise;
  upsertUserSettings: (args: {
    where: UserSettingsWhereUniqueInput;
    create: UserSettingsCreateInput;
    update: UserSettingsUpdateInput;
  }) => UserSettingsPromise;
  deleteUserSettings: (
    where: UserSettingsWhereUniqueInput
  ) => UserSettingsPromise;
  deleteManyUserSettingses: (
    where?: UserSettingsWhereInput
  ) => BatchPayloadPromise;
  createVoting: (data: VotingCreateInput) => VotingPromise;
  updateVoting: (args: {
    data: VotingUpdateInput;
    where: VotingWhereUniqueInput;
  }) => VotingPromise;
  updateManyVotings: (args: {
    data: VotingUpdateManyMutationInput;
    where?: VotingWhereInput;
  }) => BatchPayloadPromise;
  upsertVoting: (args: {
    where: VotingWhereUniqueInput;
    create: VotingCreateInput;
    update: VotingUpdateInput;
  }) => VotingPromise;
  deleteVoting: (where: VotingWhereUniqueInput) => VotingPromise;
  deleteManyVotings: (where?: VotingWhereInput) => BatchPayloadPromise;
  createWebPushNotification: (
    data: WebPushNotificationCreateInput
  ) => WebPushNotificationPromise;
  updateWebPushNotification: (args: {
    data: WebPushNotificationUpdateInput;
    where: WebPushNotificationWhereUniqueInput;
  }) => WebPushNotificationPromise;
  updateManyWebPushNotifications: (args: {
    data: WebPushNotificationUpdateManyMutationInput;
    where?: WebPushNotificationWhereInput;
  }) => BatchPayloadPromise;
  upsertWebPushNotification: (args: {
    where: WebPushNotificationWhereUniqueInput;
    create: WebPushNotificationCreateInput;
    update: WebPushNotificationUpdateInput;
  }) => WebPushNotificationPromise;
  deleteWebPushNotification: (
    where: WebPushNotificationWhereUniqueInput
  ) => WebPushNotificationPromise;
  deleteManyWebPushNotifications: (
    where?: WebPushNotificationWhereInput
  ) => BatchPayloadPromise;
  createWebPushSettings: (
    data: WebPushSettingsCreateInput
  ) => WebPushSettingsPromise;
  updateWebPushSettings: (args: {
    data: WebPushSettingsUpdateInput;
    where: WebPushSettingsWhereUniqueInput;
  }) => WebPushSettingsPromise;
  updateManyWebPushSettingses: (args: {
    data: WebPushSettingsUpdateManyMutationInput;
    where?: WebPushSettingsWhereInput;
  }) => BatchPayloadPromise;
  upsertWebPushSettings: (args: {
    where: WebPushSettingsWhereUniqueInput;
    create: WebPushSettingsCreateInput;
    update: WebPushSettingsUpdateInput;
  }) => WebPushSettingsPromise;
  deleteWebPushSettings: (
    where: WebPushSettingsWhereUniqueInput
  ) => WebPushSettingsPromise;
  deleteManyWebPushSettingses: (
    where?: WebPushSettingsWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  activity: (
    where?: ActivitySubscriptionWhereInput
  ) => ActivitySubscriptionPayloadSubscription;
  award: (
    where?: AwardSubscriptionWhereInput
  ) => AwardSubscriptionPayloadSubscription;
  bot: (
    where?: BotSubscriptionWhereInput
  ) => BotSubscriptionPayloadSubscription;
  botSettings: (
    where?: BotSettingsSubscriptionWhereInput
  ) => BotSettingsSubscriptionPayloadSubscription;
  buddy: (
    where?: BuddySubscriptionWhereInput
  ) => BuddySubscriptionPayloadSubscription;
  buddyRequest: (
    where?: BuddyRequestSubscriptionWhereInput
  ) => BuddyRequestSubscriptionPayloadSubscription;
  calendarEntry: (
    where?: CalendarEntrySubscriptionWhereInput
  ) => CalendarEntrySubscriptionPayloadSubscription;
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  challenge: (
    where?: ChallengeSubscriptionWhereInput
  ) => ChallengeSubscriptionPayloadSubscription;
  challengeCategory: (
    where?: ChallengeCategorySubscriptionWhereInput
  ) => ChallengeCategorySubscriptionPayloadSubscription;
  challengeGroup: (
    where?: ChallengeGroupSubscriptionWhereInput
  ) => ChallengeGroupSubscriptionPayloadSubscription;
  chat: (
    where?: ChatSubscriptionWhereInput
  ) => ChatSubscriptionPayloadSubscription;
  chatMessage: (
    where?: ChatMessageSubscriptionWhereInput
  ) => ChatMessageSubscriptionPayloadSubscription;
  chatMessageAttachment: (
    where?: ChatMessageAttachmentSubscriptionWhereInput
  ) => ChatMessageAttachmentSubscriptionPayloadSubscription;
  contribution: (
    where?: ContributionSubscriptionWhereInput
  ) => ContributionSubscriptionPayloadSubscription;
  favoriteActivity: (
    where?: FavoriteActivitySubscriptionWhereInput
  ) => FavoriteActivitySubscriptionPayloadSubscription;
  globalSettings: (
    where?: GlobalSettingsSubscriptionWhereInput
  ) => GlobalSettingsSubscriptionPayloadSubscription;
  group: (
    where?: GroupSubscriptionWhereInput
  ) => GroupSubscriptionPayloadSubscription;
  groupColor: (
    where?: GroupColorSubscriptionWhereInput
  ) => GroupColorSubscriptionPayloadSubscription;
  initiator: (
    where?: InitiatorSubscriptionWhereInput
  ) => InitiatorSubscriptionPayloadSubscription;
  ipaq: (
    where?: IpaqSubscriptionWhereInput
  ) => IpaqSubscriptionPayloadSubscription;
  ipaqAnswers: (
    where?: IpaqAnswersSubscriptionWhereInput
  ) => IpaqAnswersSubscriptionPayloadSubscription;
  joinedChallenges: (
    where?: JoinedChallengesSubscriptionWhereInput
  ) => JoinedChallengesSubscriptionPayloadSubscription;
  patient: (
    where?: PatientSubscriptionWhereInput
  ) => PatientSubscriptionPayloadSubscription;
  patientProfileInfo: (
    where?: PatientProfileInfoSubscriptionWhereInput
  ) => PatientProfileInfoSubscriptionPayloadSubscription;
  phq9: (
    where?: Phq9SubscriptionWhereInput
  ) => Phq9SubscriptionPayloadSubscription;
  profileActivity: (
    where?: ProfileActivitySubscriptionWhereInput
  ) => ProfileActivitySubscriptionPayloadSubscription;
  questionnaires: (
    where?: QuestionnairesSubscriptionWhereInput
  ) => QuestionnairesSubscriptionPayloadSubscription;
  scheduledTask: (
    where?: ScheduledTaskSubscriptionWhereInput
  ) => ScheduledTaskSubscriptionPayloadSubscription;
  sensorData: (
    where?: SensorDataSubscriptionWhereInput
  ) => SensorDataSubscriptionPayloadSubscription;
  timeSpan: (
    where?: TimeSpanSubscriptionWhereInput
  ) => TimeSpanSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userSettings: (
    where?: UserSettingsSubscriptionWhereInput
  ) => UserSettingsSubscriptionPayloadSubscription;
  voting: (
    where?: VotingSubscriptionWhereInput
  ) => VotingSubscriptionPayloadSubscription;
  webPushNotification: (
    where?: WebPushNotificationSubscriptionWhereInput
  ) => WebPushNotificationSubscriptionPayloadSubscription;
  webPushSettings: (
    where?: WebPushSettingsSubscriptionWhereInput
  ) => WebPushSettingsSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ActivityGrade = "LIGHT" | "MODERATE" | "HARD";

export type ActivityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "key_ASC"
  | "key_DESC"
  | "titel_ASC"
  | "titel_DESC"
  | "description_ASC"
  | "description_DESC"
  | "grade_ASC"
  | "grade_DESC"
  | "icon_ASC"
  | "icon_DESC"
  | "isCustom_ASC"
  | "isCustom_DESC"
  | "color_ASC"
  | "color_DESC";

export type UserRole = "ADMIN" | "DOCTOR" | "PATIENT" | "USER";

export type Gender = "MALE" | "FEMALE" | "DIVERSE";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC"
  | "role_ASC"
  | "role_DESC"
  | "lastActive_ASC"
  | "lastActive_DESC";

export type WebPushNotificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "notificationInformation_ASC"
  | "notificationInformation_DESC";

export type ProfileActivityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "key_ASC"
  | "key_DESC"
  | "icon_ASC"
  | "icon_DESC"
  | "titel_ASC"
  | "titel_DESC";

export type ChatMessageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "text_ASC"
  | "text_DESC";

export type SensorDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "x_ASC"
  | "x_DESC"
  | "y_ASC"
  | "y_DESC"
  | "z_ASC"
  | "z_DESC"
  | "alpha_ASC"
  | "alpha_DESC"
  | "beta_ASC"
  | "beta_DESC"
  | "gamma_ASC"
  | "gamma_DESC";

export type Phq9OrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "score_ASC"
  | "score_DESC"
  | "isComplete_ASC"
  | "isComplete_DESC"
  | "expiryDate_ASC"
  | "expiryDate_DESC";

export type IpaqOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "score_ASC"
  | "score_DESC"
  | "expiryDate_ASC"
  | "expiryDate_DESC"
  | "isComplete_ASC"
  | "isComplete_DESC";

export type IpaqAnswersOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "numDays_ASC"
  | "numDays_DESC"
  | "numHours_ASC"
  | "numHours_DESC"
  | "numMinutes_ASC"
  | "numMinutes_DESC";

export type FavoriteActivityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "activityKey_ASC"
  | "activityKey_DESC";

export type CalendarEntryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "isDone_ASC"
  | "isDone_DESC"
  | "isRunning_ASC"
  | "isRunning_DESC"
  | "trackingRequested_ASC"
  | "trackingRequested_DESC";

export type StatusChallegen = "ERSTELLT" | "GESTARTED" | "BEENDET";

export type GroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ChallengeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "image_ASC"
  | "image_DESC"
  | "premium_ASC"
  | "premium_DESC"
  | "timeEnd_ASC"
  | "timeEnd_DESC"
  | "emailSend_ASC"
  | "emailSend_DESC"
  | "status_ASC"
  | "status_DESC"
  | "initiator_ASC"
  | "initiator_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AwardVT = "GOLD" | "SILBER" | "BRONZ";

export type AwardOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BotOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type BotSettingsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "botFirstGreetingText_ASC"
  | "botFirstGreetingText_DESC"
  | "botAskCreateActivitiesMessage_ASC"
  | "botAskCreateActivitiesMessage_DESC"
  | "botActivityLessThanPlannedMessage_ASC"
  | "botActivityLessThanPlannedMessage_DESC"
  | "botActivityLessThanPlannedWeekday_ASC"
  | "botActivityLessThanPlannedWeekday_DESC"
  | "botAskStartChatMessage_ASC"
  | "botAskStartChatMessage_DESC";

export type BuddyOrderByInput = "id_ASC" | "id_DESC";

export type BuddyRequestState = "SEND" | "CONFIRMED" | "DENIED" | "REMOVED";

export type BuddyRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "state_ASC"
  | "state_DESC";

export type ChallengeCategoryOrderByInput = "id_ASC" | "id_DESC";

export type ChallengeGroupOrderByInput = "id_ASC" | "id_DESC";

export type ChatOrderByInput = "id_ASC" | "id_DESC";

export type ChatMessageAttachmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "originalCalendarEntryId_ASC"
  | "originalCalendarEntryId_DESC"
  | "ownerId_ASC"
  | "ownerId_DESC";

export type ContributionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "image_ASC"
  | "image_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GlobalSettingsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "matchingPercentageCap_ASC"
  | "matchingPercentageCap_DESC"
  | "defaultActivityTimeMinutesPerWeek_ASC"
  | "defaultActivityTimeMinutesPerWeek_DESC"
  | "minimumActivityTimeMinutes_ASC"
  | "minimumActivityTimeMinutes_DESC"
  | "maximumActivityTimeMinutes_ASC"
  | "maximumActivityTimeMinutes_DESC"
  | "ipaqGroupLowMax_ASC"
  | "ipaqGroupLowMax_DESC"
  | "ipaqGroupModerateMax_ASC"
  | "ipaqGroupModerateMax_DESC"
  | "ipaqGroupHighMax_ASC"
  | "ipaqGroupHighMax_DESC"
  | "phqGroupLowMin_ASC"
  | "phqGroupLowMin_DESC"
  | "phqGroupLowMax_ASC"
  | "phqGroupLowMax_DESC";

export type GroupColorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "color_ASC"
  | "color_DESC";

export type InitiatorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC";

export type JoinedChallengesOrderByInput = "id_ASC" | "id_DESC";

export type PatientOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "verificationCode_ASC"
  | "verificationCode_DESC"
  | "verified_ASC"
  | "verified_DESC"
  | "online_ASC"
  | "online_DESC"
  | "activeMinutesPerWeek_ASC"
  | "activeMinutesPerWeek_DESC";

export type PatientProfileInfoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "sameGender_ASC"
  | "sameGender_DESC"
  | "hideGender_ASC"
  | "hideGender_DESC"
  | "meetingDesired_ASC"
  | "meetingDesired_DESC"
  | "avatar_ASC"
  | "avatar_DESC";

export type QuestionnairesOrderByInput = "id_ASC" | "id_DESC";

export type TaskTypes =
  | "SYSTEM_SCHEDULE_REQUEST_DESTRUCTION"
  | "SYSTEM_AUTO_MATCH"
  | "PUSH_NOTIFY_NEW_CHAT_MESSAGE"
  | "BOT_WELCOME_MESSAGE"
  | "BOT_INTRODUCTION_CREATE_ACTIVITIES_TIME"
  | "BOT_INTRODUCTION_CREATE_ACTIVITIES_COUNT"
  | "BOT_PLANNED_ACTIVITIES_LOW"
  | "BOT_REMIND_TO_CHAT"
  | "PUSH_NOTIFY_IPAQ_REMINDER"
  | "PUSH_NOTIFY_IPAQ_REMINDER_FOLLOWUP"
  | "PUSH_NOTIFY_PHQ_REMINDER"
  | "PUSH_NOTIFY_PHQ_REMINDER_FOLLOWUP"
  | "PUSH_NOTIFY_INCOMING_BUDDY_REQUEST"
  | "PUSH_NOTIFY_INCOMING_BUDDY_REQUEST_REMINDER"
  | "PUSH_NOTIFY_INCOMING_BUDDY_REQUEST_REMINDER_FOLLOWUP"
  | "PUSH_NOTIFY_BUDDY_REQUEST_DENIED"
  | "PUSH_NOTIFY_NOT_ENOUGH_ACTIVITIES_USER"
  | "PUSH_NOTIFY_NOT_ENOUGH_ACTIVITIES_BUDDY"
  | "PUSH_NOTIFY_TO_MUCH_ACTIVITIES_USER"
  | "PUSH_NOTIFY_TO_MUCH_ACTIVITIES_BUDDY"
  | "PUSH_NOTIFY_MISSED_ACTIVITY_BUDDY";

export type ScheduledTaskOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "scheduledFor_ASC"
  | "scheduledFor_DESC"
  | "taskType_ASC"
  | "taskType_DESC"
  | "userId_ASC"
  | "userId_DESC"
  | "chatId_ASC"
  | "chatId_DESC"
  | "buddyRequestId_ASC"
  | "buddyRequestId_DESC";

export type TimeSpanOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "days_ASC"
  | "days_DESC"
  | "hours_ASC"
  | "hours_DESC"
  | "minutes_ASC"
  | "minutes_DESC"
  | "seconds_ASC"
  | "seconds_DESC";

export type UserSettingsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "themeName_ASC"
  | "themeName_DESC";

export type VotingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "votedPoint_ASC"
  | "votedPoint_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type WebPushSettingsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "webPushIpaqReminderMessage_ASC"
  | "webPushIpaqReminderMessage_DESC"
  | "webPushPhqReminderMessage_ASC"
  | "webPushPhqReminderMessage_DESC"
  | "webPushIncomingBuddyRequestMessage_ASC"
  | "webPushIncomingBuddyRequestMessage_DESC"
  | "webPushIncomingRequestNoResponseMessage_ASC"
  | "webPushIncomingRequestNoResponseMessage_DESC"
  | "webPushIncomingRequestNotAnsweredMessage_ASC"
  | "webPushIncomingRequestNotAnsweredMessage_DESC"
  | "webPushNotEnoughActivitiesMessage_ASC"
  | "webPushNotEnoughActivitiesMessage_DESC"
  | "webPushNotEnoughActivitiesWeekday_ASC"
  | "webPushNotEnoughActivitiesWeekday_DESC"
  | "webPushNotEnoughActivitiesBuddyMessage_ASC"
  | "webPushNotEnoughActivitiesBuddyMessage_DESC"
  | "webPushNotEnoughActivitiesBuddyWeekday_ASC"
  | "webPushNotEnoughActivitiesBuddyWeekday_DESC"
  | "webPushToManyActivitiesMessage_ASC"
  | "webPushToManyActivitiesMessage_DESC"
  | "webPushToManyActivitiesWeekday_ASC"
  | "webPushToManyActivitiesWeekday_DESC"
  | "webPushToManyActivitiesBuddyMessage_ASC"
  | "webPushToManyActivitiesBuddyMessage_DESC"
  | "webPushActivityMissedBuddyMessage_ASC"
  | "webPushActivityMissedBuddyMessage_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ActivityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  key?: Maybe<String>;
}>;

export interface ActivityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  key?: Maybe<String>;
  key_not?: Maybe<String>;
  key_in?: Maybe<String[] | String>;
  key_not_in?: Maybe<String[] | String>;
  key_lt?: Maybe<String>;
  key_lte?: Maybe<String>;
  key_gt?: Maybe<String>;
  key_gte?: Maybe<String>;
  key_contains?: Maybe<String>;
  key_not_contains?: Maybe<String>;
  key_starts_with?: Maybe<String>;
  key_not_starts_with?: Maybe<String>;
  key_ends_with?: Maybe<String>;
  key_not_ends_with?: Maybe<String>;
  titel?: Maybe<String>;
  titel_not?: Maybe<String>;
  titel_in?: Maybe<String[] | String>;
  titel_not_in?: Maybe<String[] | String>;
  titel_lt?: Maybe<String>;
  titel_lte?: Maybe<String>;
  titel_gt?: Maybe<String>;
  titel_gte?: Maybe<String>;
  titel_contains?: Maybe<String>;
  titel_not_contains?: Maybe<String>;
  titel_starts_with?: Maybe<String>;
  titel_not_starts_with?: Maybe<String>;
  titel_ends_with?: Maybe<String>;
  titel_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  grade?: Maybe<ActivityGrade>;
  grade_not?: Maybe<ActivityGrade>;
  grade_in?: Maybe<ActivityGrade[] | ActivityGrade>;
  grade_not_in?: Maybe<ActivityGrade[] | ActivityGrade>;
  icon?: Maybe<String>;
  icon_not?: Maybe<String>;
  icon_in?: Maybe<String[] | String>;
  icon_not_in?: Maybe<String[] | String>;
  icon_lt?: Maybe<String>;
  icon_lte?: Maybe<String>;
  icon_gt?: Maybe<String>;
  icon_gte?: Maybe<String>;
  icon_contains?: Maybe<String>;
  icon_not_contains?: Maybe<String>;
  icon_starts_with?: Maybe<String>;
  icon_not_starts_with?: Maybe<String>;
  icon_ends_with?: Maybe<String>;
  icon_not_ends_with?: Maybe<String>;
  isCustom?: Maybe<Boolean>;
  isCustom_not?: Maybe<Boolean>;
  color?: Maybe<String>;
  color_not?: Maybe<String>;
  color_in?: Maybe<String[] | String>;
  color_not_in?: Maybe<String[] | String>;
  color_lt?: Maybe<String>;
  color_lte?: Maybe<String>;
  color_gt?: Maybe<String>;
  color_gte?: Maybe<String>;
  color_contains?: Maybe<String>;
  color_not_contains?: Maybe<String>;
  color_starts_with?: Maybe<String>;
  color_not_starts_with?: Maybe<String>;
  color_ends_with?: Maybe<String>;
  color_not_ends_with?: Maybe<String>;
  AND?: Maybe<ActivityWhereInput[] | ActivityWhereInput>;
  OR?: Maybe<ActivityWhereInput[] | ActivityWhereInput>;
  NOT?: Maybe<ActivityWhereInput[] | ActivityWhereInput>;
}

export type AwardWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  role?: Maybe<UserRole>;
  role_not?: Maybe<UserRole>;
  role_in?: Maybe<UserRole[] | UserRole>;
  role_not_in?: Maybe<UserRole[] | UserRole>;
  settings?: Maybe<UserSettingsWhereInput>;
  notifications_every?: Maybe<WebPushNotificationWhereInput>;
  notifications_some?: Maybe<WebPushNotificationWhereInput>;
  notifications_none?: Maybe<WebPushNotificationWhereInput>;
  patient?: Maybe<PatientWhereInput>;
  lastActive?: Maybe<DateTimeInput>;
  lastActive_not?: Maybe<DateTimeInput>;
  lastActive_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastActive_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastActive_lt?: Maybe<DateTimeInput>;
  lastActive_lte?: Maybe<DateTimeInput>;
  lastActive_gt?: Maybe<DateTimeInput>;
  lastActive_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface UserSettingsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  themeName?: Maybe<String>;
  themeName_not?: Maybe<String>;
  themeName_in?: Maybe<String[] | String>;
  themeName_not_in?: Maybe<String[] | String>;
  themeName_lt?: Maybe<String>;
  themeName_lte?: Maybe<String>;
  themeName_gt?: Maybe<String>;
  themeName_gte?: Maybe<String>;
  themeName_contains?: Maybe<String>;
  themeName_not_contains?: Maybe<String>;
  themeName_starts_with?: Maybe<String>;
  themeName_not_starts_with?: Maybe<String>;
  themeName_ends_with?: Maybe<String>;
  themeName_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserSettingsWhereInput[] | UserSettingsWhereInput>;
  OR?: Maybe<UserSettingsWhereInput[] | UserSettingsWhereInput>;
  NOT?: Maybe<UserSettingsWhereInput[] | UserSettingsWhereInput>;
}

export interface WebPushNotificationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<WebPushNotificationWhereInput[] | WebPushNotificationWhereInput>;
  OR?: Maybe<WebPushNotificationWhereInput[] | WebPushNotificationWhereInput>;
  NOT?: Maybe<WebPushNotificationWhereInput[] | WebPushNotificationWhereInput>;
}

export interface PatientWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  verificationCode?: Maybe<String>;
  verificationCode_not?: Maybe<String>;
  verificationCode_in?: Maybe<String[] | String>;
  verificationCode_not_in?: Maybe<String[] | String>;
  verificationCode_lt?: Maybe<String>;
  verificationCode_lte?: Maybe<String>;
  verificationCode_gt?: Maybe<String>;
  verificationCode_gte?: Maybe<String>;
  verificationCode_contains?: Maybe<String>;
  verificationCode_not_contains?: Maybe<String>;
  verificationCode_starts_with?: Maybe<String>;
  verificationCode_not_starts_with?: Maybe<String>;
  verificationCode_ends_with?: Maybe<String>;
  verificationCode_not_ends_with?: Maybe<String>;
  verified?: Maybe<Boolean>;
  verified_not?: Maybe<Boolean>;
  profile?: Maybe<PatientProfileInfoWhereInput>;
  buddy?: Maybe<BuddyWhereInput>;
  quests?: Maybe<QuestionnairesWhereInput>;
  online?: Maybe<Boolean>;
  online_not?: Maybe<Boolean>;
  activities_every?: Maybe<ActivityWhereInput>;
  activities_some?: Maybe<ActivityWhereInput>;
  activities_none?: Maybe<ActivityWhereInput>;
  favoriteActivities_every?: Maybe<FavoriteActivityWhereInput>;
  favoriteActivities_some?: Maybe<FavoriteActivityWhereInput>;
  favoriteActivities_none?: Maybe<FavoriteActivityWhereInput>;
  calendarEntries_every?: Maybe<CalendarEntryWhereInput>;
  calendarEntries_some?: Maybe<CalendarEntryWhereInput>;
  calendarEntries_none?: Maybe<CalendarEntryWhereInput>;
  activeMinutesPerWeek?: Maybe<Int>;
  activeMinutesPerWeek_not?: Maybe<Int>;
  activeMinutesPerWeek_in?: Maybe<Int[] | Int>;
  activeMinutesPerWeek_not_in?: Maybe<Int[] | Int>;
  activeMinutesPerWeek_lt?: Maybe<Int>;
  activeMinutesPerWeek_lte?: Maybe<Int>;
  activeMinutesPerWeek_gt?: Maybe<Int>;
  activeMinutesPerWeek_gte?: Maybe<Int>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<PatientWhereInput[] | PatientWhereInput>;
  OR?: Maybe<PatientWhereInput[] | PatientWhereInput>;
  NOT?: Maybe<PatientWhereInput[] | PatientWhereInput>;
}

export interface PatientProfileInfoWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  birthday?: Maybe<DateTimeInput>;
  birthday_not?: Maybe<DateTimeInput>;
  birthday_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthday_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthday_lt?: Maybe<DateTimeInput>;
  birthday_lte?: Maybe<DateTimeInput>;
  birthday_gt?: Maybe<DateTimeInput>;
  birthday_gte?: Maybe<DateTimeInput>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  sameGender?: Maybe<Boolean>;
  sameGender_not?: Maybe<Boolean>;
  hideGender?: Maybe<Boolean>;
  hideGender_not?: Maybe<Boolean>;
  meetingDesired?: Maybe<Boolean>;
  meetingDesired_not?: Maybe<Boolean>;
  avatar?: Maybe<String>;
  avatar_not?: Maybe<String>;
  avatar_in?: Maybe<String[] | String>;
  avatar_not_in?: Maybe<String[] | String>;
  avatar_lt?: Maybe<String>;
  avatar_lte?: Maybe<String>;
  avatar_gt?: Maybe<String>;
  avatar_gte?: Maybe<String>;
  avatar_contains?: Maybe<String>;
  avatar_not_contains?: Maybe<String>;
  avatar_starts_with?: Maybe<String>;
  avatar_not_starts_with?: Maybe<String>;
  avatar_ends_with?: Maybe<String>;
  avatar_not_ends_with?: Maybe<String>;
  profileActivities_every?: Maybe<ProfileActivityWhereInput>;
  profileActivities_some?: Maybe<ProfileActivityWhereInput>;
  profileActivities_none?: Maybe<ProfileActivityWhereInput>;
  AND?: Maybe<PatientProfileInfoWhereInput[] | PatientProfileInfoWhereInput>;
  OR?: Maybe<PatientProfileInfoWhereInput[] | PatientProfileInfoWhereInput>;
  NOT?: Maybe<PatientProfileInfoWhereInput[] | PatientProfileInfoWhereInput>;
}

export interface ProfileActivityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  key?: Maybe<String>;
  key_not?: Maybe<String>;
  key_in?: Maybe<String[] | String>;
  key_not_in?: Maybe<String[] | String>;
  key_lt?: Maybe<String>;
  key_lte?: Maybe<String>;
  key_gt?: Maybe<String>;
  key_gte?: Maybe<String>;
  key_contains?: Maybe<String>;
  key_not_contains?: Maybe<String>;
  key_starts_with?: Maybe<String>;
  key_not_starts_with?: Maybe<String>;
  key_ends_with?: Maybe<String>;
  key_not_ends_with?: Maybe<String>;
  icon?: Maybe<String>;
  icon_not?: Maybe<String>;
  icon_in?: Maybe<String[] | String>;
  icon_not_in?: Maybe<String[] | String>;
  icon_lt?: Maybe<String>;
  icon_lte?: Maybe<String>;
  icon_gt?: Maybe<String>;
  icon_gte?: Maybe<String>;
  icon_contains?: Maybe<String>;
  icon_not_contains?: Maybe<String>;
  icon_starts_with?: Maybe<String>;
  icon_not_starts_with?: Maybe<String>;
  icon_ends_with?: Maybe<String>;
  icon_not_ends_with?: Maybe<String>;
  titel?: Maybe<String>;
  titel_not?: Maybe<String>;
  titel_in?: Maybe<String[] | String>;
  titel_not_in?: Maybe<String[] | String>;
  titel_lt?: Maybe<String>;
  titel_lte?: Maybe<String>;
  titel_gt?: Maybe<String>;
  titel_gte?: Maybe<String>;
  titel_contains?: Maybe<String>;
  titel_not_contains?: Maybe<String>;
  titel_starts_with?: Maybe<String>;
  titel_not_starts_with?: Maybe<String>;
  titel_ends_with?: Maybe<String>;
  titel_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProfileActivityWhereInput[] | ProfileActivityWhereInput>;
  OR?: Maybe<ProfileActivityWhereInput[] | ProfileActivityWhereInput>;
  NOT?: Maybe<ProfileActivityWhereInput[] | ProfileActivityWhereInput>;
}

export interface BuddyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  patient?: Maybe<PatientWhereInput>;
  chat?: Maybe<ChatWhereInput>;
  AND?: Maybe<BuddyWhereInput[] | BuddyWhereInput>;
  OR?: Maybe<BuddyWhereInput[] | BuddyWhereInput>;
  NOT?: Maybe<BuddyWhereInput[] | BuddyWhereInput>;
}

export interface ChatWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  messages_every?: Maybe<ChatMessageWhereInput>;
  messages_some?: Maybe<ChatMessageWhereInput>;
  messages_none?: Maybe<ChatMessageWhereInput>;
  bot?: Maybe<BotWhereInput>;
  AND?: Maybe<ChatWhereInput[] | ChatWhereInput>;
  OR?: Maybe<ChatWhereInput[] | ChatWhereInput>;
  NOT?: Maybe<ChatWhereInput[] | ChatWhereInput>;
}

export interface ChatMessageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  chat?: Maybe<ChatWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  author?: Maybe<UserWhereInput>;
  authorBot?: Maybe<BotWhereInput>;
  attachment?: Maybe<ChatMessageAttachmentWhereInput>;
  AND?: Maybe<ChatMessageWhereInput[] | ChatMessageWhereInput>;
  OR?: Maybe<ChatMessageWhereInput[] | ChatMessageWhereInput>;
  NOT?: Maybe<ChatMessageWhereInput[] | ChatMessageWhereInput>;
}

export interface BotWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  chat?: Maybe<ChatWhereInput>;
  AND?: Maybe<BotWhereInput[] | BotWhereInput>;
  OR?: Maybe<BotWhereInput[] | BotWhereInput>;
  NOT?: Maybe<BotWhereInput[] | BotWhereInput>;
}

export interface ChatMessageAttachmentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  calendarEntry?: Maybe<CalendarEntryWhereInput>;
  originalCalendarEntryId?: Maybe<ID_Input>;
  originalCalendarEntryId_not?: Maybe<ID_Input>;
  originalCalendarEntryId_in?: Maybe<ID_Input[] | ID_Input>;
  originalCalendarEntryId_not_in?: Maybe<ID_Input[] | ID_Input>;
  originalCalendarEntryId_lt?: Maybe<ID_Input>;
  originalCalendarEntryId_lte?: Maybe<ID_Input>;
  originalCalendarEntryId_gt?: Maybe<ID_Input>;
  originalCalendarEntryId_gte?: Maybe<ID_Input>;
  originalCalendarEntryId_contains?: Maybe<ID_Input>;
  originalCalendarEntryId_not_contains?: Maybe<ID_Input>;
  originalCalendarEntryId_starts_with?: Maybe<ID_Input>;
  originalCalendarEntryId_not_starts_with?: Maybe<ID_Input>;
  originalCalendarEntryId_ends_with?: Maybe<ID_Input>;
  originalCalendarEntryId_not_ends_with?: Maybe<ID_Input>;
  ownerId?: Maybe<ID_Input>;
  ownerId_not?: Maybe<ID_Input>;
  ownerId_in?: Maybe<ID_Input[] | ID_Input>;
  ownerId_not_in?: Maybe<ID_Input[] | ID_Input>;
  ownerId_lt?: Maybe<ID_Input>;
  ownerId_lte?: Maybe<ID_Input>;
  ownerId_gt?: Maybe<ID_Input>;
  ownerId_gte?: Maybe<ID_Input>;
  ownerId_contains?: Maybe<ID_Input>;
  ownerId_not_contains?: Maybe<ID_Input>;
  ownerId_starts_with?: Maybe<ID_Input>;
  ownerId_not_starts_with?: Maybe<ID_Input>;
  ownerId_ends_with?: Maybe<ID_Input>;
  ownerId_not_ends_with?: Maybe<ID_Input>;
  chatMessage?: Maybe<ChatMessageWhereInput>;
  AND?: Maybe<
    ChatMessageAttachmentWhereInput[] | ChatMessageAttachmentWhereInput
  >;
  OR?: Maybe<
    ChatMessageAttachmentWhereInput[] | ChatMessageAttachmentWhereInput
  >;
  NOT?: Maybe<
    ChatMessageAttachmentWhereInput[] | ChatMessageAttachmentWhereInput
  >;
}

export interface CalendarEntryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  activity?: Maybe<ActivityWhereInput>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  endTime_not?: Maybe<DateTimeInput>;
  endTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_lt?: Maybe<DateTimeInput>;
  endTime_lte?: Maybe<DateTimeInput>;
  endTime_gt?: Maybe<DateTimeInput>;
  endTime_gte?: Maybe<DateTimeInput>;
  isDone?: Maybe<Boolean>;
  isDone_not?: Maybe<Boolean>;
  isRunning?: Maybe<Boolean>;
  isRunning_not?: Maybe<Boolean>;
  trackingRequested?: Maybe<Boolean>;
  trackingRequested_not?: Maybe<Boolean>;
  patient?: Maybe<PatientWhereInput>;
  sensorData_every?: Maybe<SensorDataWhereInput>;
  sensorData_some?: Maybe<SensorDataWhereInput>;
  sensorData_none?: Maybe<SensorDataWhereInput>;
  AND?: Maybe<CalendarEntryWhereInput[] | CalendarEntryWhereInput>;
  OR?: Maybe<CalendarEntryWhereInput[] | CalendarEntryWhereInput>;
  NOT?: Maybe<CalendarEntryWhereInput[] | CalendarEntryWhereInput>;
}

export interface SensorDataWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  x?: Maybe<Float>;
  x_not?: Maybe<Float>;
  x_in?: Maybe<Float[] | Float>;
  x_not_in?: Maybe<Float[] | Float>;
  x_lt?: Maybe<Float>;
  x_lte?: Maybe<Float>;
  x_gt?: Maybe<Float>;
  x_gte?: Maybe<Float>;
  y?: Maybe<Float>;
  y_not?: Maybe<Float>;
  y_in?: Maybe<Float[] | Float>;
  y_not_in?: Maybe<Float[] | Float>;
  y_lt?: Maybe<Float>;
  y_lte?: Maybe<Float>;
  y_gt?: Maybe<Float>;
  y_gte?: Maybe<Float>;
  z?: Maybe<Float>;
  z_not?: Maybe<Float>;
  z_in?: Maybe<Float[] | Float>;
  z_not_in?: Maybe<Float[] | Float>;
  z_lt?: Maybe<Float>;
  z_lte?: Maybe<Float>;
  z_gt?: Maybe<Float>;
  z_gte?: Maybe<Float>;
  alpha?: Maybe<Float>;
  alpha_not?: Maybe<Float>;
  alpha_in?: Maybe<Float[] | Float>;
  alpha_not_in?: Maybe<Float[] | Float>;
  alpha_lt?: Maybe<Float>;
  alpha_lte?: Maybe<Float>;
  alpha_gt?: Maybe<Float>;
  alpha_gte?: Maybe<Float>;
  beta?: Maybe<Float>;
  beta_not?: Maybe<Float>;
  beta_in?: Maybe<Float[] | Float>;
  beta_not_in?: Maybe<Float[] | Float>;
  beta_lt?: Maybe<Float>;
  beta_lte?: Maybe<Float>;
  beta_gt?: Maybe<Float>;
  beta_gte?: Maybe<Float>;
  gamma?: Maybe<Float>;
  gamma_not?: Maybe<Float>;
  gamma_in?: Maybe<Float[] | Float>;
  gamma_not_in?: Maybe<Float[] | Float>;
  gamma_lt?: Maybe<Float>;
  gamma_lte?: Maybe<Float>;
  gamma_gt?: Maybe<Float>;
  gamma_gte?: Maybe<Float>;
  AND?: Maybe<SensorDataWhereInput[] | SensorDataWhereInput>;
  OR?: Maybe<SensorDataWhereInput[] | SensorDataWhereInput>;
  NOT?: Maybe<SensorDataWhereInput[] | SensorDataWhereInput>;
}

export interface QuestionnairesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  phq9s_every?: Maybe<Phq9WhereInput>;
  phq9s_some?: Maybe<Phq9WhereInput>;
  phq9s_none?: Maybe<Phq9WhereInput>;
  ipaqs_every?: Maybe<IpaqWhereInput>;
  ipaqs_some?: Maybe<IpaqWhereInput>;
  ipaqs_none?: Maybe<IpaqWhereInput>;
  patient?: Maybe<PatientWhereInput>;
  AND?: Maybe<QuestionnairesWhereInput[] | QuestionnairesWhereInput>;
  OR?: Maybe<QuestionnairesWhereInput[] | QuestionnairesWhereInput>;
  NOT?: Maybe<QuestionnairesWhereInput[] | QuestionnairesWhereInput>;
}

export interface Phq9WhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  score?: Maybe<Int>;
  score_not?: Maybe<Int>;
  score_in?: Maybe<Int[] | Int>;
  score_not_in?: Maybe<Int[] | Int>;
  score_lt?: Maybe<Int>;
  score_lte?: Maybe<Int>;
  score_gt?: Maybe<Int>;
  score_gte?: Maybe<Int>;
  isComplete?: Maybe<Boolean>;
  isComplete_not?: Maybe<Boolean>;
  expiryDate?: Maybe<DateTimeInput>;
  expiryDate_not?: Maybe<DateTimeInput>;
  expiryDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiryDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiryDate_lt?: Maybe<DateTimeInput>;
  expiryDate_lte?: Maybe<DateTimeInput>;
  expiryDate_gt?: Maybe<DateTimeInput>;
  expiryDate_gte?: Maybe<DateTimeInput>;
  quests?: Maybe<QuestionnairesWhereInput>;
  AND?: Maybe<Phq9WhereInput[] | Phq9WhereInput>;
  OR?: Maybe<Phq9WhereInput[] | Phq9WhereInput>;
  NOT?: Maybe<Phq9WhereInput[] | Phq9WhereInput>;
}

export interface IpaqWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  answers_every?: Maybe<IpaqAnswersWhereInput>;
  answers_some?: Maybe<IpaqAnswersWhereInput>;
  answers_none?: Maybe<IpaqAnswersWhereInput>;
  score?: Maybe<Float>;
  score_not?: Maybe<Float>;
  score_in?: Maybe<Float[] | Float>;
  score_not_in?: Maybe<Float[] | Float>;
  score_lt?: Maybe<Float>;
  score_lte?: Maybe<Float>;
  score_gt?: Maybe<Float>;
  score_gte?: Maybe<Float>;
  expiryDate?: Maybe<DateTimeInput>;
  expiryDate_not?: Maybe<DateTimeInput>;
  expiryDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiryDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiryDate_lt?: Maybe<DateTimeInput>;
  expiryDate_lte?: Maybe<DateTimeInput>;
  expiryDate_gt?: Maybe<DateTimeInput>;
  expiryDate_gte?: Maybe<DateTimeInput>;
  isComplete?: Maybe<Boolean>;
  isComplete_not?: Maybe<Boolean>;
  quests?: Maybe<QuestionnairesWhereInput>;
  AND?: Maybe<IpaqWhereInput[] | IpaqWhereInput>;
  OR?: Maybe<IpaqWhereInput[] | IpaqWhereInput>;
  NOT?: Maybe<IpaqWhereInput[] | IpaqWhereInput>;
}

export interface IpaqAnswersWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  numDays?: Maybe<Int>;
  numDays_not?: Maybe<Int>;
  numDays_in?: Maybe<Int[] | Int>;
  numDays_not_in?: Maybe<Int[] | Int>;
  numDays_lt?: Maybe<Int>;
  numDays_lte?: Maybe<Int>;
  numDays_gt?: Maybe<Int>;
  numDays_gte?: Maybe<Int>;
  numHours?: Maybe<Int>;
  numHours_not?: Maybe<Int>;
  numHours_in?: Maybe<Int[] | Int>;
  numHours_not_in?: Maybe<Int[] | Int>;
  numHours_lt?: Maybe<Int>;
  numHours_lte?: Maybe<Int>;
  numHours_gt?: Maybe<Int>;
  numHours_gte?: Maybe<Int>;
  numMinutes?: Maybe<Int>;
  numMinutes_not?: Maybe<Int>;
  numMinutes_in?: Maybe<Int[] | Int>;
  numMinutes_not_in?: Maybe<Int[] | Int>;
  numMinutes_lt?: Maybe<Int>;
  numMinutes_lte?: Maybe<Int>;
  numMinutes_gt?: Maybe<Int>;
  numMinutes_gte?: Maybe<Int>;
  quest?: Maybe<IpaqWhereInput>;
  AND?: Maybe<IpaqAnswersWhereInput[] | IpaqAnswersWhereInput>;
  OR?: Maybe<IpaqAnswersWhereInput[] | IpaqAnswersWhereInput>;
  NOT?: Maybe<IpaqAnswersWhereInput[] | IpaqAnswersWhereInput>;
}

export interface FavoriteActivityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  activityKey?: Maybe<String>;
  activityKey_not?: Maybe<String>;
  activityKey_in?: Maybe<String[] | String>;
  activityKey_not_in?: Maybe<String[] | String>;
  activityKey_lt?: Maybe<String>;
  activityKey_lte?: Maybe<String>;
  activityKey_gt?: Maybe<String>;
  activityKey_gte?: Maybe<String>;
  activityKey_contains?: Maybe<String>;
  activityKey_not_contains?: Maybe<String>;
  activityKey_starts_with?: Maybe<String>;
  activityKey_not_starts_with?: Maybe<String>;
  activityKey_ends_with?: Maybe<String>;
  activityKey_not_ends_with?: Maybe<String>;
  AND?: Maybe<FavoriteActivityWhereInput[] | FavoriteActivityWhereInput>;
  OR?: Maybe<FavoriteActivityWhereInput[] | FavoriteActivityWhereInput>;
  NOT?: Maybe<FavoriteActivityWhereInput[] | FavoriteActivityWhereInput>;
}

export interface GroupWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdBy?: Maybe<UserWhereInput>;
  challenge_every?: Maybe<ChallengeWhereInput>;
  challenge_some?: Maybe<ChallengeWhereInput>;
  challenge_none?: Maybe<ChallengeWhereInput>;
  AND?: Maybe<GroupWhereInput[] | GroupWhereInput>;
  OR?: Maybe<GroupWhereInput[] | GroupWhereInput>;
  NOT?: Maybe<GroupWhereInput[] | GroupWhereInput>;
}

export interface ChallengeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  premium?: Maybe<String>;
  premium_not?: Maybe<String>;
  premium_in?: Maybe<String[] | String>;
  premium_not_in?: Maybe<String[] | String>;
  premium_lt?: Maybe<String>;
  premium_lte?: Maybe<String>;
  premium_gt?: Maybe<String>;
  premium_gte?: Maybe<String>;
  premium_contains?: Maybe<String>;
  premium_not_contains?: Maybe<String>;
  premium_starts_with?: Maybe<String>;
  premium_not_starts_with?: Maybe<String>;
  premium_ends_with?: Maybe<String>;
  premium_not_ends_with?: Maybe<String>;
  timeEnd?: Maybe<DateTimeInput>;
  timeEnd_not?: Maybe<DateTimeInput>;
  timeEnd_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  timeEnd_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  timeEnd_lt?: Maybe<DateTimeInput>;
  timeEnd_lte?: Maybe<DateTimeInput>;
  timeEnd_gt?: Maybe<DateTimeInput>;
  timeEnd_gte?: Maybe<DateTimeInput>;
  emailSend?: Maybe<String>;
  emailSend_not?: Maybe<String>;
  emailSend_in?: Maybe<String[] | String>;
  emailSend_not_in?: Maybe<String[] | String>;
  emailSend_lt?: Maybe<String>;
  emailSend_lte?: Maybe<String>;
  emailSend_gt?: Maybe<String>;
  emailSend_gte?: Maybe<String>;
  emailSend_contains?: Maybe<String>;
  emailSend_not_contains?: Maybe<String>;
  emailSend_starts_with?: Maybe<String>;
  emailSend_not_starts_with?: Maybe<String>;
  emailSend_ends_with?: Maybe<String>;
  emailSend_not_ends_with?: Maybe<String>;
  jury_every?: Maybe<UserWhereInput>;
  jury_some?: Maybe<UserWhereInput>;
  jury_none?: Maybe<UserWhereInput>;
  group_every?: Maybe<GroupWhereInput>;
  group_some?: Maybe<GroupWhereInput>;
  group_none?: Maybe<GroupWhereInput>;
  category_every?: Maybe<CategoryWhereInput>;
  category_some?: Maybe<CategoryWhereInput>;
  category_none?: Maybe<CategoryWhereInput>;
  status?: Maybe<StatusChallegen>;
  status_not?: Maybe<StatusChallegen>;
  status_in?: Maybe<StatusChallegen[] | StatusChallegen>;
  status_not_in?: Maybe<StatusChallegen[] | StatusChallegen>;
  initiator?: Maybe<String>;
  initiator_not?: Maybe<String>;
  initiator_in?: Maybe<String[] | String>;
  initiator_not_in?: Maybe<String[] | String>;
  initiator_lt?: Maybe<String>;
  initiator_lte?: Maybe<String>;
  initiator_gt?: Maybe<String>;
  initiator_gte?: Maybe<String>;
  initiator_contains?: Maybe<String>;
  initiator_not_contains?: Maybe<String>;
  initiator_starts_with?: Maybe<String>;
  initiator_not_starts_with?: Maybe<String>;
  initiator_ends_with?: Maybe<String>;
  initiator_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdBy?: Maybe<UserWhereInput>;
  AND?: Maybe<ChallengeWhereInput[] | ChallengeWhereInput>;
  OR?: Maybe<ChallengeWhereInput[] | ChallengeWhereInput>;
  NOT?: Maybe<ChallengeWhereInput[] | ChallengeWhereInput>;
}

export interface CategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  challenge_every?: Maybe<ChallengeWhereInput>;
  challenge_some?: Maybe<ChallengeWhereInput>;
  challenge_none?: Maybe<ChallengeWhereInput>;
  AND?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  OR?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  NOT?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
}

export interface AwardWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  challengeID?: Maybe<ChallengeWhereInput>;
  contributionID?: Maybe<ContributionWhereInput>;
  votingID?: Maybe<VotingWhereInput>;
  createdBy?: Maybe<UserWhereInput>;
  status?: Maybe<AwardVT>;
  status_not?: Maybe<AwardVT>;
  status_in?: Maybe<AwardVT[] | AwardVT>;
  status_not_in?: Maybe<AwardVT[] | AwardVT>;
  winner?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AwardWhereInput[] | AwardWhereInput>;
  OR?: Maybe<AwardWhereInput[] | AwardWhereInput>;
  NOT?: Maybe<AwardWhereInput[] | AwardWhereInput>;
}

export interface ContributionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  challengeID?: Maybe<ChallengeWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdBy?: Maybe<UserWhereInput>;
  AND?: Maybe<ContributionWhereInput[] | ContributionWhereInput>;
  OR?: Maybe<ContributionWhereInput[] | ContributionWhereInput>;
  NOT?: Maybe<ContributionWhereInput[] | ContributionWhereInput>;
}

export interface VotingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  challengeID?: Maybe<ChallengeWhereInput>;
  contributionID?: Maybe<ContributionWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  votedPoint?: Maybe<Int>;
  votedPoint_not?: Maybe<Int>;
  votedPoint_in?: Maybe<Int[] | Int>;
  votedPoint_not_in?: Maybe<Int[] | Int>;
  votedPoint_lt?: Maybe<Int>;
  votedPoint_lte?: Maybe<Int>;
  votedPoint_gt?: Maybe<Int>;
  votedPoint_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdBy?: Maybe<UserWhereInput>;
  AND?: Maybe<VotingWhereInput[] | VotingWhereInput>;
  OR?: Maybe<VotingWhereInput[] | VotingWhereInput>;
  NOT?: Maybe<VotingWhereInput[] | VotingWhereInput>;
}

export type BotWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type BotSettingsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BotSettingsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  botFirstGreetingText?: Maybe<String>;
  botFirstGreetingText_not?: Maybe<String>;
  botFirstGreetingText_in?: Maybe<String[] | String>;
  botFirstGreetingText_not_in?: Maybe<String[] | String>;
  botFirstGreetingText_lt?: Maybe<String>;
  botFirstGreetingText_lte?: Maybe<String>;
  botFirstGreetingText_gt?: Maybe<String>;
  botFirstGreetingText_gte?: Maybe<String>;
  botFirstGreetingText_contains?: Maybe<String>;
  botFirstGreetingText_not_contains?: Maybe<String>;
  botFirstGreetingText_starts_with?: Maybe<String>;
  botFirstGreetingText_not_starts_with?: Maybe<String>;
  botFirstGreetingText_ends_with?: Maybe<String>;
  botFirstGreetingText_not_ends_with?: Maybe<String>;
  botFirstGreetingTextDelay?: Maybe<TimeSpanWhereInput>;
  botAskCreateActivitiesTime?: Maybe<TimeSpanWhereInput>;
  botAskCreateActivitiesMessage?: Maybe<String>;
  botAskCreateActivitiesMessage_not?: Maybe<String>;
  botAskCreateActivitiesMessage_in?: Maybe<String[] | String>;
  botAskCreateActivitiesMessage_not_in?: Maybe<String[] | String>;
  botAskCreateActivitiesMessage_lt?: Maybe<String>;
  botAskCreateActivitiesMessage_lte?: Maybe<String>;
  botAskCreateActivitiesMessage_gt?: Maybe<String>;
  botAskCreateActivitiesMessage_gte?: Maybe<String>;
  botAskCreateActivitiesMessage_contains?: Maybe<String>;
  botAskCreateActivitiesMessage_not_contains?: Maybe<String>;
  botAskCreateActivitiesMessage_starts_with?: Maybe<String>;
  botAskCreateActivitiesMessage_not_starts_with?: Maybe<String>;
  botAskCreateActivitiesMessage_ends_with?: Maybe<String>;
  botAskCreateActivitiesMessage_not_ends_with?: Maybe<String>;
  botActivityLessThanPlannedMessage?: Maybe<String>;
  botActivityLessThanPlannedMessage_not?: Maybe<String>;
  botActivityLessThanPlannedMessage_in?: Maybe<String[] | String>;
  botActivityLessThanPlannedMessage_not_in?: Maybe<String[] | String>;
  botActivityLessThanPlannedMessage_lt?: Maybe<String>;
  botActivityLessThanPlannedMessage_lte?: Maybe<String>;
  botActivityLessThanPlannedMessage_gt?: Maybe<String>;
  botActivityLessThanPlannedMessage_gte?: Maybe<String>;
  botActivityLessThanPlannedMessage_contains?: Maybe<String>;
  botActivityLessThanPlannedMessage_not_contains?: Maybe<String>;
  botActivityLessThanPlannedMessage_starts_with?: Maybe<String>;
  botActivityLessThanPlannedMessage_not_starts_with?: Maybe<String>;
  botActivityLessThanPlannedMessage_ends_with?: Maybe<String>;
  botActivityLessThanPlannedMessage_not_ends_with?: Maybe<String>;
  botActivityLessThanPlannedWeekday?: Maybe<Int>;
  botActivityLessThanPlannedWeekday_not?: Maybe<Int>;
  botActivityLessThanPlannedWeekday_in?: Maybe<Int[] | Int>;
  botActivityLessThanPlannedWeekday_not_in?: Maybe<Int[] | Int>;
  botActivityLessThanPlannedWeekday_lt?: Maybe<Int>;
  botActivityLessThanPlannedWeekday_lte?: Maybe<Int>;
  botActivityLessThanPlannedWeekday_gt?: Maybe<Int>;
  botActivityLessThanPlannedWeekday_gte?: Maybe<Int>;
  botAskStartChatIntervall?: Maybe<TimeSpanWhereInput>;
  botAskStartChatMessage?: Maybe<String>;
  botAskStartChatMessage_not?: Maybe<String>;
  botAskStartChatMessage_in?: Maybe<String[] | String>;
  botAskStartChatMessage_not_in?: Maybe<String[] | String>;
  botAskStartChatMessage_lt?: Maybe<String>;
  botAskStartChatMessage_lte?: Maybe<String>;
  botAskStartChatMessage_gt?: Maybe<String>;
  botAskStartChatMessage_gte?: Maybe<String>;
  botAskStartChatMessage_contains?: Maybe<String>;
  botAskStartChatMessage_not_contains?: Maybe<String>;
  botAskStartChatMessage_starts_with?: Maybe<String>;
  botAskStartChatMessage_not_starts_with?: Maybe<String>;
  botAskStartChatMessage_ends_with?: Maybe<String>;
  botAskStartChatMessage_not_ends_with?: Maybe<String>;
  AND?: Maybe<BotSettingsWhereInput[] | BotSettingsWhereInput>;
  OR?: Maybe<BotSettingsWhereInput[] | BotSettingsWhereInput>;
  NOT?: Maybe<BotSettingsWhereInput[] | BotSettingsWhereInput>;
}

export interface TimeSpanWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  days?: Maybe<Int>;
  days_not?: Maybe<Int>;
  days_in?: Maybe<Int[] | Int>;
  days_not_in?: Maybe<Int[] | Int>;
  days_lt?: Maybe<Int>;
  days_lte?: Maybe<Int>;
  days_gt?: Maybe<Int>;
  days_gte?: Maybe<Int>;
  hours?: Maybe<Int>;
  hours_not?: Maybe<Int>;
  hours_in?: Maybe<Int[] | Int>;
  hours_not_in?: Maybe<Int[] | Int>;
  hours_lt?: Maybe<Int>;
  hours_lte?: Maybe<Int>;
  hours_gt?: Maybe<Int>;
  hours_gte?: Maybe<Int>;
  minutes?: Maybe<Int>;
  minutes_not?: Maybe<Int>;
  minutes_in?: Maybe<Int[] | Int>;
  minutes_not_in?: Maybe<Int[] | Int>;
  minutes_lt?: Maybe<Int>;
  minutes_lte?: Maybe<Int>;
  minutes_gt?: Maybe<Int>;
  minutes_gte?: Maybe<Int>;
  seconds?: Maybe<Int>;
  seconds_not?: Maybe<Int>;
  seconds_in?: Maybe<Int[] | Int>;
  seconds_not_in?: Maybe<Int[] | Int>;
  seconds_lt?: Maybe<Int>;
  seconds_lte?: Maybe<Int>;
  seconds_gt?: Maybe<Int>;
  seconds_gte?: Maybe<Int>;
  AND?: Maybe<TimeSpanWhereInput[] | TimeSpanWhereInput>;
  OR?: Maybe<TimeSpanWhereInput[] | TimeSpanWhereInput>;
  NOT?: Maybe<TimeSpanWhereInput[] | TimeSpanWhereInput>;
}

export type BuddyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type BuddyRequestWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BuddyRequestWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  from?: Maybe<PatientWhereInput>;
  to?: Maybe<PatientWhereInput>;
  state?: Maybe<BuddyRequestState>;
  state_not?: Maybe<BuddyRequestState>;
  state_in?: Maybe<BuddyRequestState[] | BuddyRequestState>;
  state_not_in?: Maybe<BuddyRequestState[] | BuddyRequestState>;
  AND?: Maybe<BuddyRequestWhereInput[] | BuddyRequestWhereInput>;
  OR?: Maybe<BuddyRequestWhereInput[] | BuddyRequestWhereInput>;
  NOT?: Maybe<BuddyRequestWhereInput[] | BuddyRequestWhereInput>;
}

export type CalendarEntryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  title?: Maybe<String>;
}>;

export type ChallengeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  title?: Maybe<String>;
}>;

export type ChallengeCategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ChallengeCategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  challegeId?: Maybe<ChallengeWhereInput>;
  categoryID?: Maybe<GroupWhereInput>;
  AND?: Maybe<ChallengeCategoryWhereInput[] | ChallengeCategoryWhereInput>;
  OR?: Maybe<ChallengeCategoryWhereInput[] | ChallengeCategoryWhereInput>;
  NOT?: Maybe<ChallengeCategoryWhereInput[] | ChallengeCategoryWhereInput>;
}

export type ChallengeGroupWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ChallengeGroupWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  challegeId?: Maybe<ChallengeWhereInput>;
  groupID?: Maybe<GroupWhereInput>;
  AND?: Maybe<ChallengeGroupWhereInput[] | ChallengeGroupWhereInput>;
  OR?: Maybe<ChallengeGroupWhereInput[] | ChallengeGroupWhereInput>;
  NOT?: Maybe<ChallengeGroupWhereInput[] | ChallengeGroupWhereInput>;
}

export type ChatWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ChatMessageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ChatMessageAttachmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ContributionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type FavoriteActivityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  activityKey?: Maybe<String>;
}>;

export type GlobalSettingsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GlobalSettingsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  matchingPercentageCap?: Maybe<Int>;
  matchingPercentageCap_not?: Maybe<Int>;
  matchingPercentageCap_in?: Maybe<Int[] | Int>;
  matchingPercentageCap_not_in?: Maybe<Int[] | Int>;
  matchingPercentageCap_lt?: Maybe<Int>;
  matchingPercentageCap_lte?: Maybe<Int>;
  matchingPercentageCap_gt?: Maybe<Int>;
  matchingPercentageCap_gte?: Maybe<Int>;
  matchingTimeout?: Maybe<TimeSpanWhereInput>;
  defaultActivityTimeMinutesPerWeek?: Maybe<Int>;
  defaultActivityTimeMinutesPerWeek_not?: Maybe<Int>;
  defaultActivityTimeMinutesPerWeek_in?: Maybe<Int[] | Int>;
  defaultActivityTimeMinutesPerWeek_not_in?: Maybe<Int[] | Int>;
  defaultActivityTimeMinutesPerWeek_lt?: Maybe<Int>;
  defaultActivityTimeMinutesPerWeek_lte?: Maybe<Int>;
  defaultActivityTimeMinutesPerWeek_gt?: Maybe<Int>;
  defaultActivityTimeMinutesPerWeek_gte?: Maybe<Int>;
  minimumActivityTimeMinutes?: Maybe<Int>;
  minimumActivityTimeMinutes_not?: Maybe<Int>;
  minimumActivityTimeMinutes_in?: Maybe<Int[] | Int>;
  minimumActivityTimeMinutes_not_in?: Maybe<Int[] | Int>;
  minimumActivityTimeMinutes_lt?: Maybe<Int>;
  minimumActivityTimeMinutes_lte?: Maybe<Int>;
  minimumActivityTimeMinutes_gt?: Maybe<Int>;
  minimumActivityTimeMinutes_gte?: Maybe<Int>;
  maximumActivityTimeMinutes?: Maybe<Int>;
  maximumActivityTimeMinutes_not?: Maybe<Int>;
  maximumActivityTimeMinutes_in?: Maybe<Int[] | Int>;
  maximumActivityTimeMinutes_not_in?: Maybe<Int[] | Int>;
  maximumActivityTimeMinutes_lt?: Maybe<Int>;
  maximumActivityTimeMinutes_lte?: Maybe<Int>;
  maximumActivityTimeMinutes_gt?: Maybe<Int>;
  maximumActivityTimeMinutes_gte?: Maybe<Int>;
  ipaqGroupLowMax?: Maybe<Int>;
  ipaqGroupLowMax_not?: Maybe<Int>;
  ipaqGroupLowMax_in?: Maybe<Int[] | Int>;
  ipaqGroupLowMax_not_in?: Maybe<Int[] | Int>;
  ipaqGroupLowMax_lt?: Maybe<Int>;
  ipaqGroupLowMax_lte?: Maybe<Int>;
  ipaqGroupLowMax_gt?: Maybe<Int>;
  ipaqGroupLowMax_gte?: Maybe<Int>;
  ipaqGroupModerateMax?: Maybe<Int>;
  ipaqGroupModerateMax_not?: Maybe<Int>;
  ipaqGroupModerateMax_in?: Maybe<Int[] | Int>;
  ipaqGroupModerateMax_not_in?: Maybe<Int[] | Int>;
  ipaqGroupModerateMax_lt?: Maybe<Int>;
  ipaqGroupModerateMax_lte?: Maybe<Int>;
  ipaqGroupModerateMax_gt?: Maybe<Int>;
  ipaqGroupModerateMax_gte?: Maybe<Int>;
  ipaqGroupHighMax?: Maybe<Int>;
  ipaqGroupHighMax_not?: Maybe<Int>;
  ipaqGroupHighMax_in?: Maybe<Int[] | Int>;
  ipaqGroupHighMax_not_in?: Maybe<Int[] | Int>;
  ipaqGroupHighMax_lt?: Maybe<Int>;
  ipaqGroupHighMax_lte?: Maybe<Int>;
  ipaqGroupHighMax_gt?: Maybe<Int>;
  ipaqGroupHighMax_gte?: Maybe<Int>;
  phqGroupLowMin?: Maybe<Int>;
  phqGroupLowMin_not?: Maybe<Int>;
  phqGroupLowMin_in?: Maybe<Int[] | Int>;
  phqGroupLowMin_not_in?: Maybe<Int[] | Int>;
  phqGroupLowMin_lt?: Maybe<Int>;
  phqGroupLowMin_lte?: Maybe<Int>;
  phqGroupLowMin_gt?: Maybe<Int>;
  phqGroupLowMin_gte?: Maybe<Int>;
  phqGroupLowMax?: Maybe<Int>;
  phqGroupLowMax_not?: Maybe<Int>;
  phqGroupLowMax_in?: Maybe<Int[] | Int>;
  phqGroupLowMax_not_in?: Maybe<Int[] | Int>;
  phqGroupLowMax_lt?: Maybe<Int>;
  phqGroupLowMax_lte?: Maybe<Int>;
  phqGroupLowMax_gt?: Maybe<Int>;
  phqGroupLowMax_gte?: Maybe<Int>;
  botSettings?: Maybe<BotSettingsWhereInput>;
  webPushSettings?: Maybe<WebPushSettingsWhereInput>;
  AND?: Maybe<GlobalSettingsWhereInput[] | GlobalSettingsWhereInput>;
  OR?: Maybe<GlobalSettingsWhereInput[] | GlobalSettingsWhereInput>;
  NOT?: Maybe<GlobalSettingsWhereInput[] | GlobalSettingsWhereInput>;
}

export interface WebPushSettingsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  webPushIpaqReminderIntervall?: Maybe<TimeSpanWhereInput>;
  webPushIpaqReminderIntervallFollowUp?: Maybe<TimeSpanWhereInput>;
  webPushIpaqReminderMessage?: Maybe<String>;
  webPushIpaqReminderMessage_not?: Maybe<String>;
  webPushIpaqReminderMessage_in?: Maybe<String[] | String>;
  webPushIpaqReminderMessage_not_in?: Maybe<String[] | String>;
  webPushIpaqReminderMessage_lt?: Maybe<String>;
  webPushIpaqReminderMessage_lte?: Maybe<String>;
  webPushIpaqReminderMessage_gt?: Maybe<String>;
  webPushIpaqReminderMessage_gte?: Maybe<String>;
  webPushIpaqReminderMessage_contains?: Maybe<String>;
  webPushIpaqReminderMessage_not_contains?: Maybe<String>;
  webPushIpaqReminderMessage_starts_with?: Maybe<String>;
  webPushIpaqReminderMessage_not_starts_with?: Maybe<String>;
  webPushIpaqReminderMessage_ends_with?: Maybe<String>;
  webPushIpaqReminderMessage_not_ends_with?: Maybe<String>;
  webPushPhqReminderIntervall?: Maybe<TimeSpanWhereInput>;
  webPushPhqReminderIntervallFollowUp?: Maybe<TimeSpanWhereInput>;
  webPushPhqReminderMessage?: Maybe<String>;
  webPushPhqReminderMessage_not?: Maybe<String>;
  webPushPhqReminderMessage_in?: Maybe<String[] | String>;
  webPushPhqReminderMessage_not_in?: Maybe<String[] | String>;
  webPushPhqReminderMessage_lt?: Maybe<String>;
  webPushPhqReminderMessage_lte?: Maybe<String>;
  webPushPhqReminderMessage_gt?: Maybe<String>;
  webPushPhqReminderMessage_gte?: Maybe<String>;
  webPushPhqReminderMessage_contains?: Maybe<String>;
  webPushPhqReminderMessage_not_contains?: Maybe<String>;
  webPushPhqReminderMessage_starts_with?: Maybe<String>;
  webPushPhqReminderMessage_not_starts_with?: Maybe<String>;
  webPushPhqReminderMessage_ends_with?: Maybe<String>;
  webPushPhqReminderMessage_not_ends_with?: Maybe<String>;
  webPushIncomingBuddyRequestMessage?: Maybe<String>;
  webPushIncomingBuddyRequestMessage_not?: Maybe<String>;
  webPushIncomingBuddyRequestMessage_in?: Maybe<String[] | String>;
  webPushIncomingBuddyRequestMessage_not_in?: Maybe<String[] | String>;
  webPushIncomingBuddyRequestMessage_lt?: Maybe<String>;
  webPushIncomingBuddyRequestMessage_lte?: Maybe<String>;
  webPushIncomingBuddyRequestMessage_gt?: Maybe<String>;
  webPushIncomingBuddyRequestMessage_gte?: Maybe<String>;
  webPushIncomingBuddyRequestMessage_contains?: Maybe<String>;
  webPushIncomingBuddyRequestMessage_not_contains?: Maybe<String>;
  webPushIncomingBuddyRequestMessage_starts_with?: Maybe<String>;
  webPushIncomingBuddyRequestMessage_not_starts_with?: Maybe<String>;
  webPushIncomingBuddyRequestMessage_ends_with?: Maybe<String>;
  webPushIncomingBuddyRequestMessage_not_ends_with?: Maybe<String>;
  webPushIncomingBuddyRequestDelay?: Maybe<TimeSpanWhereInput>;
  webPushIncomingRequestNoResponseMessage?: Maybe<String>;
  webPushIncomingRequestNoResponseMessage_not?: Maybe<String>;
  webPushIncomingRequestNoResponseMessage_in?: Maybe<String[] | String>;
  webPushIncomingRequestNoResponseMessage_not_in?: Maybe<String[] | String>;
  webPushIncomingRequestNoResponseMessage_lt?: Maybe<String>;
  webPushIncomingRequestNoResponseMessage_lte?: Maybe<String>;
  webPushIncomingRequestNoResponseMessage_gt?: Maybe<String>;
  webPushIncomingRequestNoResponseMessage_gte?: Maybe<String>;
  webPushIncomingRequestNoResponseMessage_contains?: Maybe<String>;
  webPushIncomingRequestNoResponseMessage_not_contains?: Maybe<String>;
  webPushIncomingRequestNoResponseMessage_starts_with?: Maybe<String>;
  webPushIncomingRequestNoResponseMessage_not_starts_with?: Maybe<String>;
  webPushIncomingRequestNoResponseMessage_ends_with?: Maybe<String>;
  webPushIncomingRequestNoResponseMessage_not_ends_with?: Maybe<String>;
  webPushIncomingRequestNoResponseIntervall?: Maybe<TimeSpanWhereInput>;
  webPushIncomingRequestNoResponseFollowupIntervall?: Maybe<TimeSpanWhereInput>;
  webPushIncomingRequestNotAnsweredMessage?: Maybe<String>;
  webPushIncomingRequestNotAnsweredMessage_not?: Maybe<String>;
  webPushIncomingRequestNotAnsweredMessage_in?: Maybe<String[] | String>;
  webPushIncomingRequestNotAnsweredMessage_not_in?: Maybe<String[] | String>;
  webPushIncomingRequestNotAnsweredMessage_lt?: Maybe<String>;
  webPushIncomingRequestNotAnsweredMessage_lte?: Maybe<String>;
  webPushIncomingRequestNotAnsweredMessage_gt?: Maybe<String>;
  webPushIncomingRequestNotAnsweredMessage_gte?: Maybe<String>;
  webPushIncomingRequestNotAnsweredMessage_contains?: Maybe<String>;
  webPushIncomingRequestNotAnsweredMessage_not_contains?: Maybe<String>;
  webPushIncomingRequestNotAnsweredMessage_starts_with?: Maybe<String>;
  webPushIncomingRequestNotAnsweredMessage_not_starts_with?: Maybe<String>;
  webPushIncomingRequestNotAnsweredMessage_ends_with?: Maybe<String>;
  webPushIncomingRequestNotAnsweredMessage_not_ends_with?: Maybe<String>;
  webPushIncomingRequestNotAnsweredIntervall?: Maybe<TimeSpanWhereInput>;
  webPushNotEnoughActivitiesMessage?: Maybe<String>;
  webPushNotEnoughActivitiesMessage_not?: Maybe<String>;
  webPushNotEnoughActivitiesMessage_in?: Maybe<String[] | String>;
  webPushNotEnoughActivitiesMessage_not_in?: Maybe<String[] | String>;
  webPushNotEnoughActivitiesMessage_lt?: Maybe<String>;
  webPushNotEnoughActivitiesMessage_lte?: Maybe<String>;
  webPushNotEnoughActivitiesMessage_gt?: Maybe<String>;
  webPushNotEnoughActivitiesMessage_gte?: Maybe<String>;
  webPushNotEnoughActivitiesMessage_contains?: Maybe<String>;
  webPushNotEnoughActivitiesMessage_not_contains?: Maybe<String>;
  webPushNotEnoughActivitiesMessage_starts_with?: Maybe<String>;
  webPushNotEnoughActivitiesMessage_not_starts_with?: Maybe<String>;
  webPushNotEnoughActivitiesMessage_ends_with?: Maybe<String>;
  webPushNotEnoughActivitiesMessage_not_ends_with?: Maybe<String>;
  webPushNotEnoughActivitiesWeekday?: Maybe<Int>;
  webPushNotEnoughActivitiesWeekday_not?: Maybe<Int>;
  webPushNotEnoughActivitiesWeekday_in?: Maybe<Int[] | Int>;
  webPushNotEnoughActivitiesWeekday_not_in?: Maybe<Int[] | Int>;
  webPushNotEnoughActivitiesWeekday_lt?: Maybe<Int>;
  webPushNotEnoughActivitiesWeekday_lte?: Maybe<Int>;
  webPushNotEnoughActivitiesWeekday_gt?: Maybe<Int>;
  webPushNotEnoughActivitiesWeekday_gte?: Maybe<Int>;
  webPushNotEnoughActivitiesBuddyMessage?: Maybe<String>;
  webPushNotEnoughActivitiesBuddyMessage_not?: Maybe<String>;
  webPushNotEnoughActivitiesBuddyMessage_in?: Maybe<String[] | String>;
  webPushNotEnoughActivitiesBuddyMessage_not_in?: Maybe<String[] | String>;
  webPushNotEnoughActivitiesBuddyMessage_lt?: Maybe<String>;
  webPushNotEnoughActivitiesBuddyMessage_lte?: Maybe<String>;
  webPushNotEnoughActivitiesBuddyMessage_gt?: Maybe<String>;
  webPushNotEnoughActivitiesBuddyMessage_gte?: Maybe<String>;
  webPushNotEnoughActivitiesBuddyMessage_contains?: Maybe<String>;
  webPushNotEnoughActivitiesBuddyMessage_not_contains?: Maybe<String>;
  webPushNotEnoughActivitiesBuddyMessage_starts_with?: Maybe<String>;
  webPushNotEnoughActivitiesBuddyMessage_not_starts_with?: Maybe<String>;
  webPushNotEnoughActivitiesBuddyMessage_ends_with?: Maybe<String>;
  webPushNotEnoughActivitiesBuddyMessage_not_ends_with?: Maybe<String>;
  webPushNotEnoughActivitiesBuddyWeekday?: Maybe<Int>;
  webPushNotEnoughActivitiesBuddyWeekday_not?: Maybe<Int>;
  webPushNotEnoughActivitiesBuddyWeekday_in?: Maybe<Int[] | Int>;
  webPushNotEnoughActivitiesBuddyWeekday_not_in?: Maybe<Int[] | Int>;
  webPushNotEnoughActivitiesBuddyWeekday_lt?: Maybe<Int>;
  webPushNotEnoughActivitiesBuddyWeekday_lte?: Maybe<Int>;
  webPushNotEnoughActivitiesBuddyWeekday_gt?: Maybe<Int>;
  webPushNotEnoughActivitiesBuddyWeekday_gte?: Maybe<Int>;
  webPushToManyActivitiesMessage?: Maybe<String>;
  webPushToManyActivitiesMessage_not?: Maybe<String>;
  webPushToManyActivitiesMessage_in?: Maybe<String[] | String>;
  webPushToManyActivitiesMessage_not_in?: Maybe<String[] | String>;
  webPushToManyActivitiesMessage_lt?: Maybe<String>;
  webPushToManyActivitiesMessage_lte?: Maybe<String>;
  webPushToManyActivitiesMessage_gt?: Maybe<String>;
  webPushToManyActivitiesMessage_gte?: Maybe<String>;
  webPushToManyActivitiesMessage_contains?: Maybe<String>;
  webPushToManyActivitiesMessage_not_contains?: Maybe<String>;
  webPushToManyActivitiesMessage_starts_with?: Maybe<String>;
  webPushToManyActivitiesMessage_not_starts_with?: Maybe<String>;
  webPushToManyActivitiesMessage_ends_with?: Maybe<String>;
  webPushToManyActivitiesMessage_not_ends_with?: Maybe<String>;
  webPushToManyActivitiesWeekday?: Maybe<Int>;
  webPushToManyActivitiesWeekday_not?: Maybe<Int>;
  webPushToManyActivitiesWeekday_in?: Maybe<Int[] | Int>;
  webPushToManyActivitiesWeekday_not_in?: Maybe<Int[] | Int>;
  webPushToManyActivitiesWeekday_lt?: Maybe<Int>;
  webPushToManyActivitiesWeekday_lte?: Maybe<Int>;
  webPushToManyActivitiesWeekday_gt?: Maybe<Int>;
  webPushToManyActivitiesWeekday_gte?: Maybe<Int>;
  webPushToManyActivitiesBuddyMessage?: Maybe<String>;
  webPushToManyActivitiesBuddyMessage_not?: Maybe<String>;
  webPushToManyActivitiesBuddyMessage_in?: Maybe<String[] | String>;
  webPushToManyActivitiesBuddyMessage_not_in?: Maybe<String[] | String>;
  webPushToManyActivitiesBuddyMessage_lt?: Maybe<String>;
  webPushToManyActivitiesBuddyMessage_lte?: Maybe<String>;
  webPushToManyActivitiesBuddyMessage_gt?: Maybe<String>;
  webPushToManyActivitiesBuddyMessage_gte?: Maybe<String>;
  webPushToManyActivitiesBuddyMessage_contains?: Maybe<String>;
  webPushToManyActivitiesBuddyMessage_not_contains?: Maybe<String>;
  webPushToManyActivitiesBuddyMessage_starts_with?: Maybe<String>;
  webPushToManyActivitiesBuddyMessage_not_starts_with?: Maybe<String>;
  webPushToManyActivitiesBuddyMessage_ends_with?: Maybe<String>;
  webPushToManyActivitiesBuddyMessage_not_ends_with?: Maybe<String>;
  webPushToManyActivitiesBuddyDelay?: Maybe<TimeSpanWhereInput>;
  webPushActivityMissedBuddyMessage?: Maybe<String>;
  webPushActivityMissedBuddyMessage_not?: Maybe<String>;
  webPushActivityMissedBuddyMessage_in?: Maybe<String[] | String>;
  webPushActivityMissedBuddyMessage_not_in?: Maybe<String[] | String>;
  webPushActivityMissedBuddyMessage_lt?: Maybe<String>;
  webPushActivityMissedBuddyMessage_lte?: Maybe<String>;
  webPushActivityMissedBuddyMessage_gt?: Maybe<String>;
  webPushActivityMissedBuddyMessage_gte?: Maybe<String>;
  webPushActivityMissedBuddyMessage_contains?: Maybe<String>;
  webPushActivityMissedBuddyMessage_not_contains?: Maybe<String>;
  webPushActivityMissedBuddyMessage_starts_with?: Maybe<String>;
  webPushActivityMissedBuddyMessage_not_starts_with?: Maybe<String>;
  webPushActivityMissedBuddyMessage_ends_with?: Maybe<String>;
  webPushActivityMissedBuddyMessage_not_ends_with?: Maybe<String>;
  webPushActivityMissedBuddyDelay?: Maybe<TimeSpanWhereInput>;
  AND?: Maybe<WebPushSettingsWhereInput[] | WebPushSettingsWhereInput>;
  OR?: Maybe<WebPushSettingsWhereInput[] | WebPushSettingsWhereInput>;
  NOT?: Maybe<WebPushSettingsWhereInput[] | WebPushSettingsWhereInput>;
}

export type GroupWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  title?: Maybe<String>;
}>;

export type GroupColorWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GroupColorWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  group?: Maybe<GroupWhereInput>;
  color?: Maybe<String>;
  color_not?: Maybe<String>;
  color_in?: Maybe<String[] | String>;
  color_not_in?: Maybe<String[] | String>;
  color_lt?: Maybe<String>;
  color_lte?: Maybe<String>;
  color_gt?: Maybe<String>;
  color_gte?: Maybe<String>;
  color_contains?: Maybe<String>;
  color_not_contains?: Maybe<String>;
  color_starts_with?: Maybe<String>;
  color_not_starts_with?: Maybe<String>;
  color_ends_with?: Maybe<String>;
  color_not_ends_with?: Maybe<String>;
  AND?: Maybe<GroupColorWhereInput[] | GroupColorWhereInput>;
  OR?: Maybe<GroupColorWhereInput[] | GroupColorWhereInput>;
  NOT?: Maybe<GroupColorWhereInput[] | GroupColorWhereInput>;
}

export type InitiatorWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  title?: Maybe<String>;
}>;

export interface InitiatorWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<InitiatorWhereInput[] | InitiatorWhereInput>;
  OR?: Maybe<InitiatorWhereInput[] | InitiatorWhereInput>;
  NOT?: Maybe<InitiatorWhereInput[] | InitiatorWhereInput>;
}

export type IpaqWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type IpaqAnswersWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type JoinedChallengesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface JoinedChallengesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  userId?: Maybe<UserWhereInput>;
  challegeId?: Maybe<ChallengeWhereInput>;
  AND?: Maybe<JoinedChallengesWhereInput[] | JoinedChallengesWhereInput>;
  OR?: Maybe<JoinedChallengesWhereInput[] | JoinedChallengesWhereInput>;
  NOT?: Maybe<JoinedChallengesWhereInput[] | JoinedChallengesWhereInput>;
}

export type PatientWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PatientProfileInfoWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type Phq9WhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ProfileActivityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  key?: Maybe<String>;
}>;

export type QuestionnairesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ScheduledTaskWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ScheduledTaskWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  scheduledFor?: Maybe<DateTimeInput>;
  scheduledFor_not?: Maybe<DateTimeInput>;
  scheduledFor_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  scheduledFor_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  scheduledFor_lt?: Maybe<DateTimeInput>;
  scheduledFor_lte?: Maybe<DateTimeInput>;
  scheduledFor_gt?: Maybe<DateTimeInput>;
  scheduledFor_gte?: Maybe<DateTimeInput>;
  taskType?: Maybe<TaskTypes>;
  taskType_not?: Maybe<TaskTypes>;
  taskType_in?: Maybe<TaskTypes[] | TaskTypes>;
  taskType_not_in?: Maybe<TaskTypes[] | TaskTypes>;
  userId?: Maybe<ID_Input>;
  userId_not?: Maybe<ID_Input>;
  userId_in?: Maybe<ID_Input[] | ID_Input>;
  userId_not_in?: Maybe<ID_Input[] | ID_Input>;
  userId_lt?: Maybe<ID_Input>;
  userId_lte?: Maybe<ID_Input>;
  userId_gt?: Maybe<ID_Input>;
  userId_gte?: Maybe<ID_Input>;
  userId_contains?: Maybe<ID_Input>;
  userId_not_contains?: Maybe<ID_Input>;
  userId_starts_with?: Maybe<ID_Input>;
  userId_not_starts_with?: Maybe<ID_Input>;
  userId_ends_with?: Maybe<ID_Input>;
  userId_not_ends_with?: Maybe<ID_Input>;
  chatId?: Maybe<ID_Input>;
  chatId_not?: Maybe<ID_Input>;
  chatId_in?: Maybe<ID_Input[] | ID_Input>;
  chatId_not_in?: Maybe<ID_Input[] | ID_Input>;
  chatId_lt?: Maybe<ID_Input>;
  chatId_lte?: Maybe<ID_Input>;
  chatId_gt?: Maybe<ID_Input>;
  chatId_gte?: Maybe<ID_Input>;
  chatId_contains?: Maybe<ID_Input>;
  chatId_not_contains?: Maybe<ID_Input>;
  chatId_starts_with?: Maybe<ID_Input>;
  chatId_not_starts_with?: Maybe<ID_Input>;
  chatId_ends_with?: Maybe<ID_Input>;
  chatId_not_ends_with?: Maybe<ID_Input>;
  buddyRequestId?: Maybe<ID_Input>;
  buddyRequestId_not?: Maybe<ID_Input>;
  buddyRequestId_in?: Maybe<ID_Input[] | ID_Input>;
  buddyRequestId_not_in?: Maybe<ID_Input[] | ID_Input>;
  buddyRequestId_lt?: Maybe<ID_Input>;
  buddyRequestId_lte?: Maybe<ID_Input>;
  buddyRequestId_gt?: Maybe<ID_Input>;
  buddyRequestId_gte?: Maybe<ID_Input>;
  buddyRequestId_contains?: Maybe<ID_Input>;
  buddyRequestId_not_contains?: Maybe<ID_Input>;
  buddyRequestId_starts_with?: Maybe<ID_Input>;
  buddyRequestId_not_starts_with?: Maybe<ID_Input>;
  buddyRequestId_ends_with?: Maybe<ID_Input>;
  buddyRequestId_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<ScheduledTaskWhereInput[] | ScheduledTaskWhereInput>;
  OR?: Maybe<ScheduledTaskWhereInput[] | ScheduledTaskWhereInput>;
  NOT?: Maybe<ScheduledTaskWhereInput[] | ScheduledTaskWhereInput>;
}

export type SensorDataWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TimeSpanWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  username?: Maybe<String>;
}>;

export type UserSettingsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type VotingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type WebPushNotificationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type WebPushSettingsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ActivityCreateInput {
  id?: Maybe<ID_Input>;
  key: String;
  titel?: Maybe<String>;
  description?: Maybe<String>;
  grade?: Maybe<ActivityGrade>;
  icon?: Maybe<String>;
  tags?: Maybe<ActivityCreatetagsInput>;
  isCustom?: Maybe<Boolean>;
  color?: Maybe<String>;
}

export interface ActivityCreatetagsInput {
  set?: Maybe<String[] | String>;
}

export interface ActivityUpdateInput {
  key?: Maybe<String>;
  titel?: Maybe<String>;
  description?: Maybe<String>;
  grade?: Maybe<ActivityGrade>;
  icon?: Maybe<String>;
  tags?: Maybe<ActivityUpdatetagsInput>;
  isCustom?: Maybe<Boolean>;
  color?: Maybe<String>;
}

export interface ActivityUpdatetagsInput {
  set?: Maybe<String[] | String>;
}

export interface ActivityUpdateManyMutationInput {
  key?: Maybe<String>;
  titel?: Maybe<String>;
  description?: Maybe<String>;
  grade?: Maybe<ActivityGrade>;
  icon?: Maybe<String>;
  tags?: Maybe<ActivityUpdatetagsInput>;
  isCustom?: Maybe<Boolean>;
  color?: Maybe<String>;
}

export interface AwardCreateInput {
  id?: Maybe<ID_Input>;
  challengeID?: Maybe<ChallengeCreateOneInput>;
  contributionID?: Maybe<ContributionCreateOneInput>;
  votingID?: Maybe<VotingCreateOneInput>;
  createdBy?: Maybe<UserCreateOneInput>;
  status?: Maybe<AwardVT>;
  winner?: Maybe<UserCreateOneInput>;
}

export interface ChallengeCreateOneInput {
  create?: Maybe<ChallengeCreateInput>;
  connect?: Maybe<ChallengeWhereUniqueInput>;
}

export interface ChallengeCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  image: String;
  premium?: Maybe<String>;
  timeEnd?: Maybe<DateTimeInput>;
  emailSend?: Maybe<String>;
  jury?: Maybe<UserCreateManyInput>;
  group?: Maybe<GroupCreateManyWithoutChallengeInput>;
  category?: Maybe<CategoryCreateManyWithoutChallengeInput>;
  status?: Maybe<StatusChallegen>;
  initiator: String;
  createdBy?: Maybe<UserCreateOneInput>;
}

export interface UserCreateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  username: String;
  password?: Maybe<String>;
  role?: Maybe<UserRole>;
  settings?: Maybe<UserSettingsCreateOneInput>;
  notifications?: Maybe<WebPushNotificationCreateManyInput>;
  patient?: Maybe<PatientCreateOneWithoutUserInput>;
  lastActive?: Maybe<DateTimeInput>;
}

export interface UserSettingsCreateOneInput {
  create?: Maybe<UserSettingsCreateInput>;
  connect?: Maybe<UserSettingsWhereUniqueInput>;
}

export interface UserSettingsCreateInput {
  id?: Maybe<ID_Input>;
  themeName?: Maybe<String>;
}

export interface WebPushNotificationCreateManyInput {
  create?: Maybe<
    WebPushNotificationCreateInput[] | WebPushNotificationCreateInput
  >;
  connect?: Maybe<
    WebPushNotificationWhereUniqueInput[] | WebPushNotificationWhereUniqueInput
  >;
}

export interface WebPushNotificationCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  notificationInformation: Json;
}

export interface PatientCreateOneWithoutUserInput {
  create?: Maybe<PatientCreateWithoutUserInput>;
  connect?: Maybe<PatientWhereUniqueInput>;
}

export interface PatientCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  verificationCode: String;
  verified?: Maybe<Boolean>;
  profile?: Maybe<PatientProfileInfoCreateOneInput>;
  buddy?: Maybe<BuddyCreateOneWithoutPatientInput>;
  quests?: Maybe<QuestionnairesCreateOneWithoutPatientInput>;
  online?: Maybe<Boolean>;
  activities?: Maybe<ActivityCreateManyInput>;
  favoriteActivities?: Maybe<FavoriteActivityCreateManyInput>;
  calendarEntries?: Maybe<CalendarEntryCreateManyWithoutPatientInput>;
  activeMinutesPerWeek?: Maybe<Int>;
}

export interface PatientProfileInfoCreateOneInput {
  create?: Maybe<PatientProfileInfoCreateInput>;
  connect?: Maybe<PatientProfileInfoWhereUniqueInput>;
}

export interface PatientProfileInfoCreateInput {
  id?: Maybe<ID_Input>;
  birthday?: Maybe<DateTimeInput>;
  gender?: Maybe<Gender>;
  sameGender?: Maybe<Boolean>;
  hideGender?: Maybe<Boolean>;
  meetingDesired?: Maybe<Boolean>;
  avatar?: Maybe<String>;
  profileActivities?: Maybe<ProfileActivityCreateManyInput>;
}

export interface ProfileActivityCreateManyInput {
  create?: Maybe<ProfileActivityCreateInput[] | ProfileActivityCreateInput>;
  connect?: Maybe<
    ProfileActivityWhereUniqueInput[] | ProfileActivityWhereUniqueInput
  >;
}

export interface ProfileActivityCreateInput {
  id?: Maybe<ID_Input>;
  key: String;
  icon: String;
  titel: String;
}

export interface BuddyCreateOneWithoutPatientInput {
  create?: Maybe<BuddyCreateWithoutPatientInput>;
  connect?: Maybe<BuddyWhereUniqueInput>;
}

export interface BuddyCreateWithoutPatientInput {
  id?: Maybe<ID_Input>;
  chat?: Maybe<ChatCreateOneInput>;
}

export interface ChatCreateOneInput {
  create?: Maybe<ChatCreateInput>;
  connect?: Maybe<ChatWhereUniqueInput>;
}

export interface ChatCreateInput {
  id?: Maybe<ID_Input>;
  messages?: Maybe<ChatMessageCreateManyWithoutChatInput>;
  bot?: Maybe<BotCreateOneWithoutChatInput>;
}

export interface ChatMessageCreateManyWithoutChatInput {
  create?: Maybe<
    ChatMessageCreateWithoutChatInput[] | ChatMessageCreateWithoutChatInput
  >;
  connect?: Maybe<ChatMessageWhereUniqueInput[] | ChatMessageWhereUniqueInput>;
}

export interface ChatMessageCreateWithoutChatInput {
  id?: Maybe<ID_Input>;
  text?: Maybe<String>;
  author?: Maybe<UserCreateOneInput>;
  authorBot?: Maybe<BotCreateOneInput>;
  attachment?: Maybe<ChatMessageAttachmentCreateOneWithoutChatMessageInput>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface BotCreateOneInput {
  create?: Maybe<BotCreateInput>;
  connect?: Maybe<BotWhereUniqueInput>;
}

export interface BotCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  chat?: Maybe<ChatCreateOneWithoutBotInput>;
}

export interface ChatCreateOneWithoutBotInput {
  create?: Maybe<ChatCreateWithoutBotInput>;
  connect?: Maybe<ChatWhereUniqueInput>;
}

export interface ChatCreateWithoutBotInput {
  id?: Maybe<ID_Input>;
  messages?: Maybe<ChatMessageCreateManyWithoutChatInput>;
}

export interface ChatMessageAttachmentCreateOneWithoutChatMessageInput {
  create?: Maybe<ChatMessageAttachmentCreateWithoutChatMessageInput>;
  connect?: Maybe<ChatMessageAttachmentWhereUniqueInput>;
}

export interface ChatMessageAttachmentCreateWithoutChatMessageInput {
  id?: Maybe<ID_Input>;
  calendarEntry?: Maybe<CalendarEntryCreateOneInput>;
  originalCalendarEntryId?: Maybe<ID_Input>;
  ownerId?: Maybe<ID_Input>;
}

export interface CalendarEntryCreateOneInput {
  create?: Maybe<CalendarEntryCreateInput>;
  connect?: Maybe<CalendarEntryWhereUniqueInput>;
}

export interface CalendarEntryCreateInput {
  id?: Maybe<ID_Input>;
  activity: ActivityCreateOneInput;
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  isDone?: Maybe<Boolean>;
  isRunning?: Maybe<Boolean>;
  trackingRequested?: Maybe<Boolean>;
  patient?: Maybe<PatientCreateOneWithoutCalendarEntriesInput>;
  sensorData?: Maybe<SensorDataCreateManyInput>;
}

export interface ActivityCreateOneInput {
  create?: Maybe<ActivityCreateInput>;
  connect?: Maybe<ActivityWhereUniqueInput>;
}

export interface PatientCreateOneWithoutCalendarEntriesInput {
  create?: Maybe<PatientCreateWithoutCalendarEntriesInput>;
  connect?: Maybe<PatientWhereUniqueInput>;
}

export interface PatientCreateWithoutCalendarEntriesInput {
  id?: Maybe<ID_Input>;
  verificationCode: String;
  verified?: Maybe<Boolean>;
  profile?: Maybe<PatientProfileInfoCreateOneInput>;
  buddy?: Maybe<BuddyCreateOneWithoutPatientInput>;
  quests?: Maybe<QuestionnairesCreateOneWithoutPatientInput>;
  online?: Maybe<Boolean>;
  activities?: Maybe<ActivityCreateManyInput>;
  favoriteActivities?: Maybe<FavoriteActivityCreateManyInput>;
  activeMinutesPerWeek?: Maybe<Int>;
  user?: Maybe<UserCreateOneWithoutPatientInput>;
}

export interface QuestionnairesCreateOneWithoutPatientInput {
  create?: Maybe<QuestionnairesCreateWithoutPatientInput>;
  connect?: Maybe<QuestionnairesWhereUniqueInput>;
}

export interface QuestionnairesCreateWithoutPatientInput {
  id?: Maybe<ID_Input>;
  phq9s?: Maybe<Phq9CreateManyWithoutQuestsInput>;
  ipaqs?: Maybe<IpaqCreateManyWithoutQuestsInput>;
}

export interface Phq9CreateManyWithoutQuestsInput {
  create?: Maybe<Phq9CreateWithoutQuestsInput[] | Phq9CreateWithoutQuestsInput>;
  connect?: Maybe<Phq9WhereUniqueInput[] | Phq9WhereUniqueInput>;
}

export interface Phq9CreateWithoutQuestsInput {
  id?: Maybe<ID_Input>;
  answers?: Maybe<Phq9CreateanswersInput>;
  score?: Maybe<Int>;
  isComplete?: Maybe<Boolean>;
  expiryDate?: Maybe<DateTimeInput>;
}

export interface Phq9CreateanswersInput {
  set?: Maybe<Int[] | Int>;
}

export interface IpaqCreateManyWithoutQuestsInput {
  create?: Maybe<IpaqCreateWithoutQuestsInput[] | IpaqCreateWithoutQuestsInput>;
  connect?: Maybe<IpaqWhereUniqueInput[] | IpaqWhereUniqueInput>;
}

export interface IpaqCreateWithoutQuestsInput {
  id?: Maybe<ID_Input>;
  answers?: Maybe<IpaqAnswersCreateManyWithoutQuestInput>;
  score?: Maybe<Float>;
  expiryDate?: Maybe<DateTimeInput>;
  isComplete?: Maybe<Boolean>;
}

export interface IpaqAnswersCreateManyWithoutQuestInput {
  create?: Maybe<
    IpaqAnswersCreateWithoutQuestInput[] | IpaqAnswersCreateWithoutQuestInput
  >;
  connect?: Maybe<IpaqAnswersWhereUniqueInput[] | IpaqAnswersWhereUniqueInput>;
}

export interface IpaqAnswersCreateWithoutQuestInput {
  id?: Maybe<ID_Input>;
  numDays?: Maybe<Int>;
  numHours?: Maybe<Int>;
  numMinutes?: Maybe<Int>;
}

export interface ActivityCreateManyInput {
  create?: Maybe<ActivityCreateInput[] | ActivityCreateInput>;
  connect?: Maybe<ActivityWhereUniqueInput[] | ActivityWhereUniqueInput>;
}

export interface FavoriteActivityCreateManyInput {
  create?: Maybe<FavoriteActivityCreateInput[] | FavoriteActivityCreateInput>;
  connect?: Maybe<
    FavoriteActivityWhereUniqueInput[] | FavoriteActivityWhereUniqueInput
  >;
}

export interface FavoriteActivityCreateInput {
  id?: Maybe<ID_Input>;
  activityKey: String;
}

export interface UserCreateOneWithoutPatientInput {
  create?: Maybe<UserCreateWithoutPatientInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutPatientInput {
  id?: Maybe<ID_Input>;
  username: String;
  password?: Maybe<String>;
  role?: Maybe<UserRole>;
  settings?: Maybe<UserSettingsCreateOneInput>;
  notifications?: Maybe<WebPushNotificationCreateManyInput>;
  lastActive?: Maybe<DateTimeInput>;
}

export interface SensorDataCreateManyInput {
  create?: Maybe<SensorDataCreateInput[] | SensorDataCreateInput>;
  connect?: Maybe<SensorDataWhereUniqueInput[] | SensorDataWhereUniqueInput>;
}

export interface SensorDataCreateInput {
  id?: Maybe<ID_Input>;
  type: String;
  x?: Maybe<Float>;
  y?: Maybe<Float>;
  z?: Maybe<Float>;
  alpha?: Maybe<Float>;
  beta?: Maybe<Float>;
  gamma?: Maybe<Float>;
}

export interface BotCreateOneWithoutChatInput {
  create?: Maybe<BotCreateWithoutChatInput>;
  connect?: Maybe<BotWhereUniqueInput>;
}

export interface BotCreateWithoutChatInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
}

export interface CalendarEntryCreateManyWithoutPatientInput {
  create?: Maybe<
    | CalendarEntryCreateWithoutPatientInput[]
    | CalendarEntryCreateWithoutPatientInput
  >;
  connect?: Maybe<
    CalendarEntryWhereUniqueInput[] | CalendarEntryWhereUniqueInput
  >;
}

export interface CalendarEntryCreateWithoutPatientInput {
  id?: Maybe<ID_Input>;
  activity: ActivityCreateOneInput;
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  isDone?: Maybe<Boolean>;
  isRunning?: Maybe<Boolean>;
  trackingRequested?: Maybe<Boolean>;
  sensorData?: Maybe<SensorDataCreateManyInput>;
}

export interface GroupCreateManyWithoutChallengeInput {
  create?: Maybe<
    GroupCreateWithoutChallengeInput[] | GroupCreateWithoutChallengeInput
  >;
  connect?: Maybe<GroupWhereUniqueInput[] | GroupWhereUniqueInput>;
}

export interface GroupCreateWithoutChallengeInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  createdBy?: Maybe<UserCreateOneInput>;
}

export interface CategoryCreateManyWithoutChallengeInput {
  create?: Maybe<
    CategoryCreateWithoutChallengeInput[] | CategoryCreateWithoutChallengeInput
  >;
  connect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
}

export interface CategoryCreateWithoutChallengeInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
}

export interface ContributionCreateOneInput {
  create?: Maybe<ContributionCreateInput>;
  connect?: Maybe<ContributionWhereUniqueInput>;
}

export interface ContributionCreateInput {
  id?: Maybe<ID_Input>;
  challengeID?: Maybe<ChallengeCreateOneInput>;
  title: String;
  description?: Maybe<String>;
  image?: Maybe<String>;
  createdBy?: Maybe<UserCreateOneInput>;
}

export interface VotingCreateOneInput {
  create?: Maybe<VotingCreateInput>;
  connect?: Maybe<VotingWhereUniqueInput>;
}

export interface VotingCreateInput {
  id?: Maybe<ID_Input>;
  challengeID?: Maybe<ChallengeCreateOneInput>;
  contributionID?: Maybe<ContributionCreateOneInput>;
  title: String;
  description?: Maybe<String>;
  votedPoint?: Maybe<Int>;
  createdBy?: Maybe<UserCreateOneInput>;
}

export interface AwardUpdateInput {
  challengeID?: Maybe<ChallengeUpdateOneInput>;
  contributionID?: Maybe<ContributionUpdateOneInput>;
  votingID?: Maybe<VotingUpdateOneInput>;
  createdBy?: Maybe<UserUpdateOneInput>;
  status?: Maybe<AwardVT>;
  winner?: Maybe<UserUpdateOneInput>;
}

export interface ChallengeUpdateOneInput {
  create?: Maybe<ChallengeCreateInput>;
  update?: Maybe<ChallengeUpdateDataInput>;
  upsert?: Maybe<ChallengeUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ChallengeWhereUniqueInput>;
}

export interface ChallengeUpdateDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  image?: Maybe<String>;
  premium?: Maybe<String>;
  timeEnd?: Maybe<DateTimeInput>;
  emailSend?: Maybe<String>;
  jury?: Maybe<UserUpdateManyInput>;
  group?: Maybe<GroupUpdateManyWithoutChallengeInput>;
  category?: Maybe<CategoryUpdateManyWithoutChallengeInput>;
  status?: Maybe<StatusChallegen>;
  initiator?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneInput>;
}

export interface UserUpdateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface UserUpdateDataInput {
  username?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<UserRole>;
  settings?: Maybe<UserSettingsUpdateOneInput>;
  notifications?: Maybe<WebPushNotificationUpdateManyInput>;
  patient?: Maybe<PatientUpdateOneWithoutUserInput>;
  lastActive?: Maybe<DateTimeInput>;
}

export interface UserSettingsUpdateOneInput {
  create?: Maybe<UserSettingsCreateInput>;
  update?: Maybe<UserSettingsUpdateDataInput>;
  upsert?: Maybe<UserSettingsUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserSettingsWhereUniqueInput>;
}

export interface UserSettingsUpdateDataInput {
  themeName?: Maybe<String>;
}

export interface UserSettingsUpsertNestedInput {
  update: UserSettingsUpdateDataInput;
  create: UserSettingsCreateInput;
}

export interface WebPushNotificationUpdateManyInput {
  create?: Maybe<
    WebPushNotificationCreateInput[] | WebPushNotificationCreateInput
  >;
  update?: Maybe<
    | WebPushNotificationUpdateWithWhereUniqueNestedInput[]
    | WebPushNotificationUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | WebPushNotificationUpsertWithWhereUniqueNestedInput[]
    | WebPushNotificationUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    WebPushNotificationWhereUniqueInput[] | WebPushNotificationWhereUniqueInput
  >;
  connect?: Maybe<
    WebPushNotificationWhereUniqueInput[] | WebPushNotificationWhereUniqueInput
  >;
  set?: Maybe<
    WebPushNotificationWhereUniqueInput[] | WebPushNotificationWhereUniqueInput
  >;
  disconnect?: Maybe<
    WebPushNotificationWhereUniqueInput[] | WebPushNotificationWhereUniqueInput
  >;
  deleteMany?: Maybe<
    WebPushNotificationScalarWhereInput[] | WebPushNotificationScalarWhereInput
  >;
  updateMany?: Maybe<
    | WebPushNotificationUpdateManyWithWhereNestedInput[]
    | WebPushNotificationUpdateManyWithWhereNestedInput
  >;
}

export interface WebPushNotificationUpdateWithWhereUniqueNestedInput {
  where: WebPushNotificationWhereUniqueInput;
  data: WebPushNotificationUpdateDataInput;
}

export interface WebPushNotificationUpdateDataInput {
  name?: Maybe<String>;
  notificationInformation?: Maybe<Json>;
}

export interface WebPushNotificationUpsertWithWhereUniqueNestedInput {
  where: WebPushNotificationWhereUniqueInput;
  update: WebPushNotificationUpdateDataInput;
  create: WebPushNotificationCreateInput;
}

export interface WebPushNotificationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    WebPushNotificationScalarWhereInput[] | WebPushNotificationScalarWhereInput
  >;
  OR?: Maybe<
    WebPushNotificationScalarWhereInput[] | WebPushNotificationScalarWhereInput
  >;
  NOT?: Maybe<
    WebPushNotificationScalarWhereInput[] | WebPushNotificationScalarWhereInput
  >;
}

export interface WebPushNotificationUpdateManyWithWhereNestedInput {
  where: WebPushNotificationScalarWhereInput;
  data: WebPushNotificationUpdateManyDataInput;
}

export interface WebPushNotificationUpdateManyDataInput {
  name?: Maybe<String>;
  notificationInformation?: Maybe<Json>;
}

export interface PatientUpdateOneWithoutUserInput {
  create?: Maybe<PatientCreateWithoutUserInput>;
  update?: Maybe<PatientUpdateWithoutUserDataInput>;
  upsert?: Maybe<PatientUpsertWithoutUserInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PatientWhereUniqueInput>;
}

export interface PatientUpdateWithoutUserDataInput {
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  profile?: Maybe<PatientProfileInfoUpdateOneInput>;
  buddy?: Maybe<BuddyUpdateOneWithoutPatientInput>;
  quests?: Maybe<QuestionnairesUpdateOneWithoutPatientInput>;
  online?: Maybe<Boolean>;
  activities?: Maybe<ActivityUpdateManyInput>;
  favoriteActivities?: Maybe<FavoriteActivityUpdateManyInput>;
  calendarEntries?: Maybe<CalendarEntryUpdateManyWithoutPatientInput>;
  activeMinutesPerWeek?: Maybe<Int>;
}

export interface PatientProfileInfoUpdateOneInput {
  create?: Maybe<PatientProfileInfoCreateInput>;
  update?: Maybe<PatientProfileInfoUpdateDataInput>;
  upsert?: Maybe<PatientProfileInfoUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PatientProfileInfoWhereUniqueInput>;
}

export interface PatientProfileInfoUpdateDataInput {
  birthday?: Maybe<DateTimeInput>;
  gender?: Maybe<Gender>;
  sameGender?: Maybe<Boolean>;
  hideGender?: Maybe<Boolean>;
  meetingDesired?: Maybe<Boolean>;
  avatar?: Maybe<String>;
  profileActivities?: Maybe<ProfileActivityUpdateManyInput>;
}

export interface ProfileActivityUpdateManyInput {
  create?: Maybe<ProfileActivityCreateInput[] | ProfileActivityCreateInput>;
  update?: Maybe<
    | ProfileActivityUpdateWithWhereUniqueNestedInput[]
    | ProfileActivityUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ProfileActivityUpsertWithWhereUniqueNestedInput[]
    | ProfileActivityUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    ProfileActivityWhereUniqueInput[] | ProfileActivityWhereUniqueInput
  >;
  connect?: Maybe<
    ProfileActivityWhereUniqueInput[] | ProfileActivityWhereUniqueInput
  >;
  set?: Maybe<
    ProfileActivityWhereUniqueInput[] | ProfileActivityWhereUniqueInput
  >;
  disconnect?: Maybe<
    ProfileActivityWhereUniqueInput[] | ProfileActivityWhereUniqueInput
  >;
  deleteMany?: Maybe<
    ProfileActivityScalarWhereInput[] | ProfileActivityScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProfileActivityUpdateManyWithWhereNestedInput[]
    | ProfileActivityUpdateManyWithWhereNestedInput
  >;
}

export interface ProfileActivityUpdateWithWhereUniqueNestedInput {
  where: ProfileActivityWhereUniqueInput;
  data: ProfileActivityUpdateDataInput;
}

export interface ProfileActivityUpdateDataInput {
  key?: Maybe<String>;
  icon?: Maybe<String>;
  titel?: Maybe<String>;
}

export interface ProfileActivityUpsertWithWhereUniqueNestedInput {
  where: ProfileActivityWhereUniqueInput;
  update: ProfileActivityUpdateDataInput;
  create: ProfileActivityCreateInput;
}

export interface ProfileActivityScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  key?: Maybe<String>;
  key_not?: Maybe<String>;
  key_in?: Maybe<String[] | String>;
  key_not_in?: Maybe<String[] | String>;
  key_lt?: Maybe<String>;
  key_lte?: Maybe<String>;
  key_gt?: Maybe<String>;
  key_gte?: Maybe<String>;
  key_contains?: Maybe<String>;
  key_not_contains?: Maybe<String>;
  key_starts_with?: Maybe<String>;
  key_not_starts_with?: Maybe<String>;
  key_ends_with?: Maybe<String>;
  key_not_ends_with?: Maybe<String>;
  icon?: Maybe<String>;
  icon_not?: Maybe<String>;
  icon_in?: Maybe<String[] | String>;
  icon_not_in?: Maybe<String[] | String>;
  icon_lt?: Maybe<String>;
  icon_lte?: Maybe<String>;
  icon_gt?: Maybe<String>;
  icon_gte?: Maybe<String>;
  icon_contains?: Maybe<String>;
  icon_not_contains?: Maybe<String>;
  icon_starts_with?: Maybe<String>;
  icon_not_starts_with?: Maybe<String>;
  icon_ends_with?: Maybe<String>;
  icon_not_ends_with?: Maybe<String>;
  titel?: Maybe<String>;
  titel_not?: Maybe<String>;
  titel_in?: Maybe<String[] | String>;
  titel_not_in?: Maybe<String[] | String>;
  titel_lt?: Maybe<String>;
  titel_lte?: Maybe<String>;
  titel_gt?: Maybe<String>;
  titel_gte?: Maybe<String>;
  titel_contains?: Maybe<String>;
  titel_not_contains?: Maybe<String>;
  titel_starts_with?: Maybe<String>;
  titel_not_starts_with?: Maybe<String>;
  titel_ends_with?: Maybe<String>;
  titel_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    ProfileActivityScalarWhereInput[] | ProfileActivityScalarWhereInput
  >;
  OR?: Maybe<
    ProfileActivityScalarWhereInput[] | ProfileActivityScalarWhereInput
  >;
  NOT?: Maybe<
    ProfileActivityScalarWhereInput[] | ProfileActivityScalarWhereInput
  >;
}

export interface ProfileActivityUpdateManyWithWhereNestedInput {
  where: ProfileActivityScalarWhereInput;
  data: ProfileActivityUpdateManyDataInput;
}

export interface ProfileActivityUpdateManyDataInput {
  key?: Maybe<String>;
  icon?: Maybe<String>;
  titel?: Maybe<String>;
}

export interface PatientProfileInfoUpsertNestedInput {
  update: PatientProfileInfoUpdateDataInput;
  create: PatientProfileInfoCreateInput;
}

export interface BuddyUpdateOneWithoutPatientInput {
  create?: Maybe<BuddyCreateWithoutPatientInput>;
  update?: Maybe<BuddyUpdateWithoutPatientDataInput>;
  upsert?: Maybe<BuddyUpsertWithoutPatientInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BuddyWhereUniqueInput>;
}

export interface BuddyUpdateWithoutPatientDataInput {
  chat?: Maybe<ChatUpdateOneInput>;
}

export interface ChatUpdateOneInput {
  create?: Maybe<ChatCreateInput>;
  update?: Maybe<ChatUpdateDataInput>;
  upsert?: Maybe<ChatUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ChatWhereUniqueInput>;
}

export interface ChatUpdateDataInput {
  messages?: Maybe<ChatMessageUpdateManyWithoutChatInput>;
  bot?: Maybe<BotUpdateOneWithoutChatInput>;
}

export interface ChatMessageUpdateManyWithoutChatInput {
  create?: Maybe<
    ChatMessageCreateWithoutChatInput[] | ChatMessageCreateWithoutChatInput
  >;
  delete?: Maybe<ChatMessageWhereUniqueInput[] | ChatMessageWhereUniqueInput>;
  connect?: Maybe<ChatMessageWhereUniqueInput[] | ChatMessageWhereUniqueInput>;
  set?: Maybe<ChatMessageWhereUniqueInput[] | ChatMessageWhereUniqueInput>;
  disconnect?: Maybe<
    ChatMessageWhereUniqueInput[] | ChatMessageWhereUniqueInput
  >;
  update?: Maybe<
    | ChatMessageUpdateWithWhereUniqueWithoutChatInput[]
    | ChatMessageUpdateWithWhereUniqueWithoutChatInput
  >;
  upsert?: Maybe<
    | ChatMessageUpsertWithWhereUniqueWithoutChatInput[]
    | ChatMessageUpsertWithWhereUniqueWithoutChatInput
  >;
  deleteMany?: Maybe<
    ChatMessageScalarWhereInput[] | ChatMessageScalarWhereInput
  >;
  updateMany?: Maybe<
    | ChatMessageUpdateManyWithWhereNestedInput[]
    | ChatMessageUpdateManyWithWhereNestedInput
  >;
}

export interface ChatMessageUpdateWithWhereUniqueWithoutChatInput {
  where: ChatMessageWhereUniqueInput;
  data: ChatMessageUpdateWithoutChatDataInput;
}

export interface ChatMessageUpdateWithoutChatDataInput {
  text?: Maybe<String>;
  author?: Maybe<UserUpdateOneInput>;
  authorBot?: Maybe<BotUpdateOneInput>;
  attachment?: Maybe<ChatMessageAttachmentUpdateOneWithoutChatMessageInput>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface BotUpdateOneInput {
  create?: Maybe<BotCreateInput>;
  update?: Maybe<BotUpdateDataInput>;
  upsert?: Maybe<BotUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BotWhereUniqueInput>;
}

export interface BotUpdateDataInput {
  name?: Maybe<String>;
  chat?: Maybe<ChatUpdateOneWithoutBotInput>;
}

export interface ChatUpdateOneWithoutBotInput {
  create?: Maybe<ChatCreateWithoutBotInput>;
  update?: Maybe<ChatUpdateWithoutBotDataInput>;
  upsert?: Maybe<ChatUpsertWithoutBotInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ChatWhereUniqueInput>;
}

export interface ChatUpdateWithoutBotDataInput {
  messages?: Maybe<ChatMessageUpdateManyWithoutChatInput>;
}

export interface ChatUpsertWithoutBotInput {
  update: ChatUpdateWithoutBotDataInput;
  create: ChatCreateWithoutBotInput;
}

export interface BotUpsertNestedInput {
  update: BotUpdateDataInput;
  create: BotCreateInput;
}

export interface ChatMessageAttachmentUpdateOneWithoutChatMessageInput {
  create?: Maybe<ChatMessageAttachmentCreateWithoutChatMessageInput>;
  update?: Maybe<ChatMessageAttachmentUpdateWithoutChatMessageDataInput>;
  upsert?: Maybe<ChatMessageAttachmentUpsertWithoutChatMessageInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ChatMessageAttachmentWhereUniqueInput>;
}

export interface ChatMessageAttachmentUpdateWithoutChatMessageDataInput {
  calendarEntry?: Maybe<CalendarEntryUpdateOneInput>;
  originalCalendarEntryId?: Maybe<ID_Input>;
  ownerId?: Maybe<ID_Input>;
}

export interface CalendarEntryUpdateOneInput {
  create?: Maybe<CalendarEntryCreateInput>;
  update?: Maybe<CalendarEntryUpdateDataInput>;
  upsert?: Maybe<CalendarEntryUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CalendarEntryWhereUniqueInput>;
}

export interface CalendarEntryUpdateDataInput {
  activity?: Maybe<ActivityUpdateOneRequiredInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  isDone?: Maybe<Boolean>;
  isRunning?: Maybe<Boolean>;
  trackingRequested?: Maybe<Boolean>;
  patient?: Maybe<PatientUpdateOneWithoutCalendarEntriesInput>;
  sensorData?: Maybe<SensorDataUpdateManyInput>;
}

export interface ActivityUpdateOneRequiredInput {
  create?: Maybe<ActivityCreateInput>;
  update?: Maybe<ActivityUpdateDataInput>;
  upsert?: Maybe<ActivityUpsertNestedInput>;
  connect?: Maybe<ActivityWhereUniqueInput>;
}

export interface ActivityUpdateDataInput {
  key?: Maybe<String>;
  titel?: Maybe<String>;
  description?: Maybe<String>;
  grade?: Maybe<ActivityGrade>;
  icon?: Maybe<String>;
  tags?: Maybe<ActivityUpdatetagsInput>;
  isCustom?: Maybe<Boolean>;
  color?: Maybe<String>;
}

export interface ActivityUpsertNestedInput {
  update: ActivityUpdateDataInput;
  create: ActivityCreateInput;
}

export interface PatientUpdateOneWithoutCalendarEntriesInput {
  create?: Maybe<PatientCreateWithoutCalendarEntriesInput>;
  update?: Maybe<PatientUpdateWithoutCalendarEntriesDataInput>;
  upsert?: Maybe<PatientUpsertWithoutCalendarEntriesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PatientWhereUniqueInput>;
}

export interface PatientUpdateWithoutCalendarEntriesDataInput {
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  profile?: Maybe<PatientProfileInfoUpdateOneInput>;
  buddy?: Maybe<BuddyUpdateOneWithoutPatientInput>;
  quests?: Maybe<QuestionnairesUpdateOneWithoutPatientInput>;
  online?: Maybe<Boolean>;
  activities?: Maybe<ActivityUpdateManyInput>;
  favoriteActivities?: Maybe<FavoriteActivityUpdateManyInput>;
  activeMinutesPerWeek?: Maybe<Int>;
  user?: Maybe<UserUpdateOneWithoutPatientInput>;
}

export interface QuestionnairesUpdateOneWithoutPatientInput {
  create?: Maybe<QuestionnairesCreateWithoutPatientInput>;
  update?: Maybe<QuestionnairesUpdateWithoutPatientDataInput>;
  upsert?: Maybe<QuestionnairesUpsertWithoutPatientInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<QuestionnairesWhereUniqueInput>;
}

export interface QuestionnairesUpdateWithoutPatientDataInput {
  phq9s?: Maybe<Phq9UpdateManyWithoutQuestsInput>;
  ipaqs?: Maybe<IpaqUpdateManyWithoutQuestsInput>;
}

export interface Phq9UpdateManyWithoutQuestsInput {
  create?: Maybe<Phq9CreateWithoutQuestsInput[] | Phq9CreateWithoutQuestsInput>;
  delete?: Maybe<Phq9WhereUniqueInput[] | Phq9WhereUniqueInput>;
  connect?: Maybe<Phq9WhereUniqueInput[] | Phq9WhereUniqueInput>;
  set?: Maybe<Phq9WhereUniqueInput[] | Phq9WhereUniqueInput>;
  disconnect?: Maybe<Phq9WhereUniqueInput[] | Phq9WhereUniqueInput>;
  update?: Maybe<
    | Phq9UpdateWithWhereUniqueWithoutQuestsInput[]
    | Phq9UpdateWithWhereUniqueWithoutQuestsInput
  >;
  upsert?: Maybe<
    | Phq9UpsertWithWhereUniqueWithoutQuestsInput[]
    | Phq9UpsertWithWhereUniqueWithoutQuestsInput
  >;
  deleteMany?: Maybe<Phq9ScalarWhereInput[] | Phq9ScalarWhereInput>;
  updateMany?: Maybe<
    Phq9UpdateManyWithWhereNestedInput[] | Phq9UpdateManyWithWhereNestedInput
  >;
}

export interface Phq9UpdateWithWhereUniqueWithoutQuestsInput {
  where: Phq9WhereUniqueInput;
  data: Phq9UpdateWithoutQuestsDataInput;
}

export interface Phq9UpdateWithoutQuestsDataInput {
  answers?: Maybe<Phq9UpdateanswersInput>;
  score?: Maybe<Int>;
  isComplete?: Maybe<Boolean>;
  expiryDate?: Maybe<DateTimeInput>;
}

export interface Phq9UpdateanswersInput {
  set?: Maybe<Int[] | Int>;
}

export interface Phq9UpsertWithWhereUniqueWithoutQuestsInput {
  where: Phq9WhereUniqueInput;
  update: Phq9UpdateWithoutQuestsDataInput;
  create: Phq9CreateWithoutQuestsInput;
}

export interface Phq9ScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  score?: Maybe<Int>;
  score_not?: Maybe<Int>;
  score_in?: Maybe<Int[] | Int>;
  score_not_in?: Maybe<Int[] | Int>;
  score_lt?: Maybe<Int>;
  score_lte?: Maybe<Int>;
  score_gt?: Maybe<Int>;
  score_gte?: Maybe<Int>;
  isComplete?: Maybe<Boolean>;
  isComplete_not?: Maybe<Boolean>;
  expiryDate?: Maybe<DateTimeInput>;
  expiryDate_not?: Maybe<DateTimeInput>;
  expiryDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiryDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiryDate_lt?: Maybe<DateTimeInput>;
  expiryDate_lte?: Maybe<DateTimeInput>;
  expiryDate_gt?: Maybe<DateTimeInput>;
  expiryDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<Phq9ScalarWhereInput[] | Phq9ScalarWhereInput>;
  OR?: Maybe<Phq9ScalarWhereInput[] | Phq9ScalarWhereInput>;
  NOT?: Maybe<Phq9ScalarWhereInput[] | Phq9ScalarWhereInput>;
}

export interface Phq9UpdateManyWithWhereNestedInput {
  where: Phq9ScalarWhereInput;
  data: Phq9UpdateManyDataInput;
}

export interface Phq9UpdateManyDataInput {
  answers?: Maybe<Phq9UpdateanswersInput>;
  score?: Maybe<Int>;
  isComplete?: Maybe<Boolean>;
  expiryDate?: Maybe<DateTimeInput>;
}

export interface IpaqUpdateManyWithoutQuestsInput {
  create?: Maybe<IpaqCreateWithoutQuestsInput[] | IpaqCreateWithoutQuestsInput>;
  delete?: Maybe<IpaqWhereUniqueInput[] | IpaqWhereUniqueInput>;
  connect?: Maybe<IpaqWhereUniqueInput[] | IpaqWhereUniqueInput>;
  set?: Maybe<IpaqWhereUniqueInput[] | IpaqWhereUniqueInput>;
  disconnect?: Maybe<IpaqWhereUniqueInput[] | IpaqWhereUniqueInput>;
  update?: Maybe<
    | IpaqUpdateWithWhereUniqueWithoutQuestsInput[]
    | IpaqUpdateWithWhereUniqueWithoutQuestsInput
  >;
  upsert?: Maybe<
    | IpaqUpsertWithWhereUniqueWithoutQuestsInput[]
    | IpaqUpsertWithWhereUniqueWithoutQuestsInput
  >;
  deleteMany?: Maybe<IpaqScalarWhereInput[] | IpaqScalarWhereInput>;
  updateMany?: Maybe<
    IpaqUpdateManyWithWhereNestedInput[] | IpaqUpdateManyWithWhereNestedInput
  >;
}

export interface IpaqUpdateWithWhereUniqueWithoutQuestsInput {
  where: IpaqWhereUniqueInput;
  data: IpaqUpdateWithoutQuestsDataInput;
}

export interface IpaqUpdateWithoutQuestsDataInput {
  answers?: Maybe<IpaqAnswersUpdateManyWithoutQuestInput>;
  score?: Maybe<Float>;
  expiryDate?: Maybe<DateTimeInput>;
  isComplete?: Maybe<Boolean>;
}

export interface IpaqAnswersUpdateManyWithoutQuestInput {
  create?: Maybe<
    IpaqAnswersCreateWithoutQuestInput[] | IpaqAnswersCreateWithoutQuestInput
  >;
  delete?: Maybe<IpaqAnswersWhereUniqueInput[] | IpaqAnswersWhereUniqueInput>;
  connect?: Maybe<IpaqAnswersWhereUniqueInput[] | IpaqAnswersWhereUniqueInput>;
  set?: Maybe<IpaqAnswersWhereUniqueInput[] | IpaqAnswersWhereUniqueInput>;
  disconnect?: Maybe<
    IpaqAnswersWhereUniqueInput[] | IpaqAnswersWhereUniqueInput
  >;
  update?: Maybe<
    | IpaqAnswersUpdateWithWhereUniqueWithoutQuestInput[]
    | IpaqAnswersUpdateWithWhereUniqueWithoutQuestInput
  >;
  upsert?: Maybe<
    | IpaqAnswersUpsertWithWhereUniqueWithoutQuestInput[]
    | IpaqAnswersUpsertWithWhereUniqueWithoutQuestInput
  >;
  deleteMany?: Maybe<
    IpaqAnswersScalarWhereInput[] | IpaqAnswersScalarWhereInput
  >;
  updateMany?: Maybe<
    | IpaqAnswersUpdateManyWithWhereNestedInput[]
    | IpaqAnswersUpdateManyWithWhereNestedInput
  >;
}

export interface IpaqAnswersUpdateWithWhereUniqueWithoutQuestInput {
  where: IpaqAnswersWhereUniqueInput;
  data: IpaqAnswersUpdateWithoutQuestDataInput;
}

export interface IpaqAnswersUpdateWithoutQuestDataInput {
  numDays?: Maybe<Int>;
  numHours?: Maybe<Int>;
  numMinutes?: Maybe<Int>;
}

export interface IpaqAnswersUpsertWithWhereUniqueWithoutQuestInput {
  where: IpaqAnswersWhereUniqueInput;
  update: IpaqAnswersUpdateWithoutQuestDataInput;
  create: IpaqAnswersCreateWithoutQuestInput;
}

export interface IpaqAnswersScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  numDays?: Maybe<Int>;
  numDays_not?: Maybe<Int>;
  numDays_in?: Maybe<Int[] | Int>;
  numDays_not_in?: Maybe<Int[] | Int>;
  numDays_lt?: Maybe<Int>;
  numDays_lte?: Maybe<Int>;
  numDays_gt?: Maybe<Int>;
  numDays_gte?: Maybe<Int>;
  numHours?: Maybe<Int>;
  numHours_not?: Maybe<Int>;
  numHours_in?: Maybe<Int[] | Int>;
  numHours_not_in?: Maybe<Int[] | Int>;
  numHours_lt?: Maybe<Int>;
  numHours_lte?: Maybe<Int>;
  numHours_gt?: Maybe<Int>;
  numHours_gte?: Maybe<Int>;
  numMinutes?: Maybe<Int>;
  numMinutes_not?: Maybe<Int>;
  numMinutes_in?: Maybe<Int[] | Int>;
  numMinutes_not_in?: Maybe<Int[] | Int>;
  numMinutes_lt?: Maybe<Int>;
  numMinutes_lte?: Maybe<Int>;
  numMinutes_gt?: Maybe<Int>;
  numMinutes_gte?: Maybe<Int>;
  AND?: Maybe<IpaqAnswersScalarWhereInput[] | IpaqAnswersScalarWhereInput>;
  OR?: Maybe<IpaqAnswersScalarWhereInput[] | IpaqAnswersScalarWhereInput>;
  NOT?: Maybe<IpaqAnswersScalarWhereInput[] | IpaqAnswersScalarWhereInput>;
}

export interface IpaqAnswersUpdateManyWithWhereNestedInput {
  where: IpaqAnswersScalarWhereInput;
  data: IpaqAnswersUpdateManyDataInput;
}

export interface IpaqAnswersUpdateManyDataInput {
  numDays?: Maybe<Int>;
  numHours?: Maybe<Int>;
  numMinutes?: Maybe<Int>;
}

export interface IpaqUpsertWithWhereUniqueWithoutQuestsInput {
  where: IpaqWhereUniqueInput;
  update: IpaqUpdateWithoutQuestsDataInput;
  create: IpaqCreateWithoutQuestsInput;
}

export interface IpaqScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  score?: Maybe<Float>;
  score_not?: Maybe<Float>;
  score_in?: Maybe<Float[] | Float>;
  score_not_in?: Maybe<Float[] | Float>;
  score_lt?: Maybe<Float>;
  score_lte?: Maybe<Float>;
  score_gt?: Maybe<Float>;
  score_gte?: Maybe<Float>;
  expiryDate?: Maybe<DateTimeInput>;
  expiryDate_not?: Maybe<DateTimeInput>;
  expiryDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiryDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiryDate_lt?: Maybe<DateTimeInput>;
  expiryDate_lte?: Maybe<DateTimeInput>;
  expiryDate_gt?: Maybe<DateTimeInput>;
  expiryDate_gte?: Maybe<DateTimeInput>;
  isComplete?: Maybe<Boolean>;
  isComplete_not?: Maybe<Boolean>;
  AND?: Maybe<IpaqScalarWhereInput[] | IpaqScalarWhereInput>;
  OR?: Maybe<IpaqScalarWhereInput[] | IpaqScalarWhereInput>;
  NOT?: Maybe<IpaqScalarWhereInput[] | IpaqScalarWhereInput>;
}

export interface IpaqUpdateManyWithWhereNestedInput {
  where: IpaqScalarWhereInput;
  data: IpaqUpdateManyDataInput;
}

export interface IpaqUpdateManyDataInput {
  score?: Maybe<Float>;
  expiryDate?: Maybe<DateTimeInput>;
  isComplete?: Maybe<Boolean>;
}

export interface QuestionnairesUpsertWithoutPatientInput {
  update: QuestionnairesUpdateWithoutPatientDataInput;
  create: QuestionnairesCreateWithoutPatientInput;
}

export interface ActivityUpdateManyInput {
  create?: Maybe<ActivityCreateInput[] | ActivityCreateInput>;
  update?: Maybe<
    | ActivityUpdateWithWhereUniqueNestedInput[]
    | ActivityUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ActivityUpsertWithWhereUniqueNestedInput[]
    | ActivityUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ActivityWhereUniqueInput[] | ActivityWhereUniqueInput>;
  connect?: Maybe<ActivityWhereUniqueInput[] | ActivityWhereUniqueInput>;
  set?: Maybe<ActivityWhereUniqueInput[] | ActivityWhereUniqueInput>;
  disconnect?: Maybe<ActivityWhereUniqueInput[] | ActivityWhereUniqueInput>;
  deleteMany?: Maybe<ActivityScalarWhereInput[] | ActivityScalarWhereInput>;
  updateMany?: Maybe<
    | ActivityUpdateManyWithWhereNestedInput[]
    | ActivityUpdateManyWithWhereNestedInput
  >;
}

export interface ActivityUpdateWithWhereUniqueNestedInput {
  where: ActivityWhereUniqueInput;
  data: ActivityUpdateDataInput;
}

export interface ActivityUpsertWithWhereUniqueNestedInput {
  where: ActivityWhereUniqueInput;
  update: ActivityUpdateDataInput;
  create: ActivityCreateInput;
}

export interface ActivityScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  key?: Maybe<String>;
  key_not?: Maybe<String>;
  key_in?: Maybe<String[] | String>;
  key_not_in?: Maybe<String[] | String>;
  key_lt?: Maybe<String>;
  key_lte?: Maybe<String>;
  key_gt?: Maybe<String>;
  key_gte?: Maybe<String>;
  key_contains?: Maybe<String>;
  key_not_contains?: Maybe<String>;
  key_starts_with?: Maybe<String>;
  key_not_starts_with?: Maybe<String>;
  key_ends_with?: Maybe<String>;
  key_not_ends_with?: Maybe<String>;
  titel?: Maybe<String>;
  titel_not?: Maybe<String>;
  titel_in?: Maybe<String[] | String>;
  titel_not_in?: Maybe<String[] | String>;
  titel_lt?: Maybe<String>;
  titel_lte?: Maybe<String>;
  titel_gt?: Maybe<String>;
  titel_gte?: Maybe<String>;
  titel_contains?: Maybe<String>;
  titel_not_contains?: Maybe<String>;
  titel_starts_with?: Maybe<String>;
  titel_not_starts_with?: Maybe<String>;
  titel_ends_with?: Maybe<String>;
  titel_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  grade?: Maybe<ActivityGrade>;
  grade_not?: Maybe<ActivityGrade>;
  grade_in?: Maybe<ActivityGrade[] | ActivityGrade>;
  grade_not_in?: Maybe<ActivityGrade[] | ActivityGrade>;
  icon?: Maybe<String>;
  icon_not?: Maybe<String>;
  icon_in?: Maybe<String[] | String>;
  icon_not_in?: Maybe<String[] | String>;
  icon_lt?: Maybe<String>;
  icon_lte?: Maybe<String>;
  icon_gt?: Maybe<String>;
  icon_gte?: Maybe<String>;
  icon_contains?: Maybe<String>;
  icon_not_contains?: Maybe<String>;
  icon_starts_with?: Maybe<String>;
  icon_not_starts_with?: Maybe<String>;
  icon_ends_with?: Maybe<String>;
  icon_not_ends_with?: Maybe<String>;
  isCustom?: Maybe<Boolean>;
  isCustom_not?: Maybe<Boolean>;
  color?: Maybe<String>;
  color_not?: Maybe<String>;
  color_in?: Maybe<String[] | String>;
  color_not_in?: Maybe<String[] | String>;
  color_lt?: Maybe<String>;
  color_lte?: Maybe<String>;
  color_gt?: Maybe<String>;
  color_gte?: Maybe<String>;
  color_contains?: Maybe<String>;
  color_not_contains?: Maybe<String>;
  color_starts_with?: Maybe<String>;
  color_not_starts_with?: Maybe<String>;
  color_ends_with?: Maybe<String>;
  color_not_ends_with?: Maybe<String>;
  AND?: Maybe<ActivityScalarWhereInput[] | ActivityScalarWhereInput>;
  OR?: Maybe<ActivityScalarWhereInput[] | ActivityScalarWhereInput>;
  NOT?: Maybe<ActivityScalarWhereInput[] | ActivityScalarWhereInput>;
}

export interface ActivityUpdateManyWithWhereNestedInput {
  where: ActivityScalarWhereInput;
  data: ActivityUpdateManyDataInput;
}

export interface ActivityUpdateManyDataInput {
  key?: Maybe<String>;
  titel?: Maybe<String>;
  description?: Maybe<String>;
  grade?: Maybe<ActivityGrade>;
  icon?: Maybe<String>;
  tags?: Maybe<ActivityUpdatetagsInput>;
  isCustom?: Maybe<Boolean>;
  color?: Maybe<String>;
}

export interface FavoriteActivityUpdateManyInput {
  create?: Maybe<FavoriteActivityCreateInput[] | FavoriteActivityCreateInput>;
  update?: Maybe<
    | FavoriteActivityUpdateWithWhereUniqueNestedInput[]
    | FavoriteActivityUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | FavoriteActivityUpsertWithWhereUniqueNestedInput[]
    | FavoriteActivityUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    FavoriteActivityWhereUniqueInput[] | FavoriteActivityWhereUniqueInput
  >;
  connect?: Maybe<
    FavoriteActivityWhereUniqueInput[] | FavoriteActivityWhereUniqueInput
  >;
  set?: Maybe<
    FavoriteActivityWhereUniqueInput[] | FavoriteActivityWhereUniqueInput
  >;
  disconnect?: Maybe<
    FavoriteActivityWhereUniqueInput[] | FavoriteActivityWhereUniqueInput
  >;
  deleteMany?: Maybe<
    FavoriteActivityScalarWhereInput[] | FavoriteActivityScalarWhereInput
  >;
  updateMany?: Maybe<
    | FavoriteActivityUpdateManyWithWhereNestedInput[]
    | FavoriteActivityUpdateManyWithWhereNestedInput
  >;
}

export interface FavoriteActivityUpdateWithWhereUniqueNestedInput {
  where: FavoriteActivityWhereUniqueInput;
  data: FavoriteActivityUpdateDataInput;
}

export interface FavoriteActivityUpdateDataInput {
  activityKey?: Maybe<String>;
}

export interface FavoriteActivityUpsertWithWhereUniqueNestedInput {
  where: FavoriteActivityWhereUniqueInput;
  update: FavoriteActivityUpdateDataInput;
  create: FavoriteActivityCreateInput;
}

export interface FavoriteActivityScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  activityKey?: Maybe<String>;
  activityKey_not?: Maybe<String>;
  activityKey_in?: Maybe<String[] | String>;
  activityKey_not_in?: Maybe<String[] | String>;
  activityKey_lt?: Maybe<String>;
  activityKey_lte?: Maybe<String>;
  activityKey_gt?: Maybe<String>;
  activityKey_gte?: Maybe<String>;
  activityKey_contains?: Maybe<String>;
  activityKey_not_contains?: Maybe<String>;
  activityKey_starts_with?: Maybe<String>;
  activityKey_not_starts_with?: Maybe<String>;
  activityKey_ends_with?: Maybe<String>;
  activityKey_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    FavoriteActivityScalarWhereInput[] | FavoriteActivityScalarWhereInput
  >;
  OR?: Maybe<
    FavoriteActivityScalarWhereInput[] | FavoriteActivityScalarWhereInput
  >;
  NOT?: Maybe<
    FavoriteActivityScalarWhereInput[] | FavoriteActivityScalarWhereInput
  >;
}

export interface FavoriteActivityUpdateManyWithWhereNestedInput {
  where: FavoriteActivityScalarWhereInput;
  data: FavoriteActivityUpdateManyDataInput;
}

export interface FavoriteActivityUpdateManyDataInput {
  activityKey?: Maybe<String>;
}

export interface UserUpdateOneWithoutPatientInput {
  create?: Maybe<UserCreateWithoutPatientInput>;
  update?: Maybe<UserUpdateWithoutPatientDataInput>;
  upsert?: Maybe<UserUpsertWithoutPatientInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutPatientDataInput {
  username?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<UserRole>;
  settings?: Maybe<UserSettingsUpdateOneInput>;
  notifications?: Maybe<WebPushNotificationUpdateManyInput>;
  lastActive?: Maybe<DateTimeInput>;
}

export interface UserUpsertWithoutPatientInput {
  update: UserUpdateWithoutPatientDataInput;
  create: UserCreateWithoutPatientInput;
}

export interface PatientUpsertWithoutCalendarEntriesInput {
  update: PatientUpdateWithoutCalendarEntriesDataInput;
  create: PatientCreateWithoutCalendarEntriesInput;
}

export interface SensorDataUpdateManyInput {
  create?: Maybe<SensorDataCreateInput[] | SensorDataCreateInput>;
  update?: Maybe<
    | SensorDataUpdateWithWhereUniqueNestedInput[]
    | SensorDataUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | SensorDataUpsertWithWhereUniqueNestedInput[]
    | SensorDataUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<SensorDataWhereUniqueInput[] | SensorDataWhereUniqueInput>;
  connect?: Maybe<SensorDataWhereUniqueInput[] | SensorDataWhereUniqueInput>;
  set?: Maybe<SensorDataWhereUniqueInput[] | SensorDataWhereUniqueInput>;
  disconnect?: Maybe<SensorDataWhereUniqueInput[] | SensorDataWhereUniqueInput>;
  deleteMany?: Maybe<SensorDataScalarWhereInput[] | SensorDataScalarWhereInput>;
  updateMany?: Maybe<
    | SensorDataUpdateManyWithWhereNestedInput[]
    | SensorDataUpdateManyWithWhereNestedInput
  >;
}

export interface SensorDataUpdateWithWhereUniqueNestedInput {
  where: SensorDataWhereUniqueInput;
  data: SensorDataUpdateDataInput;
}

export interface SensorDataUpdateDataInput {
  type?: Maybe<String>;
  x?: Maybe<Float>;
  y?: Maybe<Float>;
  z?: Maybe<Float>;
  alpha?: Maybe<Float>;
  beta?: Maybe<Float>;
  gamma?: Maybe<Float>;
}

export interface SensorDataUpsertWithWhereUniqueNestedInput {
  where: SensorDataWhereUniqueInput;
  update: SensorDataUpdateDataInput;
  create: SensorDataCreateInput;
}

export interface SensorDataScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  x?: Maybe<Float>;
  x_not?: Maybe<Float>;
  x_in?: Maybe<Float[] | Float>;
  x_not_in?: Maybe<Float[] | Float>;
  x_lt?: Maybe<Float>;
  x_lte?: Maybe<Float>;
  x_gt?: Maybe<Float>;
  x_gte?: Maybe<Float>;
  y?: Maybe<Float>;
  y_not?: Maybe<Float>;
  y_in?: Maybe<Float[] | Float>;
  y_not_in?: Maybe<Float[] | Float>;
  y_lt?: Maybe<Float>;
  y_lte?: Maybe<Float>;
  y_gt?: Maybe<Float>;
  y_gte?: Maybe<Float>;
  z?: Maybe<Float>;
  z_not?: Maybe<Float>;
  z_in?: Maybe<Float[] | Float>;
  z_not_in?: Maybe<Float[] | Float>;
  z_lt?: Maybe<Float>;
  z_lte?: Maybe<Float>;
  z_gt?: Maybe<Float>;
  z_gte?: Maybe<Float>;
  alpha?: Maybe<Float>;
  alpha_not?: Maybe<Float>;
  alpha_in?: Maybe<Float[] | Float>;
  alpha_not_in?: Maybe<Float[] | Float>;
  alpha_lt?: Maybe<Float>;
  alpha_lte?: Maybe<Float>;
  alpha_gt?: Maybe<Float>;
  alpha_gte?: Maybe<Float>;
  beta?: Maybe<Float>;
  beta_not?: Maybe<Float>;
  beta_in?: Maybe<Float[] | Float>;
  beta_not_in?: Maybe<Float[] | Float>;
  beta_lt?: Maybe<Float>;
  beta_lte?: Maybe<Float>;
  beta_gt?: Maybe<Float>;
  beta_gte?: Maybe<Float>;
  gamma?: Maybe<Float>;
  gamma_not?: Maybe<Float>;
  gamma_in?: Maybe<Float[] | Float>;
  gamma_not_in?: Maybe<Float[] | Float>;
  gamma_lt?: Maybe<Float>;
  gamma_lte?: Maybe<Float>;
  gamma_gt?: Maybe<Float>;
  gamma_gte?: Maybe<Float>;
  AND?: Maybe<SensorDataScalarWhereInput[] | SensorDataScalarWhereInput>;
  OR?: Maybe<SensorDataScalarWhereInput[] | SensorDataScalarWhereInput>;
  NOT?: Maybe<SensorDataScalarWhereInput[] | SensorDataScalarWhereInput>;
}

export interface SensorDataUpdateManyWithWhereNestedInput {
  where: SensorDataScalarWhereInput;
  data: SensorDataUpdateManyDataInput;
}

export interface SensorDataUpdateManyDataInput {
  type?: Maybe<String>;
  x?: Maybe<Float>;
  y?: Maybe<Float>;
  z?: Maybe<Float>;
  alpha?: Maybe<Float>;
  beta?: Maybe<Float>;
  gamma?: Maybe<Float>;
}

export interface CalendarEntryUpsertNestedInput {
  update: CalendarEntryUpdateDataInput;
  create: CalendarEntryCreateInput;
}

export interface ChatMessageAttachmentUpsertWithoutChatMessageInput {
  update: ChatMessageAttachmentUpdateWithoutChatMessageDataInput;
  create: ChatMessageAttachmentCreateWithoutChatMessageInput;
}

export interface ChatMessageUpsertWithWhereUniqueWithoutChatInput {
  where: ChatMessageWhereUniqueInput;
  update: ChatMessageUpdateWithoutChatDataInput;
  create: ChatMessageCreateWithoutChatInput;
}

export interface ChatMessageScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  AND?: Maybe<ChatMessageScalarWhereInput[] | ChatMessageScalarWhereInput>;
  OR?: Maybe<ChatMessageScalarWhereInput[] | ChatMessageScalarWhereInput>;
  NOT?: Maybe<ChatMessageScalarWhereInput[] | ChatMessageScalarWhereInput>;
}

export interface ChatMessageUpdateManyWithWhereNestedInput {
  where: ChatMessageScalarWhereInput;
  data: ChatMessageUpdateManyDataInput;
}

export interface ChatMessageUpdateManyDataInput {
  text?: Maybe<String>;
}

export interface BotUpdateOneWithoutChatInput {
  create?: Maybe<BotCreateWithoutChatInput>;
  update?: Maybe<BotUpdateWithoutChatDataInput>;
  upsert?: Maybe<BotUpsertWithoutChatInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BotWhereUniqueInput>;
}

export interface BotUpdateWithoutChatDataInput {
  name?: Maybe<String>;
}

export interface BotUpsertWithoutChatInput {
  update: BotUpdateWithoutChatDataInput;
  create: BotCreateWithoutChatInput;
}

export interface ChatUpsertNestedInput {
  update: ChatUpdateDataInput;
  create: ChatCreateInput;
}

export interface BuddyUpsertWithoutPatientInput {
  update: BuddyUpdateWithoutPatientDataInput;
  create: BuddyCreateWithoutPatientInput;
}

export interface CalendarEntryUpdateManyWithoutPatientInput {
  create?: Maybe<
    | CalendarEntryCreateWithoutPatientInput[]
    | CalendarEntryCreateWithoutPatientInput
  >;
  delete?: Maybe<
    CalendarEntryWhereUniqueInput[] | CalendarEntryWhereUniqueInput
  >;
  connect?: Maybe<
    CalendarEntryWhereUniqueInput[] | CalendarEntryWhereUniqueInput
  >;
  set?: Maybe<CalendarEntryWhereUniqueInput[] | CalendarEntryWhereUniqueInput>;
  disconnect?: Maybe<
    CalendarEntryWhereUniqueInput[] | CalendarEntryWhereUniqueInput
  >;
  update?: Maybe<
    | CalendarEntryUpdateWithWhereUniqueWithoutPatientInput[]
    | CalendarEntryUpdateWithWhereUniqueWithoutPatientInput
  >;
  upsert?: Maybe<
    | CalendarEntryUpsertWithWhereUniqueWithoutPatientInput[]
    | CalendarEntryUpsertWithWhereUniqueWithoutPatientInput
  >;
  deleteMany?: Maybe<
    CalendarEntryScalarWhereInput[] | CalendarEntryScalarWhereInput
  >;
  updateMany?: Maybe<
    | CalendarEntryUpdateManyWithWhereNestedInput[]
    | CalendarEntryUpdateManyWithWhereNestedInput
  >;
}

export interface CalendarEntryUpdateWithWhereUniqueWithoutPatientInput {
  where: CalendarEntryWhereUniqueInput;
  data: CalendarEntryUpdateWithoutPatientDataInput;
}

export interface CalendarEntryUpdateWithoutPatientDataInput {
  activity?: Maybe<ActivityUpdateOneRequiredInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  isDone?: Maybe<Boolean>;
  isRunning?: Maybe<Boolean>;
  trackingRequested?: Maybe<Boolean>;
  sensorData?: Maybe<SensorDataUpdateManyInput>;
}

export interface CalendarEntryUpsertWithWhereUniqueWithoutPatientInput {
  where: CalendarEntryWhereUniqueInput;
  update: CalendarEntryUpdateWithoutPatientDataInput;
  create: CalendarEntryCreateWithoutPatientInput;
}

export interface CalendarEntryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  endTime_not?: Maybe<DateTimeInput>;
  endTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_lt?: Maybe<DateTimeInput>;
  endTime_lte?: Maybe<DateTimeInput>;
  endTime_gt?: Maybe<DateTimeInput>;
  endTime_gte?: Maybe<DateTimeInput>;
  isDone?: Maybe<Boolean>;
  isDone_not?: Maybe<Boolean>;
  isRunning?: Maybe<Boolean>;
  isRunning_not?: Maybe<Boolean>;
  trackingRequested?: Maybe<Boolean>;
  trackingRequested_not?: Maybe<Boolean>;
  AND?: Maybe<CalendarEntryScalarWhereInput[] | CalendarEntryScalarWhereInput>;
  OR?: Maybe<CalendarEntryScalarWhereInput[] | CalendarEntryScalarWhereInput>;
  NOT?: Maybe<CalendarEntryScalarWhereInput[] | CalendarEntryScalarWhereInput>;
}

export interface CalendarEntryUpdateManyWithWhereNestedInput {
  where: CalendarEntryScalarWhereInput;
  data: CalendarEntryUpdateManyDataInput;
}

export interface CalendarEntryUpdateManyDataInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  isDone?: Maybe<Boolean>;
  isRunning?: Maybe<Boolean>;
  trackingRequested?: Maybe<Boolean>;
}

export interface PatientUpsertWithoutUserInput {
  update: PatientUpdateWithoutUserDataInput;
  create: PatientCreateWithoutUserInput;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  role?: Maybe<UserRole>;
  role_not?: Maybe<UserRole>;
  role_in?: Maybe<UserRole[] | UserRole>;
  role_not_in?: Maybe<UserRole[] | UserRole>;
  lastActive?: Maybe<DateTimeInput>;
  lastActive_not?: Maybe<DateTimeInput>;
  lastActive_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastActive_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastActive_lt?: Maybe<DateTimeInput>;
  lastActive_lte?: Maybe<DateTimeInput>;
  lastActive_gt?: Maybe<DateTimeInput>;
  lastActive_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  username?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<UserRole>;
  lastActive?: Maybe<DateTimeInput>;
}

export interface GroupUpdateManyWithoutChallengeInput {
  create?: Maybe<
    GroupCreateWithoutChallengeInput[] | GroupCreateWithoutChallengeInput
  >;
  delete?: Maybe<GroupWhereUniqueInput[] | GroupWhereUniqueInput>;
  connect?: Maybe<GroupWhereUniqueInput[] | GroupWhereUniqueInput>;
  set?: Maybe<GroupWhereUniqueInput[] | GroupWhereUniqueInput>;
  disconnect?: Maybe<GroupWhereUniqueInput[] | GroupWhereUniqueInput>;
  update?: Maybe<
    | GroupUpdateWithWhereUniqueWithoutChallengeInput[]
    | GroupUpdateWithWhereUniqueWithoutChallengeInput
  >;
  upsert?: Maybe<
    | GroupUpsertWithWhereUniqueWithoutChallengeInput[]
    | GroupUpsertWithWhereUniqueWithoutChallengeInput
  >;
  deleteMany?: Maybe<GroupScalarWhereInput[] | GroupScalarWhereInput>;
  updateMany?: Maybe<
    GroupUpdateManyWithWhereNestedInput[] | GroupUpdateManyWithWhereNestedInput
  >;
}

export interface GroupUpdateWithWhereUniqueWithoutChallengeInput {
  where: GroupWhereUniqueInput;
  data: GroupUpdateWithoutChallengeDataInput;
}

export interface GroupUpdateWithoutChallengeDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneInput>;
}

export interface GroupUpsertWithWhereUniqueWithoutChallengeInput {
  where: GroupWhereUniqueInput;
  update: GroupUpdateWithoutChallengeDataInput;
  create: GroupCreateWithoutChallengeInput;
}

export interface GroupScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<GroupScalarWhereInput[] | GroupScalarWhereInput>;
  OR?: Maybe<GroupScalarWhereInput[] | GroupScalarWhereInput>;
  NOT?: Maybe<GroupScalarWhereInput[] | GroupScalarWhereInput>;
}

export interface GroupUpdateManyWithWhereNestedInput {
  where: GroupScalarWhereInput;
  data: GroupUpdateManyDataInput;
}

export interface GroupUpdateManyDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
}

export interface CategoryUpdateManyWithoutChallengeInput {
  create?: Maybe<
    CategoryCreateWithoutChallengeInput[] | CategoryCreateWithoutChallengeInput
  >;
  delete?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  connect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  set?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  disconnect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  update?: Maybe<
    | CategoryUpdateWithWhereUniqueWithoutChallengeInput[]
    | CategoryUpdateWithWhereUniqueWithoutChallengeInput
  >;
  upsert?: Maybe<
    | CategoryUpsertWithWhereUniqueWithoutChallengeInput[]
    | CategoryUpsertWithWhereUniqueWithoutChallengeInput
  >;
  deleteMany?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
  updateMany?: Maybe<
    | CategoryUpdateManyWithWhereNestedInput[]
    | CategoryUpdateManyWithWhereNestedInput
  >;
}

export interface CategoryUpdateWithWhereUniqueWithoutChallengeInput {
  where: CategoryWhereUniqueInput;
  data: CategoryUpdateWithoutChallengeDataInput;
}

export interface CategoryUpdateWithoutChallengeDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
}

export interface CategoryUpsertWithWhereUniqueWithoutChallengeInput {
  where: CategoryWhereUniqueInput;
  update: CategoryUpdateWithoutChallengeDataInput;
  create: CategoryCreateWithoutChallengeInput;
}

export interface CategoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
  OR?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
  NOT?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
}

export interface CategoryUpdateManyWithWhereNestedInput {
  where: CategoryScalarWhereInput;
  data: CategoryUpdateManyDataInput;
}

export interface CategoryUpdateManyDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
}

export interface ChallengeUpsertNestedInput {
  update: ChallengeUpdateDataInput;
  create: ChallengeCreateInput;
}

export interface ContributionUpdateOneInput {
  create?: Maybe<ContributionCreateInput>;
  update?: Maybe<ContributionUpdateDataInput>;
  upsert?: Maybe<ContributionUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ContributionWhereUniqueInput>;
}

export interface ContributionUpdateDataInput {
  challengeID?: Maybe<ChallengeUpdateOneInput>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  image?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneInput>;
}

export interface ContributionUpsertNestedInput {
  update: ContributionUpdateDataInput;
  create: ContributionCreateInput;
}

export interface VotingUpdateOneInput {
  create?: Maybe<VotingCreateInput>;
  update?: Maybe<VotingUpdateDataInput>;
  upsert?: Maybe<VotingUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<VotingWhereUniqueInput>;
}

export interface VotingUpdateDataInput {
  challengeID?: Maybe<ChallengeUpdateOneInput>;
  contributionID?: Maybe<ContributionUpdateOneInput>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  votedPoint?: Maybe<Int>;
  createdBy?: Maybe<UserUpdateOneInput>;
}

export interface VotingUpsertNestedInput {
  update: VotingUpdateDataInput;
  create: VotingCreateInput;
}

export interface AwardUpdateManyMutationInput {
  status?: Maybe<AwardVT>;
}

export interface BotUpdateInput {
  name?: Maybe<String>;
  chat?: Maybe<ChatUpdateOneWithoutBotInput>;
}

export interface BotUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface BotSettingsCreateInput {
  id?: Maybe<ID_Input>;
  botFirstGreetingText?: Maybe<String>;
  botFirstGreetingTextDelay?: Maybe<TimeSpanCreateOneInput>;
  botAskCreateActivitiesTime?: Maybe<TimeSpanCreateOneInput>;
  botAskCreateActivitiesMessage?: Maybe<String>;
  botActivityLessThanPlannedMessage?: Maybe<String>;
  botActivityLessThanPlannedWeekday?: Maybe<Int>;
  botAskStartChatIntervall?: Maybe<TimeSpanCreateOneInput>;
  botAskStartChatMessage?: Maybe<String>;
}

export interface TimeSpanCreateOneInput {
  create?: Maybe<TimeSpanCreateInput>;
  connect?: Maybe<TimeSpanWhereUniqueInput>;
}

export interface TimeSpanCreateInput {
  id?: Maybe<ID_Input>;
  days?: Maybe<Int>;
  hours?: Maybe<Int>;
  minutes?: Maybe<Int>;
  seconds?: Maybe<Int>;
}

export interface BotSettingsUpdateInput {
  botFirstGreetingText?: Maybe<String>;
  botFirstGreetingTextDelay?: Maybe<TimeSpanUpdateOneInput>;
  botAskCreateActivitiesTime?: Maybe<TimeSpanUpdateOneInput>;
  botAskCreateActivitiesMessage?: Maybe<String>;
  botActivityLessThanPlannedMessage?: Maybe<String>;
  botActivityLessThanPlannedWeekday?: Maybe<Int>;
  botAskStartChatIntervall?: Maybe<TimeSpanUpdateOneInput>;
  botAskStartChatMessage?: Maybe<String>;
}

export interface TimeSpanUpdateOneInput {
  create?: Maybe<TimeSpanCreateInput>;
  update?: Maybe<TimeSpanUpdateDataInput>;
  upsert?: Maybe<TimeSpanUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TimeSpanWhereUniqueInput>;
}

export interface TimeSpanUpdateDataInput {
  days?: Maybe<Int>;
  hours?: Maybe<Int>;
  minutes?: Maybe<Int>;
  seconds?: Maybe<Int>;
}

export interface TimeSpanUpsertNestedInput {
  update: TimeSpanUpdateDataInput;
  create: TimeSpanCreateInput;
}

export interface BotSettingsUpdateManyMutationInput {
  botFirstGreetingText?: Maybe<String>;
  botAskCreateActivitiesMessage?: Maybe<String>;
  botActivityLessThanPlannedMessage?: Maybe<String>;
  botActivityLessThanPlannedWeekday?: Maybe<Int>;
  botAskStartChatMessage?: Maybe<String>;
}

export interface BuddyCreateInput {
  id?: Maybe<ID_Input>;
  patient: PatientCreateOneWithoutBuddyInput;
  chat?: Maybe<ChatCreateOneInput>;
}

export interface PatientCreateOneWithoutBuddyInput {
  create?: Maybe<PatientCreateWithoutBuddyInput>;
  connect?: Maybe<PatientWhereUniqueInput>;
}

export interface PatientCreateWithoutBuddyInput {
  id?: Maybe<ID_Input>;
  verificationCode: String;
  verified?: Maybe<Boolean>;
  profile?: Maybe<PatientProfileInfoCreateOneInput>;
  quests?: Maybe<QuestionnairesCreateOneWithoutPatientInput>;
  online?: Maybe<Boolean>;
  activities?: Maybe<ActivityCreateManyInput>;
  favoriteActivities?: Maybe<FavoriteActivityCreateManyInput>;
  calendarEntries?: Maybe<CalendarEntryCreateManyWithoutPatientInput>;
  activeMinutesPerWeek?: Maybe<Int>;
  user?: Maybe<UserCreateOneWithoutPatientInput>;
}

export interface BuddyUpdateInput {
  patient?: Maybe<PatientUpdateOneRequiredWithoutBuddyInput>;
  chat?: Maybe<ChatUpdateOneInput>;
}

export interface PatientUpdateOneRequiredWithoutBuddyInput {
  create?: Maybe<PatientCreateWithoutBuddyInput>;
  update?: Maybe<PatientUpdateWithoutBuddyDataInput>;
  upsert?: Maybe<PatientUpsertWithoutBuddyInput>;
  connect?: Maybe<PatientWhereUniqueInput>;
}

export interface PatientUpdateWithoutBuddyDataInput {
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  profile?: Maybe<PatientProfileInfoUpdateOneInput>;
  quests?: Maybe<QuestionnairesUpdateOneWithoutPatientInput>;
  online?: Maybe<Boolean>;
  activities?: Maybe<ActivityUpdateManyInput>;
  favoriteActivities?: Maybe<FavoriteActivityUpdateManyInput>;
  calendarEntries?: Maybe<CalendarEntryUpdateManyWithoutPatientInput>;
  activeMinutesPerWeek?: Maybe<Int>;
  user?: Maybe<UserUpdateOneWithoutPatientInput>;
}

export interface PatientUpsertWithoutBuddyInput {
  update: PatientUpdateWithoutBuddyDataInput;
  create: PatientCreateWithoutBuddyInput;
}

export interface BuddyRequestCreateInput {
  id?: Maybe<ID_Input>;
  from: PatientCreateOneInput;
  to?: Maybe<PatientCreateOneInput>;
  state?: Maybe<BuddyRequestState>;
}

export interface PatientCreateOneInput {
  create?: Maybe<PatientCreateInput>;
  connect?: Maybe<PatientWhereUniqueInput>;
}

export interface PatientCreateInput {
  id?: Maybe<ID_Input>;
  verificationCode: String;
  verified?: Maybe<Boolean>;
  profile?: Maybe<PatientProfileInfoCreateOneInput>;
  buddy?: Maybe<BuddyCreateOneWithoutPatientInput>;
  quests?: Maybe<QuestionnairesCreateOneWithoutPatientInput>;
  online?: Maybe<Boolean>;
  activities?: Maybe<ActivityCreateManyInput>;
  favoriteActivities?: Maybe<FavoriteActivityCreateManyInput>;
  calendarEntries?: Maybe<CalendarEntryCreateManyWithoutPatientInput>;
  activeMinutesPerWeek?: Maybe<Int>;
  user?: Maybe<UserCreateOneWithoutPatientInput>;
}

export interface BuddyRequestUpdateInput {
  from?: Maybe<PatientUpdateOneRequiredInput>;
  to?: Maybe<PatientUpdateOneInput>;
  state?: Maybe<BuddyRequestState>;
}

export interface PatientUpdateOneRequiredInput {
  create?: Maybe<PatientCreateInput>;
  update?: Maybe<PatientUpdateDataInput>;
  upsert?: Maybe<PatientUpsertNestedInput>;
  connect?: Maybe<PatientWhereUniqueInput>;
}

export interface PatientUpdateDataInput {
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  profile?: Maybe<PatientProfileInfoUpdateOneInput>;
  buddy?: Maybe<BuddyUpdateOneWithoutPatientInput>;
  quests?: Maybe<QuestionnairesUpdateOneWithoutPatientInput>;
  online?: Maybe<Boolean>;
  activities?: Maybe<ActivityUpdateManyInput>;
  favoriteActivities?: Maybe<FavoriteActivityUpdateManyInput>;
  calendarEntries?: Maybe<CalendarEntryUpdateManyWithoutPatientInput>;
  activeMinutesPerWeek?: Maybe<Int>;
  user?: Maybe<UserUpdateOneWithoutPatientInput>;
}

export interface PatientUpsertNestedInput {
  update: PatientUpdateDataInput;
  create: PatientCreateInput;
}

export interface PatientUpdateOneInput {
  create?: Maybe<PatientCreateInput>;
  update?: Maybe<PatientUpdateDataInput>;
  upsert?: Maybe<PatientUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PatientWhereUniqueInput>;
}

export interface BuddyRequestUpdateManyMutationInput {
  state?: Maybe<BuddyRequestState>;
}

export interface CalendarEntryUpdateInput {
  activity?: Maybe<ActivityUpdateOneRequiredInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  isDone?: Maybe<Boolean>;
  isRunning?: Maybe<Boolean>;
  trackingRequested?: Maybe<Boolean>;
  patient?: Maybe<PatientUpdateOneWithoutCalendarEntriesInput>;
  sensorData?: Maybe<SensorDataUpdateManyInput>;
}

export interface CalendarEntryUpdateManyMutationInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  isDone?: Maybe<Boolean>;
  isRunning?: Maybe<Boolean>;
  trackingRequested?: Maybe<Boolean>;
}

export interface CategoryCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  challenge?: Maybe<ChallengeCreateManyWithoutCategoryInput>;
}

export interface ChallengeCreateManyWithoutCategoryInput {
  create?: Maybe<
    ChallengeCreateWithoutCategoryInput[] | ChallengeCreateWithoutCategoryInput
  >;
  connect?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
}

export interface ChallengeCreateWithoutCategoryInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  image: String;
  premium?: Maybe<String>;
  timeEnd?: Maybe<DateTimeInput>;
  emailSend?: Maybe<String>;
  jury?: Maybe<UserCreateManyInput>;
  group?: Maybe<GroupCreateManyWithoutChallengeInput>;
  status?: Maybe<StatusChallegen>;
  initiator: String;
  createdBy?: Maybe<UserCreateOneInput>;
}

export interface CategoryUpdateInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  challenge?: Maybe<ChallengeUpdateManyWithoutCategoryInput>;
}

export interface ChallengeUpdateManyWithoutCategoryInput {
  create?: Maybe<
    ChallengeCreateWithoutCategoryInput[] | ChallengeCreateWithoutCategoryInput
  >;
  delete?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  connect?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  set?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  disconnect?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  update?: Maybe<
    | ChallengeUpdateWithWhereUniqueWithoutCategoryInput[]
    | ChallengeUpdateWithWhereUniqueWithoutCategoryInput
  >;
  upsert?: Maybe<
    | ChallengeUpsertWithWhereUniqueWithoutCategoryInput[]
    | ChallengeUpsertWithWhereUniqueWithoutCategoryInput
  >;
  deleteMany?: Maybe<ChallengeScalarWhereInput[] | ChallengeScalarWhereInput>;
  updateMany?: Maybe<
    | ChallengeUpdateManyWithWhereNestedInput[]
    | ChallengeUpdateManyWithWhereNestedInput
  >;
}

export interface ChallengeUpdateWithWhereUniqueWithoutCategoryInput {
  where: ChallengeWhereUniqueInput;
  data: ChallengeUpdateWithoutCategoryDataInput;
}

export interface ChallengeUpdateWithoutCategoryDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  image?: Maybe<String>;
  premium?: Maybe<String>;
  timeEnd?: Maybe<DateTimeInput>;
  emailSend?: Maybe<String>;
  jury?: Maybe<UserUpdateManyInput>;
  group?: Maybe<GroupUpdateManyWithoutChallengeInput>;
  status?: Maybe<StatusChallegen>;
  initiator?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneInput>;
}

export interface ChallengeUpsertWithWhereUniqueWithoutCategoryInput {
  where: ChallengeWhereUniqueInput;
  update: ChallengeUpdateWithoutCategoryDataInput;
  create: ChallengeCreateWithoutCategoryInput;
}

export interface ChallengeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  premium?: Maybe<String>;
  premium_not?: Maybe<String>;
  premium_in?: Maybe<String[] | String>;
  premium_not_in?: Maybe<String[] | String>;
  premium_lt?: Maybe<String>;
  premium_lte?: Maybe<String>;
  premium_gt?: Maybe<String>;
  premium_gte?: Maybe<String>;
  premium_contains?: Maybe<String>;
  premium_not_contains?: Maybe<String>;
  premium_starts_with?: Maybe<String>;
  premium_not_starts_with?: Maybe<String>;
  premium_ends_with?: Maybe<String>;
  premium_not_ends_with?: Maybe<String>;
  timeEnd?: Maybe<DateTimeInput>;
  timeEnd_not?: Maybe<DateTimeInput>;
  timeEnd_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  timeEnd_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  timeEnd_lt?: Maybe<DateTimeInput>;
  timeEnd_lte?: Maybe<DateTimeInput>;
  timeEnd_gt?: Maybe<DateTimeInput>;
  timeEnd_gte?: Maybe<DateTimeInput>;
  emailSend?: Maybe<String>;
  emailSend_not?: Maybe<String>;
  emailSend_in?: Maybe<String[] | String>;
  emailSend_not_in?: Maybe<String[] | String>;
  emailSend_lt?: Maybe<String>;
  emailSend_lte?: Maybe<String>;
  emailSend_gt?: Maybe<String>;
  emailSend_gte?: Maybe<String>;
  emailSend_contains?: Maybe<String>;
  emailSend_not_contains?: Maybe<String>;
  emailSend_starts_with?: Maybe<String>;
  emailSend_not_starts_with?: Maybe<String>;
  emailSend_ends_with?: Maybe<String>;
  emailSend_not_ends_with?: Maybe<String>;
  status?: Maybe<StatusChallegen>;
  status_not?: Maybe<StatusChallegen>;
  status_in?: Maybe<StatusChallegen[] | StatusChallegen>;
  status_not_in?: Maybe<StatusChallegen[] | StatusChallegen>;
  initiator?: Maybe<String>;
  initiator_not?: Maybe<String>;
  initiator_in?: Maybe<String[] | String>;
  initiator_not_in?: Maybe<String[] | String>;
  initiator_lt?: Maybe<String>;
  initiator_lte?: Maybe<String>;
  initiator_gt?: Maybe<String>;
  initiator_gte?: Maybe<String>;
  initiator_contains?: Maybe<String>;
  initiator_not_contains?: Maybe<String>;
  initiator_starts_with?: Maybe<String>;
  initiator_not_starts_with?: Maybe<String>;
  initiator_ends_with?: Maybe<String>;
  initiator_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ChallengeScalarWhereInput[] | ChallengeScalarWhereInput>;
  OR?: Maybe<ChallengeScalarWhereInput[] | ChallengeScalarWhereInput>;
  NOT?: Maybe<ChallengeScalarWhereInput[] | ChallengeScalarWhereInput>;
}

export interface ChallengeUpdateManyWithWhereNestedInput {
  where: ChallengeScalarWhereInput;
  data: ChallengeUpdateManyDataInput;
}

export interface ChallengeUpdateManyDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  image?: Maybe<String>;
  premium?: Maybe<String>;
  timeEnd?: Maybe<DateTimeInput>;
  emailSend?: Maybe<String>;
  status?: Maybe<StatusChallegen>;
  initiator?: Maybe<String>;
}

export interface CategoryUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
}

export interface ChallengeUpdateInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  image?: Maybe<String>;
  premium?: Maybe<String>;
  timeEnd?: Maybe<DateTimeInput>;
  emailSend?: Maybe<String>;
  jury?: Maybe<UserUpdateManyInput>;
  group?: Maybe<GroupUpdateManyWithoutChallengeInput>;
  category?: Maybe<CategoryUpdateManyWithoutChallengeInput>;
  status?: Maybe<StatusChallegen>;
  initiator?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneInput>;
}

export interface ChallengeUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  image?: Maybe<String>;
  premium?: Maybe<String>;
  timeEnd?: Maybe<DateTimeInput>;
  emailSend?: Maybe<String>;
  status?: Maybe<StatusChallegen>;
  initiator?: Maybe<String>;
}

export interface ChallengeCategoryCreateInput {
  id?: Maybe<ID_Input>;
  challegeId?: Maybe<ChallengeCreateOneInput>;
  categoryID?: Maybe<GroupCreateOneInput>;
}

export interface GroupCreateOneInput {
  create?: Maybe<GroupCreateInput>;
  connect?: Maybe<GroupWhereUniqueInput>;
}

export interface GroupCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  createdBy?: Maybe<UserCreateOneInput>;
  challenge?: Maybe<ChallengeCreateManyWithoutGroupInput>;
}

export interface ChallengeCreateManyWithoutGroupInput {
  create?: Maybe<
    ChallengeCreateWithoutGroupInput[] | ChallengeCreateWithoutGroupInput
  >;
  connect?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
}

export interface ChallengeCreateWithoutGroupInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  image: String;
  premium?: Maybe<String>;
  timeEnd?: Maybe<DateTimeInput>;
  emailSend?: Maybe<String>;
  jury?: Maybe<UserCreateManyInput>;
  category?: Maybe<CategoryCreateManyWithoutChallengeInput>;
  status?: Maybe<StatusChallegen>;
  initiator: String;
  createdBy?: Maybe<UserCreateOneInput>;
}

export interface ChallengeCategoryUpdateInput {
  challegeId?: Maybe<ChallengeUpdateOneInput>;
  categoryID?: Maybe<GroupUpdateOneInput>;
}

export interface GroupUpdateOneInput {
  create?: Maybe<GroupCreateInput>;
  update?: Maybe<GroupUpdateDataInput>;
  upsert?: Maybe<GroupUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<GroupWhereUniqueInput>;
}

export interface GroupUpdateDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneInput>;
  challenge?: Maybe<ChallengeUpdateManyWithoutGroupInput>;
}

export interface ChallengeUpdateManyWithoutGroupInput {
  create?: Maybe<
    ChallengeCreateWithoutGroupInput[] | ChallengeCreateWithoutGroupInput
  >;
  delete?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  connect?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  set?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  disconnect?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  update?: Maybe<
    | ChallengeUpdateWithWhereUniqueWithoutGroupInput[]
    | ChallengeUpdateWithWhereUniqueWithoutGroupInput
  >;
  upsert?: Maybe<
    | ChallengeUpsertWithWhereUniqueWithoutGroupInput[]
    | ChallengeUpsertWithWhereUniqueWithoutGroupInput
  >;
  deleteMany?: Maybe<ChallengeScalarWhereInput[] | ChallengeScalarWhereInput>;
  updateMany?: Maybe<
    | ChallengeUpdateManyWithWhereNestedInput[]
    | ChallengeUpdateManyWithWhereNestedInput
  >;
}

export interface ChallengeUpdateWithWhereUniqueWithoutGroupInput {
  where: ChallengeWhereUniqueInput;
  data: ChallengeUpdateWithoutGroupDataInput;
}

export interface ChallengeUpdateWithoutGroupDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  image?: Maybe<String>;
  premium?: Maybe<String>;
  timeEnd?: Maybe<DateTimeInput>;
  emailSend?: Maybe<String>;
  jury?: Maybe<UserUpdateManyInput>;
  category?: Maybe<CategoryUpdateManyWithoutChallengeInput>;
  status?: Maybe<StatusChallegen>;
  initiator?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneInput>;
}

export interface ChallengeUpsertWithWhereUniqueWithoutGroupInput {
  where: ChallengeWhereUniqueInput;
  update: ChallengeUpdateWithoutGroupDataInput;
  create: ChallengeCreateWithoutGroupInput;
}

export interface GroupUpsertNestedInput {
  update: GroupUpdateDataInput;
  create: GroupCreateInput;
}

export interface ChallengeGroupCreateInput {
  id?: Maybe<ID_Input>;
  challegeId?: Maybe<ChallengeCreateOneInput>;
  groupID?: Maybe<GroupCreateOneInput>;
}

export interface ChallengeGroupUpdateInput {
  challegeId?: Maybe<ChallengeUpdateOneInput>;
  groupID?: Maybe<GroupUpdateOneInput>;
}

export interface ChatUpdateInput {
  messages?: Maybe<ChatMessageUpdateManyWithoutChatInput>;
  bot?: Maybe<BotUpdateOneWithoutChatInput>;
}

export interface ChatMessageCreateInput {
  id?: Maybe<ID_Input>;
  chat?: Maybe<ChatCreateOneWithoutMessagesInput>;
  text?: Maybe<String>;
  author?: Maybe<UserCreateOneInput>;
  authorBot?: Maybe<BotCreateOneInput>;
  attachment?: Maybe<ChatMessageAttachmentCreateOneWithoutChatMessageInput>;
}

export interface ChatCreateOneWithoutMessagesInput {
  create?: Maybe<ChatCreateWithoutMessagesInput>;
  connect?: Maybe<ChatWhereUniqueInput>;
}

export interface ChatCreateWithoutMessagesInput {
  id?: Maybe<ID_Input>;
  bot?: Maybe<BotCreateOneWithoutChatInput>;
}

export interface ChatMessageUpdateInput {
  chat?: Maybe<ChatUpdateOneWithoutMessagesInput>;
  text?: Maybe<String>;
  author?: Maybe<UserUpdateOneInput>;
  authorBot?: Maybe<BotUpdateOneInput>;
  attachment?: Maybe<ChatMessageAttachmentUpdateOneWithoutChatMessageInput>;
}

export interface ChatUpdateOneWithoutMessagesInput {
  create?: Maybe<ChatCreateWithoutMessagesInput>;
  update?: Maybe<ChatUpdateWithoutMessagesDataInput>;
  upsert?: Maybe<ChatUpsertWithoutMessagesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ChatWhereUniqueInput>;
}

export interface ChatUpdateWithoutMessagesDataInput {
  bot?: Maybe<BotUpdateOneWithoutChatInput>;
}

export interface ChatUpsertWithoutMessagesInput {
  update: ChatUpdateWithoutMessagesDataInput;
  create: ChatCreateWithoutMessagesInput;
}

export interface ChatMessageUpdateManyMutationInput {
  text?: Maybe<String>;
}

export interface ChatMessageAttachmentCreateInput {
  id?: Maybe<ID_Input>;
  calendarEntry?: Maybe<CalendarEntryCreateOneInput>;
  originalCalendarEntryId?: Maybe<ID_Input>;
  ownerId?: Maybe<ID_Input>;
  chatMessage: ChatMessageCreateOneWithoutAttachmentInput;
}

export interface ChatMessageCreateOneWithoutAttachmentInput {
  create?: Maybe<ChatMessageCreateWithoutAttachmentInput>;
  connect?: Maybe<ChatMessageWhereUniqueInput>;
}

export interface ChatMessageCreateWithoutAttachmentInput {
  id?: Maybe<ID_Input>;
  chat?: Maybe<ChatCreateOneWithoutMessagesInput>;
  text?: Maybe<String>;
  author?: Maybe<UserCreateOneInput>;
  authorBot?: Maybe<BotCreateOneInput>;
}

export interface ChatMessageAttachmentUpdateInput {
  calendarEntry?: Maybe<CalendarEntryUpdateOneInput>;
  originalCalendarEntryId?: Maybe<ID_Input>;
  ownerId?: Maybe<ID_Input>;
  chatMessage?: Maybe<ChatMessageUpdateOneRequiredWithoutAttachmentInput>;
}

export interface ChatMessageUpdateOneRequiredWithoutAttachmentInput {
  create?: Maybe<ChatMessageCreateWithoutAttachmentInput>;
  update?: Maybe<ChatMessageUpdateWithoutAttachmentDataInput>;
  upsert?: Maybe<ChatMessageUpsertWithoutAttachmentInput>;
  connect?: Maybe<ChatMessageWhereUniqueInput>;
}

export interface ChatMessageUpdateWithoutAttachmentDataInput {
  chat?: Maybe<ChatUpdateOneWithoutMessagesInput>;
  text?: Maybe<String>;
  author?: Maybe<UserUpdateOneInput>;
  authorBot?: Maybe<BotUpdateOneInput>;
}

export interface ChatMessageUpsertWithoutAttachmentInput {
  update: ChatMessageUpdateWithoutAttachmentDataInput;
  create: ChatMessageCreateWithoutAttachmentInput;
}

export interface ChatMessageAttachmentUpdateManyMutationInput {
  originalCalendarEntryId?: Maybe<ID_Input>;
  ownerId?: Maybe<ID_Input>;
}

export interface ContributionUpdateInput {
  challengeID?: Maybe<ChallengeUpdateOneInput>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  image?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneInput>;
}

export interface ContributionUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  image?: Maybe<String>;
}

export interface FavoriteActivityUpdateInput {
  activityKey?: Maybe<String>;
}

export interface FavoriteActivityUpdateManyMutationInput {
  activityKey?: Maybe<String>;
}

export interface GlobalSettingsCreateInput {
  id?: Maybe<ID_Input>;
  matchingPercentageCap?: Maybe<Int>;
  matchingTimeout?: Maybe<TimeSpanCreateOneInput>;
  defaultActivityTimeMinutesPerWeek?: Maybe<Int>;
  minimumActivityTimeMinutes?: Maybe<Int>;
  maximumActivityTimeMinutes?: Maybe<Int>;
  ipaqGroupLowMax?: Maybe<Int>;
  ipaqGroupModerateMax?: Maybe<Int>;
  ipaqGroupHighMax?: Maybe<Int>;
  phqGroupLowMin?: Maybe<Int>;
  phqGroupLowMax?: Maybe<Int>;
  botSettings?: Maybe<BotSettingsCreateOneInput>;
  webPushSettings?: Maybe<WebPushSettingsCreateOneInput>;
}

export interface BotSettingsCreateOneInput {
  create?: Maybe<BotSettingsCreateInput>;
  connect?: Maybe<BotSettingsWhereUniqueInput>;
}

export interface WebPushSettingsCreateOneInput {
  create?: Maybe<WebPushSettingsCreateInput>;
  connect?: Maybe<WebPushSettingsWhereUniqueInput>;
}

export interface WebPushSettingsCreateInput {
  id?: Maybe<ID_Input>;
  webPushIpaqReminderIntervall?: Maybe<TimeSpanCreateOneInput>;
  webPushIpaqReminderIntervallFollowUp?: Maybe<TimeSpanCreateOneInput>;
  webPushIpaqReminderMessage?: Maybe<String>;
  webPushPhqReminderIntervall?: Maybe<TimeSpanCreateOneInput>;
  webPushPhqReminderIntervallFollowUp?: Maybe<TimeSpanCreateOneInput>;
  webPushPhqReminderMessage?: Maybe<String>;
  webPushIncomingBuddyRequestMessage?: Maybe<String>;
  webPushIncomingBuddyRequestDelay?: Maybe<TimeSpanCreateOneInput>;
  webPushIncomingRequestNoResponseMessage?: Maybe<String>;
  webPushIncomingRequestNoResponseIntervall?: Maybe<TimeSpanCreateOneInput>;
  webPushIncomingRequestNoResponseFollowupIntervall?: Maybe<
    TimeSpanCreateOneInput
  >;
  webPushIncomingRequestNotAnsweredMessage?: Maybe<String>;
  webPushIncomingRequestNotAnsweredIntervall?: Maybe<TimeSpanCreateOneInput>;
  webPushNotEnoughActivitiesMessage?: Maybe<String>;
  webPushNotEnoughActivitiesWeekday?: Maybe<Int>;
  webPushNotEnoughActivitiesBuddyMessage?: Maybe<String>;
  webPushNotEnoughActivitiesBuddyWeekday?: Maybe<Int>;
  webPushToManyActivitiesMessage?: Maybe<String>;
  webPushToManyActivitiesWeekday?: Maybe<Int>;
  webPushToManyActivitiesBuddyMessage?: Maybe<String>;
  webPushToManyActivitiesBuddyDelay?: Maybe<TimeSpanCreateOneInput>;
  webPushActivityMissedBuddyMessage?: Maybe<String>;
  webPushActivityMissedBuddyDelay?: Maybe<TimeSpanCreateOneInput>;
}

export interface GlobalSettingsUpdateInput {
  matchingPercentageCap?: Maybe<Int>;
  matchingTimeout?: Maybe<TimeSpanUpdateOneInput>;
  defaultActivityTimeMinutesPerWeek?: Maybe<Int>;
  minimumActivityTimeMinutes?: Maybe<Int>;
  maximumActivityTimeMinutes?: Maybe<Int>;
  ipaqGroupLowMax?: Maybe<Int>;
  ipaqGroupModerateMax?: Maybe<Int>;
  ipaqGroupHighMax?: Maybe<Int>;
  phqGroupLowMin?: Maybe<Int>;
  phqGroupLowMax?: Maybe<Int>;
  botSettings?: Maybe<BotSettingsUpdateOneInput>;
  webPushSettings?: Maybe<WebPushSettingsUpdateOneInput>;
}

export interface BotSettingsUpdateOneInput {
  create?: Maybe<BotSettingsCreateInput>;
  update?: Maybe<BotSettingsUpdateDataInput>;
  upsert?: Maybe<BotSettingsUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BotSettingsWhereUniqueInput>;
}

export interface BotSettingsUpdateDataInput {
  botFirstGreetingText?: Maybe<String>;
  botFirstGreetingTextDelay?: Maybe<TimeSpanUpdateOneInput>;
  botAskCreateActivitiesTime?: Maybe<TimeSpanUpdateOneInput>;
  botAskCreateActivitiesMessage?: Maybe<String>;
  botActivityLessThanPlannedMessage?: Maybe<String>;
  botActivityLessThanPlannedWeekday?: Maybe<Int>;
  botAskStartChatIntervall?: Maybe<TimeSpanUpdateOneInput>;
  botAskStartChatMessage?: Maybe<String>;
}

export interface BotSettingsUpsertNestedInput {
  update: BotSettingsUpdateDataInput;
  create: BotSettingsCreateInput;
}

export interface WebPushSettingsUpdateOneInput {
  create?: Maybe<WebPushSettingsCreateInput>;
  update?: Maybe<WebPushSettingsUpdateDataInput>;
  upsert?: Maybe<WebPushSettingsUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<WebPushSettingsWhereUniqueInput>;
}

export interface WebPushSettingsUpdateDataInput {
  webPushIpaqReminderIntervall?: Maybe<TimeSpanUpdateOneInput>;
  webPushIpaqReminderIntervallFollowUp?: Maybe<TimeSpanUpdateOneInput>;
  webPushIpaqReminderMessage?: Maybe<String>;
  webPushPhqReminderIntervall?: Maybe<TimeSpanUpdateOneInput>;
  webPushPhqReminderIntervallFollowUp?: Maybe<TimeSpanUpdateOneInput>;
  webPushPhqReminderMessage?: Maybe<String>;
  webPushIncomingBuddyRequestMessage?: Maybe<String>;
  webPushIncomingBuddyRequestDelay?: Maybe<TimeSpanUpdateOneInput>;
  webPushIncomingRequestNoResponseMessage?: Maybe<String>;
  webPushIncomingRequestNoResponseIntervall?: Maybe<TimeSpanUpdateOneInput>;
  webPushIncomingRequestNoResponseFollowupIntervall?: Maybe<
    TimeSpanUpdateOneInput
  >;
  webPushIncomingRequestNotAnsweredMessage?: Maybe<String>;
  webPushIncomingRequestNotAnsweredIntervall?: Maybe<TimeSpanUpdateOneInput>;
  webPushNotEnoughActivitiesMessage?: Maybe<String>;
  webPushNotEnoughActivitiesWeekday?: Maybe<Int>;
  webPushNotEnoughActivitiesBuddyMessage?: Maybe<String>;
  webPushNotEnoughActivitiesBuddyWeekday?: Maybe<Int>;
  webPushToManyActivitiesMessage?: Maybe<String>;
  webPushToManyActivitiesWeekday?: Maybe<Int>;
  webPushToManyActivitiesBuddyMessage?: Maybe<String>;
  webPushToManyActivitiesBuddyDelay?: Maybe<TimeSpanUpdateOneInput>;
  webPushActivityMissedBuddyMessage?: Maybe<String>;
  webPushActivityMissedBuddyDelay?: Maybe<TimeSpanUpdateOneInput>;
}

export interface WebPushSettingsUpsertNestedInput {
  update: WebPushSettingsUpdateDataInput;
  create: WebPushSettingsCreateInput;
}

export interface GlobalSettingsUpdateManyMutationInput {
  matchingPercentageCap?: Maybe<Int>;
  defaultActivityTimeMinutesPerWeek?: Maybe<Int>;
  minimumActivityTimeMinutes?: Maybe<Int>;
  maximumActivityTimeMinutes?: Maybe<Int>;
  ipaqGroupLowMax?: Maybe<Int>;
  ipaqGroupModerateMax?: Maybe<Int>;
  ipaqGroupHighMax?: Maybe<Int>;
  phqGroupLowMin?: Maybe<Int>;
  phqGroupLowMax?: Maybe<Int>;
}

export interface GroupUpdateInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneInput>;
  challenge?: Maybe<ChallengeUpdateManyWithoutGroupInput>;
}

export interface GroupUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
}

export interface GroupColorCreateInput {
  id?: Maybe<ID_Input>;
  group?: Maybe<GroupCreateOneInput>;
  color: String;
}

export interface GroupColorUpdateInput {
  group?: Maybe<GroupUpdateOneInput>;
  color?: Maybe<String>;
}

export interface GroupColorUpdateManyMutationInput {
  color?: Maybe<String>;
}

export interface InitiatorCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
}

export interface InitiatorUpdateInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
}

export interface InitiatorUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
}

export interface IpaqCreateInput {
  id?: Maybe<ID_Input>;
  answers?: Maybe<IpaqAnswersCreateManyWithoutQuestInput>;
  score?: Maybe<Float>;
  expiryDate?: Maybe<DateTimeInput>;
  isComplete?: Maybe<Boolean>;
  quests: QuestionnairesCreateOneWithoutIpaqsInput;
}

export interface QuestionnairesCreateOneWithoutIpaqsInput {
  create?: Maybe<QuestionnairesCreateWithoutIpaqsInput>;
  connect?: Maybe<QuestionnairesWhereUniqueInput>;
}

export interface QuestionnairesCreateWithoutIpaqsInput {
  id?: Maybe<ID_Input>;
  phq9s?: Maybe<Phq9CreateManyWithoutQuestsInput>;
  patient?: Maybe<PatientCreateOneWithoutQuestsInput>;
}

export interface PatientCreateOneWithoutQuestsInput {
  create?: Maybe<PatientCreateWithoutQuestsInput>;
  connect?: Maybe<PatientWhereUniqueInput>;
}

export interface PatientCreateWithoutQuestsInput {
  id?: Maybe<ID_Input>;
  verificationCode: String;
  verified?: Maybe<Boolean>;
  profile?: Maybe<PatientProfileInfoCreateOneInput>;
  buddy?: Maybe<BuddyCreateOneWithoutPatientInput>;
  online?: Maybe<Boolean>;
  activities?: Maybe<ActivityCreateManyInput>;
  favoriteActivities?: Maybe<FavoriteActivityCreateManyInput>;
  calendarEntries?: Maybe<CalendarEntryCreateManyWithoutPatientInput>;
  activeMinutesPerWeek?: Maybe<Int>;
  user?: Maybe<UserCreateOneWithoutPatientInput>;
}

export interface IpaqUpdateInput {
  answers?: Maybe<IpaqAnswersUpdateManyWithoutQuestInput>;
  score?: Maybe<Float>;
  expiryDate?: Maybe<DateTimeInput>;
  isComplete?: Maybe<Boolean>;
  quests?: Maybe<QuestionnairesUpdateOneRequiredWithoutIpaqsInput>;
}

export interface QuestionnairesUpdateOneRequiredWithoutIpaqsInput {
  create?: Maybe<QuestionnairesCreateWithoutIpaqsInput>;
  update?: Maybe<QuestionnairesUpdateWithoutIpaqsDataInput>;
  upsert?: Maybe<QuestionnairesUpsertWithoutIpaqsInput>;
  connect?: Maybe<QuestionnairesWhereUniqueInput>;
}

export interface QuestionnairesUpdateWithoutIpaqsDataInput {
  phq9s?: Maybe<Phq9UpdateManyWithoutQuestsInput>;
  patient?: Maybe<PatientUpdateOneWithoutQuestsInput>;
}

export interface PatientUpdateOneWithoutQuestsInput {
  create?: Maybe<PatientCreateWithoutQuestsInput>;
  update?: Maybe<PatientUpdateWithoutQuestsDataInput>;
  upsert?: Maybe<PatientUpsertWithoutQuestsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PatientWhereUniqueInput>;
}

export interface PatientUpdateWithoutQuestsDataInput {
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  profile?: Maybe<PatientProfileInfoUpdateOneInput>;
  buddy?: Maybe<BuddyUpdateOneWithoutPatientInput>;
  online?: Maybe<Boolean>;
  activities?: Maybe<ActivityUpdateManyInput>;
  favoriteActivities?: Maybe<FavoriteActivityUpdateManyInput>;
  calendarEntries?: Maybe<CalendarEntryUpdateManyWithoutPatientInput>;
  activeMinutesPerWeek?: Maybe<Int>;
  user?: Maybe<UserUpdateOneWithoutPatientInput>;
}

export interface PatientUpsertWithoutQuestsInput {
  update: PatientUpdateWithoutQuestsDataInput;
  create: PatientCreateWithoutQuestsInput;
}

export interface QuestionnairesUpsertWithoutIpaqsInput {
  update: QuestionnairesUpdateWithoutIpaqsDataInput;
  create: QuestionnairesCreateWithoutIpaqsInput;
}

export interface IpaqUpdateManyMutationInput {
  score?: Maybe<Float>;
  expiryDate?: Maybe<DateTimeInput>;
  isComplete?: Maybe<Boolean>;
}

export interface IpaqAnswersCreateInput {
  id?: Maybe<ID_Input>;
  numDays?: Maybe<Int>;
  numHours?: Maybe<Int>;
  numMinutes?: Maybe<Int>;
  quest: IpaqCreateOneWithoutAnswersInput;
}

export interface IpaqCreateOneWithoutAnswersInput {
  create?: Maybe<IpaqCreateWithoutAnswersInput>;
  connect?: Maybe<IpaqWhereUniqueInput>;
}

export interface IpaqCreateWithoutAnswersInput {
  id?: Maybe<ID_Input>;
  score?: Maybe<Float>;
  expiryDate?: Maybe<DateTimeInput>;
  isComplete?: Maybe<Boolean>;
  quests: QuestionnairesCreateOneWithoutIpaqsInput;
}

export interface IpaqAnswersUpdateInput {
  numDays?: Maybe<Int>;
  numHours?: Maybe<Int>;
  numMinutes?: Maybe<Int>;
  quest?: Maybe<IpaqUpdateOneRequiredWithoutAnswersInput>;
}

export interface IpaqUpdateOneRequiredWithoutAnswersInput {
  create?: Maybe<IpaqCreateWithoutAnswersInput>;
  update?: Maybe<IpaqUpdateWithoutAnswersDataInput>;
  upsert?: Maybe<IpaqUpsertWithoutAnswersInput>;
  connect?: Maybe<IpaqWhereUniqueInput>;
}

export interface IpaqUpdateWithoutAnswersDataInput {
  score?: Maybe<Float>;
  expiryDate?: Maybe<DateTimeInput>;
  isComplete?: Maybe<Boolean>;
  quests?: Maybe<QuestionnairesUpdateOneRequiredWithoutIpaqsInput>;
}

export interface IpaqUpsertWithoutAnswersInput {
  update: IpaqUpdateWithoutAnswersDataInput;
  create: IpaqCreateWithoutAnswersInput;
}

export interface IpaqAnswersUpdateManyMutationInput {
  numDays?: Maybe<Int>;
  numHours?: Maybe<Int>;
  numMinutes?: Maybe<Int>;
}

export interface JoinedChallengesCreateInput {
  id?: Maybe<ID_Input>;
  userId?: Maybe<UserCreateOneInput>;
  challegeId?: Maybe<ChallengeCreateOneInput>;
}

export interface JoinedChallengesUpdateInput {
  userId?: Maybe<UserUpdateOneInput>;
  challegeId?: Maybe<ChallengeUpdateOneInput>;
}

export interface PatientUpdateInput {
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  profile?: Maybe<PatientProfileInfoUpdateOneInput>;
  buddy?: Maybe<BuddyUpdateOneWithoutPatientInput>;
  quests?: Maybe<QuestionnairesUpdateOneWithoutPatientInput>;
  online?: Maybe<Boolean>;
  activities?: Maybe<ActivityUpdateManyInput>;
  favoriteActivities?: Maybe<FavoriteActivityUpdateManyInput>;
  calendarEntries?: Maybe<CalendarEntryUpdateManyWithoutPatientInput>;
  activeMinutesPerWeek?: Maybe<Int>;
  user?: Maybe<UserUpdateOneWithoutPatientInput>;
}

export interface PatientUpdateManyMutationInput {
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  online?: Maybe<Boolean>;
  activeMinutesPerWeek?: Maybe<Int>;
}

export interface PatientProfileInfoUpdateInput {
  birthday?: Maybe<DateTimeInput>;
  gender?: Maybe<Gender>;
  sameGender?: Maybe<Boolean>;
  hideGender?: Maybe<Boolean>;
  meetingDesired?: Maybe<Boolean>;
  avatar?: Maybe<String>;
  profileActivities?: Maybe<ProfileActivityUpdateManyInput>;
}

export interface PatientProfileInfoUpdateManyMutationInput {
  birthday?: Maybe<DateTimeInput>;
  gender?: Maybe<Gender>;
  sameGender?: Maybe<Boolean>;
  hideGender?: Maybe<Boolean>;
  meetingDesired?: Maybe<Boolean>;
  avatar?: Maybe<String>;
}

export interface Phq9CreateInput {
  id?: Maybe<ID_Input>;
  answers?: Maybe<Phq9CreateanswersInput>;
  score?: Maybe<Int>;
  isComplete?: Maybe<Boolean>;
  expiryDate?: Maybe<DateTimeInput>;
  quests: QuestionnairesCreateOneWithoutPhq9sInput;
}

export interface QuestionnairesCreateOneWithoutPhq9sInput {
  create?: Maybe<QuestionnairesCreateWithoutPhq9sInput>;
  connect?: Maybe<QuestionnairesWhereUniqueInput>;
}

export interface QuestionnairesCreateWithoutPhq9sInput {
  id?: Maybe<ID_Input>;
  ipaqs?: Maybe<IpaqCreateManyWithoutQuestsInput>;
  patient?: Maybe<PatientCreateOneWithoutQuestsInput>;
}

export interface Phq9UpdateInput {
  answers?: Maybe<Phq9UpdateanswersInput>;
  score?: Maybe<Int>;
  isComplete?: Maybe<Boolean>;
  expiryDate?: Maybe<DateTimeInput>;
  quests?: Maybe<QuestionnairesUpdateOneRequiredWithoutPhq9sInput>;
}

export interface QuestionnairesUpdateOneRequiredWithoutPhq9sInput {
  create?: Maybe<QuestionnairesCreateWithoutPhq9sInput>;
  update?: Maybe<QuestionnairesUpdateWithoutPhq9sDataInput>;
  upsert?: Maybe<QuestionnairesUpsertWithoutPhq9sInput>;
  connect?: Maybe<QuestionnairesWhereUniqueInput>;
}

export interface QuestionnairesUpdateWithoutPhq9sDataInput {
  ipaqs?: Maybe<IpaqUpdateManyWithoutQuestsInput>;
  patient?: Maybe<PatientUpdateOneWithoutQuestsInput>;
}

export interface QuestionnairesUpsertWithoutPhq9sInput {
  update: QuestionnairesUpdateWithoutPhq9sDataInput;
  create: QuestionnairesCreateWithoutPhq9sInput;
}

export interface Phq9UpdateManyMutationInput {
  answers?: Maybe<Phq9UpdateanswersInput>;
  score?: Maybe<Int>;
  isComplete?: Maybe<Boolean>;
  expiryDate?: Maybe<DateTimeInput>;
}

export interface ProfileActivityUpdateInput {
  key?: Maybe<String>;
  icon?: Maybe<String>;
  titel?: Maybe<String>;
}

export interface ProfileActivityUpdateManyMutationInput {
  key?: Maybe<String>;
  icon?: Maybe<String>;
  titel?: Maybe<String>;
}

export interface QuestionnairesCreateInput {
  id?: Maybe<ID_Input>;
  phq9s?: Maybe<Phq9CreateManyWithoutQuestsInput>;
  ipaqs?: Maybe<IpaqCreateManyWithoutQuestsInput>;
  patient?: Maybe<PatientCreateOneWithoutQuestsInput>;
}

export interface QuestionnairesUpdateInput {
  phq9s?: Maybe<Phq9UpdateManyWithoutQuestsInput>;
  ipaqs?: Maybe<IpaqUpdateManyWithoutQuestsInput>;
  patient?: Maybe<PatientUpdateOneWithoutQuestsInput>;
}

export interface ScheduledTaskCreateInput {
  id?: Maybe<ID_Input>;
  scheduledFor?: Maybe<DateTimeInput>;
  taskType: TaskTypes;
  userId?: Maybe<ID_Input>;
  chatId?: Maybe<ID_Input>;
  buddyRequestId?: Maybe<ID_Input>;
}

export interface ScheduledTaskUpdateInput {
  scheduledFor?: Maybe<DateTimeInput>;
  taskType?: Maybe<TaskTypes>;
  userId?: Maybe<ID_Input>;
  chatId?: Maybe<ID_Input>;
  buddyRequestId?: Maybe<ID_Input>;
}

export interface ScheduledTaskUpdateManyMutationInput {
  scheduledFor?: Maybe<DateTimeInput>;
  taskType?: Maybe<TaskTypes>;
  userId?: Maybe<ID_Input>;
  chatId?: Maybe<ID_Input>;
  buddyRequestId?: Maybe<ID_Input>;
}

export interface SensorDataUpdateInput {
  type?: Maybe<String>;
  x?: Maybe<Float>;
  y?: Maybe<Float>;
  z?: Maybe<Float>;
  alpha?: Maybe<Float>;
  beta?: Maybe<Float>;
  gamma?: Maybe<Float>;
}

export interface SensorDataUpdateManyMutationInput {
  type?: Maybe<String>;
  x?: Maybe<Float>;
  y?: Maybe<Float>;
  z?: Maybe<Float>;
  alpha?: Maybe<Float>;
  beta?: Maybe<Float>;
  gamma?: Maybe<Float>;
}

export interface TimeSpanUpdateInput {
  days?: Maybe<Int>;
  hours?: Maybe<Int>;
  minutes?: Maybe<Int>;
  seconds?: Maybe<Int>;
}

export interface TimeSpanUpdateManyMutationInput {
  days?: Maybe<Int>;
  hours?: Maybe<Int>;
  minutes?: Maybe<Int>;
  seconds?: Maybe<Int>;
}

export interface UserUpdateInput {
  username?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<UserRole>;
  settings?: Maybe<UserSettingsUpdateOneInput>;
  notifications?: Maybe<WebPushNotificationUpdateManyInput>;
  patient?: Maybe<PatientUpdateOneWithoutUserInput>;
  lastActive?: Maybe<DateTimeInput>;
}

export interface UserUpdateManyMutationInput {
  username?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<UserRole>;
  lastActive?: Maybe<DateTimeInput>;
}

export interface UserSettingsUpdateInput {
  themeName?: Maybe<String>;
}

export interface UserSettingsUpdateManyMutationInput {
  themeName?: Maybe<String>;
}

export interface VotingUpdateInput {
  challengeID?: Maybe<ChallengeUpdateOneInput>;
  contributionID?: Maybe<ContributionUpdateOneInput>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  votedPoint?: Maybe<Int>;
  createdBy?: Maybe<UserUpdateOneInput>;
}

export interface VotingUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  votedPoint?: Maybe<Int>;
}

export interface WebPushNotificationUpdateInput {
  name?: Maybe<String>;
  notificationInformation?: Maybe<Json>;
}

export interface WebPushNotificationUpdateManyMutationInput {
  name?: Maybe<String>;
  notificationInformation?: Maybe<Json>;
}

export interface WebPushSettingsUpdateInput {
  webPushIpaqReminderIntervall?: Maybe<TimeSpanUpdateOneInput>;
  webPushIpaqReminderIntervallFollowUp?: Maybe<TimeSpanUpdateOneInput>;
  webPushIpaqReminderMessage?: Maybe<String>;
  webPushPhqReminderIntervall?: Maybe<TimeSpanUpdateOneInput>;
  webPushPhqReminderIntervallFollowUp?: Maybe<TimeSpanUpdateOneInput>;
  webPushPhqReminderMessage?: Maybe<String>;
  webPushIncomingBuddyRequestMessage?: Maybe<String>;
  webPushIncomingBuddyRequestDelay?: Maybe<TimeSpanUpdateOneInput>;
  webPushIncomingRequestNoResponseMessage?: Maybe<String>;
  webPushIncomingRequestNoResponseIntervall?: Maybe<TimeSpanUpdateOneInput>;
  webPushIncomingRequestNoResponseFollowupIntervall?: Maybe<
    TimeSpanUpdateOneInput
  >;
  webPushIncomingRequestNotAnsweredMessage?: Maybe<String>;
  webPushIncomingRequestNotAnsweredIntervall?: Maybe<TimeSpanUpdateOneInput>;
  webPushNotEnoughActivitiesMessage?: Maybe<String>;
  webPushNotEnoughActivitiesWeekday?: Maybe<Int>;
  webPushNotEnoughActivitiesBuddyMessage?: Maybe<String>;
  webPushNotEnoughActivitiesBuddyWeekday?: Maybe<Int>;
  webPushToManyActivitiesMessage?: Maybe<String>;
  webPushToManyActivitiesWeekday?: Maybe<Int>;
  webPushToManyActivitiesBuddyMessage?: Maybe<String>;
  webPushToManyActivitiesBuddyDelay?: Maybe<TimeSpanUpdateOneInput>;
  webPushActivityMissedBuddyMessage?: Maybe<String>;
  webPushActivityMissedBuddyDelay?: Maybe<TimeSpanUpdateOneInput>;
}

export interface WebPushSettingsUpdateManyMutationInput {
  webPushIpaqReminderMessage?: Maybe<String>;
  webPushPhqReminderMessage?: Maybe<String>;
  webPushIncomingBuddyRequestMessage?: Maybe<String>;
  webPushIncomingRequestNoResponseMessage?: Maybe<String>;
  webPushIncomingRequestNotAnsweredMessage?: Maybe<String>;
  webPushNotEnoughActivitiesMessage?: Maybe<String>;
  webPushNotEnoughActivitiesWeekday?: Maybe<Int>;
  webPushNotEnoughActivitiesBuddyMessage?: Maybe<String>;
  webPushNotEnoughActivitiesBuddyWeekday?: Maybe<Int>;
  webPushToManyActivitiesMessage?: Maybe<String>;
  webPushToManyActivitiesWeekday?: Maybe<Int>;
  webPushToManyActivitiesBuddyMessage?: Maybe<String>;
  webPushActivityMissedBuddyMessage?: Maybe<String>;
}

export interface ActivitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ActivityWhereInput>;
  AND?: Maybe<
    ActivitySubscriptionWhereInput[] | ActivitySubscriptionWhereInput
  >;
  OR?: Maybe<ActivitySubscriptionWhereInput[] | ActivitySubscriptionWhereInput>;
  NOT?: Maybe<
    ActivitySubscriptionWhereInput[] | ActivitySubscriptionWhereInput
  >;
}

export interface AwardSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AwardWhereInput>;
  AND?: Maybe<AwardSubscriptionWhereInput[] | AwardSubscriptionWhereInput>;
  OR?: Maybe<AwardSubscriptionWhereInput[] | AwardSubscriptionWhereInput>;
  NOT?: Maybe<AwardSubscriptionWhereInput[] | AwardSubscriptionWhereInput>;
}

export interface BotSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BotWhereInput>;
  AND?: Maybe<BotSubscriptionWhereInput[] | BotSubscriptionWhereInput>;
  OR?: Maybe<BotSubscriptionWhereInput[] | BotSubscriptionWhereInput>;
  NOT?: Maybe<BotSubscriptionWhereInput[] | BotSubscriptionWhereInput>;
}

export interface BotSettingsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BotSettingsWhereInput>;
  AND?: Maybe<
    BotSettingsSubscriptionWhereInput[] | BotSettingsSubscriptionWhereInput
  >;
  OR?: Maybe<
    BotSettingsSubscriptionWhereInput[] | BotSettingsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BotSettingsSubscriptionWhereInput[] | BotSettingsSubscriptionWhereInput
  >;
}

export interface BuddySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BuddyWhereInput>;
  AND?: Maybe<BuddySubscriptionWhereInput[] | BuddySubscriptionWhereInput>;
  OR?: Maybe<BuddySubscriptionWhereInput[] | BuddySubscriptionWhereInput>;
  NOT?: Maybe<BuddySubscriptionWhereInput[] | BuddySubscriptionWhereInput>;
}

export interface BuddyRequestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BuddyRequestWhereInput>;
  AND?: Maybe<
    BuddyRequestSubscriptionWhereInput[] | BuddyRequestSubscriptionWhereInput
  >;
  OR?: Maybe<
    BuddyRequestSubscriptionWhereInput[] | BuddyRequestSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BuddyRequestSubscriptionWhereInput[] | BuddyRequestSubscriptionWhereInput
  >;
}

export interface CalendarEntrySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CalendarEntryWhereInput>;
  AND?: Maybe<
    CalendarEntrySubscriptionWhereInput[] | CalendarEntrySubscriptionWhereInput
  >;
  OR?: Maybe<
    CalendarEntrySubscriptionWhereInput[] | CalendarEntrySubscriptionWhereInput
  >;
  NOT?: Maybe<
    CalendarEntrySubscriptionWhereInput[] | CalendarEntrySubscriptionWhereInput
  >;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CategoryWhereInput>;
  AND?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
  OR?: Maybe<CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput>;
  NOT?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
}

export interface ChallengeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChallengeWhereInput>;
  AND?: Maybe<
    ChallengeSubscriptionWhereInput[] | ChallengeSubscriptionWhereInput
  >;
  OR?: Maybe<
    ChallengeSubscriptionWhereInput[] | ChallengeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ChallengeSubscriptionWhereInput[] | ChallengeSubscriptionWhereInput
  >;
}

export interface ChallengeCategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChallengeCategoryWhereInput>;
  AND?: Maybe<
    | ChallengeCategorySubscriptionWhereInput[]
    | ChallengeCategorySubscriptionWhereInput
  >;
  OR?: Maybe<
    | ChallengeCategorySubscriptionWhereInput[]
    | ChallengeCategorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ChallengeCategorySubscriptionWhereInput[]
    | ChallengeCategorySubscriptionWhereInput
  >;
}

export interface ChallengeGroupSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChallengeGroupWhereInput>;
  AND?: Maybe<
    | ChallengeGroupSubscriptionWhereInput[]
    | ChallengeGroupSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ChallengeGroupSubscriptionWhereInput[]
    | ChallengeGroupSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ChallengeGroupSubscriptionWhereInput[]
    | ChallengeGroupSubscriptionWhereInput
  >;
}

export interface ChatSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChatWhereInput>;
  AND?: Maybe<ChatSubscriptionWhereInput[] | ChatSubscriptionWhereInput>;
  OR?: Maybe<ChatSubscriptionWhereInput[] | ChatSubscriptionWhereInput>;
  NOT?: Maybe<ChatSubscriptionWhereInput[] | ChatSubscriptionWhereInput>;
}

export interface ChatMessageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChatMessageWhereInput>;
  AND?: Maybe<
    ChatMessageSubscriptionWhereInput[] | ChatMessageSubscriptionWhereInput
  >;
  OR?: Maybe<
    ChatMessageSubscriptionWhereInput[] | ChatMessageSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ChatMessageSubscriptionWhereInput[] | ChatMessageSubscriptionWhereInput
  >;
}

export interface ChatMessageAttachmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChatMessageAttachmentWhereInput>;
  AND?: Maybe<
    | ChatMessageAttachmentSubscriptionWhereInput[]
    | ChatMessageAttachmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ChatMessageAttachmentSubscriptionWhereInput[]
    | ChatMessageAttachmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ChatMessageAttachmentSubscriptionWhereInput[]
    | ChatMessageAttachmentSubscriptionWhereInput
  >;
}

export interface ContributionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ContributionWhereInput>;
  AND?: Maybe<
    ContributionSubscriptionWhereInput[] | ContributionSubscriptionWhereInput
  >;
  OR?: Maybe<
    ContributionSubscriptionWhereInput[] | ContributionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ContributionSubscriptionWhereInput[] | ContributionSubscriptionWhereInput
  >;
}

export interface FavoriteActivitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FavoriteActivityWhereInput>;
  AND?: Maybe<
    | FavoriteActivitySubscriptionWhereInput[]
    | FavoriteActivitySubscriptionWhereInput
  >;
  OR?: Maybe<
    | FavoriteActivitySubscriptionWhereInput[]
    | FavoriteActivitySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | FavoriteActivitySubscriptionWhereInput[]
    | FavoriteActivitySubscriptionWhereInput
  >;
}

export interface GlobalSettingsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GlobalSettingsWhereInput>;
  AND?: Maybe<
    | GlobalSettingsSubscriptionWhereInput[]
    | GlobalSettingsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | GlobalSettingsSubscriptionWhereInput[]
    | GlobalSettingsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | GlobalSettingsSubscriptionWhereInput[]
    | GlobalSettingsSubscriptionWhereInput
  >;
}

export interface GroupSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GroupWhereInput>;
  AND?: Maybe<GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput>;
  OR?: Maybe<GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput>;
  NOT?: Maybe<GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput>;
}

export interface GroupColorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GroupColorWhereInput>;
  AND?: Maybe<
    GroupColorSubscriptionWhereInput[] | GroupColorSubscriptionWhereInput
  >;
  OR?: Maybe<
    GroupColorSubscriptionWhereInput[] | GroupColorSubscriptionWhereInput
  >;
  NOT?: Maybe<
    GroupColorSubscriptionWhereInput[] | GroupColorSubscriptionWhereInput
  >;
}

export interface InitiatorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InitiatorWhereInput>;
  AND?: Maybe<
    InitiatorSubscriptionWhereInput[] | InitiatorSubscriptionWhereInput
  >;
  OR?: Maybe<
    InitiatorSubscriptionWhereInput[] | InitiatorSubscriptionWhereInput
  >;
  NOT?: Maybe<
    InitiatorSubscriptionWhereInput[] | InitiatorSubscriptionWhereInput
  >;
}

export interface IpaqSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<IpaqWhereInput>;
  AND?: Maybe<IpaqSubscriptionWhereInput[] | IpaqSubscriptionWhereInput>;
  OR?: Maybe<IpaqSubscriptionWhereInput[] | IpaqSubscriptionWhereInput>;
  NOT?: Maybe<IpaqSubscriptionWhereInput[] | IpaqSubscriptionWhereInput>;
}

export interface IpaqAnswersSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<IpaqAnswersWhereInput>;
  AND?: Maybe<
    IpaqAnswersSubscriptionWhereInput[] | IpaqAnswersSubscriptionWhereInput
  >;
  OR?: Maybe<
    IpaqAnswersSubscriptionWhereInput[] | IpaqAnswersSubscriptionWhereInput
  >;
  NOT?: Maybe<
    IpaqAnswersSubscriptionWhereInput[] | IpaqAnswersSubscriptionWhereInput
  >;
}

export interface JoinedChallengesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<JoinedChallengesWhereInput>;
  AND?: Maybe<
    | JoinedChallengesSubscriptionWhereInput[]
    | JoinedChallengesSubscriptionWhereInput
  >;
  OR?: Maybe<
    | JoinedChallengesSubscriptionWhereInput[]
    | JoinedChallengesSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | JoinedChallengesSubscriptionWhereInput[]
    | JoinedChallengesSubscriptionWhereInput
  >;
}

export interface PatientSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PatientWhereInput>;
  AND?: Maybe<PatientSubscriptionWhereInput[] | PatientSubscriptionWhereInput>;
  OR?: Maybe<PatientSubscriptionWhereInput[] | PatientSubscriptionWhereInput>;
  NOT?: Maybe<PatientSubscriptionWhereInput[] | PatientSubscriptionWhereInput>;
}

export interface PatientProfileInfoSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PatientProfileInfoWhereInput>;
  AND?: Maybe<
    | PatientProfileInfoSubscriptionWhereInput[]
    | PatientProfileInfoSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PatientProfileInfoSubscriptionWhereInput[]
    | PatientProfileInfoSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PatientProfileInfoSubscriptionWhereInput[]
    | PatientProfileInfoSubscriptionWhereInput
  >;
}

export interface Phq9SubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<Phq9WhereInput>;
  AND?: Maybe<Phq9SubscriptionWhereInput[] | Phq9SubscriptionWhereInput>;
  OR?: Maybe<Phq9SubscriptionWhereInput[] | Phq9SubscriptionWhereInput>;
  NOT?: Maybe<Phq9SubscriptionWhereInput[] | Phq9SubscriptionWhereInput>;
}

export interface ProfileActivitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProfileActivityWhereInput>;
  AND?: Maybe<
    | ProfileActivitySubscriptionWhereInput[]
    | ProfileActivitySubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProfileActivitySubscriptionWhereInput[]
    | ProfileActivitySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProfileActivitySubscriptionWhereInput[]
    | ProfileActivitySubscriptionWhereInput
  >;
}

export interface QuestionnairesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuestionnairesWhereInput>;
  AND?: Maybe<
    | QuestionnairesSubscriptionWhereInput[]
    | QuestionnairesSubscriptionWhereInput
  >;
  OR?: Maybe<
    | QuestionnairesSubscriptionWhereInput[]
    | QuestionnairesSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | QuestionnairesSubscriptionWhereInput[]
    | QuestionnairesSubscriptionWhereInput
  >;
}

export interface ScheduledTaskSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ScheduledTaskWhereInput>;
  AND?: Maybe<
    ScheduledTaskSubscriptionWhereInput[] | ScheduledTaskSubscriptionWhereInput
  >;
  OR?: Maybe<
    ScheduledTaskSubscriptionWhereInput[] | ScheduledTaskSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ScheduledTaskSubscriptionWhereInput[] | ScheduledTaskSubscriptionWhereInput
  >;
}

export interface SensorDataSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SensorDataWhereInput>;
  AND?: Maybe<
    SensorDataSubscriptionWhereInput[] | SensorDataSubscriptionWhereInput
  >;
  OR?: Maybe<
    SensorDataSubscriptionWhereInput[] | SensorDataSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SensorDataSubscriptionWhereInput[] | SensorDataSubscriptionWhereInput
  >;
}

export interface TimeSpanSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TimeSpanWhereInput>;
  AND?: Maybe<
    TimeSpanSubscriptionWhereInput[] | TimeSpanSubscriptionWhereInput
  >;
  OR?: Maybe<TimeSpanSubscriptionWhereInput[] | TimeSpanSubscriptionWhereInput>;
  NOT?: Maybe<
    TimeSpanSubscriptionWhereInput[] | TimeSpanSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface UserSettingsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserSettingsWhereInput>;
  AND?: Maybe<
    UserSettingsSubscriptionWhereInput[] | UserSettingsSubscriptionWhereInput
  >;
  OR?: Maybe<
    UserSettingsSubscriptionWhereInput[] | UserSettingsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    UserSettingsSubscriptionWhereInput[] | UserSettingsSubscriptionWhereInput
  >;
}

export interface VotingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VotingWhereInput>;
  AND?: Maybe<VotingSubscriptionWhereInput[] | VotingSubscriptionWhereInput>;
  OR?: Maybe<VotingSubscriptionWhereInput[] | VotingSubscriptionWhereInput>;
  NOT?: Maybe<VotingSubscriptionWhereInput[] | VotingSubscriptionWhereInput>;
}

export interface WebPushNotificationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WebPushNotificationWhereInput>;
  AND?: Maybe<
    | WebPushNotificationSubscriptionWhereInput[]
    | WebPushNotificationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | WebPushNotificationSubscriptionWhereInput[]
    | WebPushNotificationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | WebPushNotificationSubscriptionWhereInput[]
    | WebPushNotificationSubscriptionWhereInput
  >;
}

export interface WebPushSettingsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WebPushSettingsWhereInput>;
  AND?: Maybe<
    | WebPushSettingsSubscriptionWhereInput[]
    | WebPushSettingsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | WebPushSettingsSubscriptionWhereInput[]
    | WebPushSettingsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | WebPushSettingsSubscriptionWhereInput[]
    | WebPushSettingsSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Activity {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  key: String;
  titel?: String;
  description?: String;
  grade?: ActivityGrade;
  icon?: String;
  tags: String[];
  isCustom?: Boolean;
  color?: String;
}

export interface ActivityPromise extends Promise<Activity>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  key: () => Promise<String>;
  titel: () => Promise<String>;
  description: () => Promise<String>;
  grade: () => Promise<ActivityGrade>;
  icon: () => Promise<String>;
  tags: () => Promise<String[]>;
  isCustom: () => Promise<Boolean>;
  color: () => Promise<String>;
}

export interface ActivitySubscription
  extends Promise<AsyncIterator<Activity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  key: () => Promise<AsyncIterator<String>>;
  titel: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  grade: () => Promise<AsyncIterator<ActivityGrade>>;
  icon: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
  isCustom: () => Promise<AsyncIterator<Boolean>>;
  color: () => Promise<AsyncIterator<String>>;
}

export interface ActivityNullablePromise
  extends Promise<Activity | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  key: () => Promise<String>;
  titel: () => Promise<String>;
  description: () => Promise<String>;
  grade: () => Promise<ActivityGrade>;
  icon: () => Promise<String>;
  tags: () => Promise<String[]>;
  isCustom: () => Promise<Boolean>;
  color: () => Promise<String>;
}

export interface ActivityConnection {
  pageInfo: PageInfo;
  edges: ActivityEdge[];
}

export interface ActivityConnectionPromise
  extends Promise<ActivityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActivityEdge>>() => T;
  aggregate: <T = AggregateActivityPromise>() => T;
}

export interface ActivityConnectionSubscription
  extends Promise<AsyncIterator<ActivityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ActivityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateActivitySubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ActivityEdge {
  node: Activity;
  cursor: String;
}

export interface ActivityEdgePromise
  extends Promise<ActivityEdge>,
    Fragmentable {
  node: <T = ActivityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActivityEdgeSubscription
  extends Promise<AsyncIterator<ActivityEdge>>,
    Fragmentable {
  node: <T = ActivitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateActivity {
  count: Int;
}

export interface AggregateActivityPromise
  extends Promise<AggregateActivity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActivitySubscription
  extends Promise<AsyncIterator<AggregateActivity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Award {
  id: ID_Output;
  status?: AwardVT;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface AwardPromise extends Promise<Award>, Fragmentable {
  id: () => Promise<ID_Output>;
  challengeID: <T = ChallengePromise>() => T;
  contributionID: <T = ContributionPromise>() => T;
  votingID: <T = VotingPromise>() => T;
  createdBy: <T = UserPromise>() => T;
  status: () => Promise<AwardVT>;
  winner: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AwardSubscription
  extends Promise<AsyncIterator<Award>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  challengeID: <T = ChallengeSubscription>() => T;
  contributionID: <T = ContributionSubscription>() => T;
  votingID: <T = VotingSubscription>() => T;
  createdBy: <T = UserSubscription>() => T;
  status: () => Promise<AsyncIterator<AwardVT>>;
  winner: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AwardNullablePromise
  extends Promise<Award | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  challengeID: <T = ChallengePromise>() => T;
  contributionID: <T = ContributionPromise>() => T;
  votingID: <T = VotingPromise>() => T;
  createdBy: <T = UserPromise>() => T;
  status: () => Promise<AwardVT>;
  winner: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Challenge {
  id: ID_Output;
  title: String;
  description: String;
  image: String;
  premium?: String;
  timeEnd?: DateTimeOutput;
  emailSend?: String;
  status?: StatusChallegen;
  initiator: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface ChallengePromise extends Promise<Challenge>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  premium: () => Promise<String>;
  timeEnd: () => Promise<DateTimeOutput>;
  emailSend: () => Promise<String>;
  jury: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  group: <T = FragmentableArray<Group>>(args?: {
    where?: GroupWhereInput;
    orderBy?: GroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  category: <T = FragmentableArray<Category>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<StatusChallegen>;
  initiator: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdBy: <T = UserPromise>() => T;
}

export interface ChallengeSubscription
  extends Promise<AsyncIterator<Challenge>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  premium: () => Promise<AsyncIterator<String>>;
  timeEnd: () => Promise<AsyncIterator<DateTimeOutput>>;
  emailSend: () => Promise<AsyncIterator<String>>;
  jury: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  group: <T = Promise<AsyncIterator<GroupSubscription>>>(args?: {
    where?: GroupWhereInput;
    orderBy?: GroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  category: <T = Promise<AsyncIterator<CategorySubscription>>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<AsyncIterator<StatusChallegen>>;
  initiator: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdBy: <T = UserSubscription>() => T;
}

export interface ChallengeNullablePromise
  extends Promise<Challenge | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  premium: () => Promise<String>;
  timeEnd: () => Promise<DateTimeOutput>;
  emailSend: () => Promise<String>;
  jury: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  group: <T = FragmentableArray<Group>>(args?: {
    where?: GroupWhereInput;
    orderBy?: GroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  category: <T = FragmentableArray<Category>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<StatusChallegen>;
  initiator: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdBy: <T = UserPromise>() => T;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  username: String;
  password?: String;
  role: UserRole;
  lastActive?: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<UserRole>;
  settings: <T = UserSettingsPromise>() => T;
  notifications: <T = FragmentableArray<WebPushNotification>>(args?: {
    where?: WebPushNotificationWhereInput;
    orderBy?: WebPushNotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  patient: <T = PatientPromise>() => T;
  lastActive: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRole>>;
  settings: <T = UserSettingsSubscription>() => T;
  notifications: <
    T = Promise<AsyncIterator<WebPushNotificationSubscription>>
  >(args?: {
    where?: WebPushNotificationWhereInput;
    orderBy?: WebPushNotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  patient: <T = PatientSubscription>() => T;
  lastActive: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<UserRole>;
  settings: <T = UserSettingsPromise>() => T;
  notifications: <T = FragmentableArray<WebPushNotification>>(args?: {
    where?: WebPushNotificationWhereInput;
    orderBy?: WebPushNotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  patient: <T = PatientPromise>() => T;
  lastActive: () => Promise<DateTimeOutput>;
}

export interface UserSettings {
  id: ID_Output;
  themeName?: String;
}

export interface UserSettingsPromise
  extends Promise<UserSettings>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  themeName: () => Promise<String>;
}

export interface UserSettingsSubscription
  extends Promise<AsyncIterator<UserSettings>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  themeName: () => Promise<AsyncIterator<String>>;
}

export interface UserSettingsNullablePromise
  extends Promise<UserSettings | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  themeName: () => Promise<String>;
}

export interface WebPushNotification {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  notificationInformation: Json;
}

export interface WebPushNotificationPromise
  extends Promise<WebPushNotification>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  notificationInformation: () => Promise<Json>;
}

export interface WebPushNotificationSubscription
  extends Promise<AsyncIterator<WebPushNotification>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  notificationInformation: () => Promise<AsyncIterator<Json>>;
}

export interface WebPushNotificationNullablePromise
  extends Promise<WebPushNotification | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  notificationInformation: () => Promise<Json>;
}

export interface Patient {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  verificationCode: String;
  verified?: Boolean;
  online?: Boolean;
  activeMinutesPerWeek?: Int;
}

export interface PatientPromise extends Promise<Patient>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  verificationCode: () => Promise<String>;
  verified: () => Promise<Boolean>;
  profile: <T = PatientProfileInfoPromise>() => T;
  buddy: <T = BuddyPromise>() => T;
  quests: <T = QuestionnairesPromise>() => T;
  online: () => Promise<Boolean>;
  activities: <T = FragmentableArray<Activity>>(args?: {
    where?: ActivityWhereInput;
    orderBy?: ActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  favoriteActivities: <T = FragmentableArray<FavoriteActivity>>(args?: {
    where?: FavoriteActivityWhereInput;
    orderBy?: FavoriteActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  calendarEntries: <T = FragmentableArray<CalendarEntry>>(args?: {
    where?: CalendarEntryWhereInput;
    orderBy?: CalendarEntryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  activeMinutesPerWeek: () => Promise<Int>;
  user: <T = UserPromise>() => T;
}

export interface PatientSubscription
  extends Promise<AsyncIterator<Patient>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  verificationCode: () => Promise<AsyncIterator<String>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  profile: <T = PatientProfileInfoSubscription>() => T;
  buddy: <T = BuddySubscription>() => T;
  quests: <T = QuestionnairesSubscription>() => T;
  online: () => Promise<AsyncIterator<Boolean>>;
  activities: <T = Promise<AsyncIterator<ActivitySubscription>>>(args?: {
    where?: ActivityWhereInput;
    orderBy?: ActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  favoriteActivities: <
    T = Promise<AsyncIterator<FavoriteActivitySubscription>>
  >(args?: {
    where?: FavoriteActivityWhereInput;
    orderBy?: FavoriteActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  calendarEntries: <
    T = Promise<AsyncIterator<CalendarEntrySubscription>>
  >(args?: {
    where?: CalendarEntryWhereInput;
    orderBy?: CalendarEntryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  activeMinutesPerWeek: () => Promise<AsyncIterator<Int>>;
  user: <T = UserSubscription>() => T;
}

export interface PatientNullablePromise
  extends Promise<Patient | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  verificationCode: () => Promise<String>;
  verified: () => Promise<Boolean>;
  profile: <T = PatientProfileInfoPromise>() => T;
  buddy: <T = BuddyPromise>() => T;
  quests: <T = QuestionnairesPromise>() => T;
  online: () => Promise<Boolean>;
  activities: <T = FragmentableArray<Activity>>(args?: {
    where?: ActivityWhereInput;
    orderBy?: ActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  favoriteActivities: <T = FragmentableArray<FavoriteActivity>>(args?: {
    where?: FavoriteActivityWhereInput;
    orderBy?: FavoriteActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  calendarEntries: <T = FragmentableArray<CalendarEntry>>(args?: {
    where?: CalendarEntryWhereInput;
    orderBy?: CalendarEntryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  activeMinutesPerWeek: () => Promise<Int>;
  user: <T = UserPromise>() => T;
}

export interface PatientProfileInfo {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  birthday?: DateTimeOutput;
  gender?: Gender;
  sameGender?: Boolean;
  hideGender?: Boolean;
  meetingDesired?: Boolean;
  avatar: String;
}

export interface PatientProfileInfoPromise
  extends Promise<PatientProfileInfo>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  birthday: () => Promise<DateTimeOutput>;
  gender: () => Promise<Gender>;
  sameGender: () => Promise<Boolean>;
  hideGender: () => Promise<Boolean>;
  meetingDesired: () => Promise<Boolean>;
  avatar: () => Promise<String>;
  profileActivities: <T = FragmentableArray<ProfileActivity>>(args?: {
    where?: ProfileActivityWhereInput;
    orderBy?: ProfileActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PatientProfileInfoSubscription
  extends Promise<AsyncIterator<PatientProfileInfo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  sameGender: () => Promise<AsyncIterator<Boolean>>;
  hideGender: () => Promise<AsyncIterator<Boolean>>;
  meetingDesired: () => Promise<AsyncIterator<Boolean>>;
  avatar: () => Promise<AsyncIterator<String>>;
  profileActivities: <
    T = Promise<AsyncIterator<ProfileActivitySubscription>>
  >(args?: {
    where?: ProfileActivityWhereInput;
    orderBy?: ProfileActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PatientProfileInfoNullablePromise
  extends Promise<PatientProfileInfo | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  birthday: () => Promise<DateTimeOutput>;
  gender: () => Promise<Gender>;
  sameGender: () => Promise<Boolean>;
  hideGender: () => Promise<Boolean>;
  meetingDesired: () => Promise<Boolean>;
  avatar: () => Promise<String>;
  profileActivities: <T = FragmentableArray<ProfileActivity>>(args?: {
    where?: ProfileActivityWhereInput;
    orderBy?: ProfileActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProfileActivity {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  key: String;
  icon: String;
  titel: String;
}

export interface ProfileActivityPromise
  extends Promise<ProfileActivity>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  key: () => Promise<String>;
  icon: () => Promise<String>;
  titel: () => Promise<String>;
}

export interface ProfileActivitySubscription
  extends Promise<AsyncIterator<ProfileActivity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  key: () => Promise<AsyncIterator<String>>;
  icon: () => Promise<AsyncIterator<String>>;
  titel: () => Promise<AsyncIterator<String>>;
}

export interface ProfileActivityNullablePromise
  extends Promise<ProfileActivity | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  key: () => Promise<String>;
  icon: () => Promise<String>;
  titel: () => Promise<String>;
}

export interface Buddy {
  id: ID_Output;
}

export interface BuddyPromise extends Promise<Buddy>, Fragmentable {
  id: () => Promise<ID_Output>;
  patient: <T = PatientPromise>() => T;
  chat: <T = ChatPromise>() => T;
}

export interface BuddySubscription
  extends Promise<AsyncIterator<Buddy>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  patient: <T = PatientSubscription>() => T;
  chat: <T = ChatSubscription>() => T;
}

export interface BuddyNullablePromise
  extends Promise<Buddy | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  patient: <T = PatientPromise>() => T;
  chat: <T = ChatPromise>() => T;
}

export interface Chat {
  id: ID_Output;
}

export interface ChatPromise extends Promise<Chat>, Fragmentable {
  id: () => Promise<ID_Output>;
  messages: <T = FragmentableArray<ChatMessage>>(args?: {
    where?: ChatMessageWhereInput;
    orderBy?: ChatMessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bot: <T = BotPromise>() => T;
}

export interface ChatSubscription
  extends Promise<AsyncIterator<Chat>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  messages: <T = Promise<AsyncIterator<ChatMessageSubscription>>>(args?: {
    where?: ChatMessageWhereInput;
    orderBy?: ChatMessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bot: <T = BotSubscription>() => T;
}

export interface ChatNullablePromise
  extends Promise<Chat | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  messages: <T = FragmentableArray<ChatMessage>>(args?: {
    where?: ChatMessageWhereInput;
    orderBy?: ChatMessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bot: <T = BotPromise>() => T;
}

export interface ChatMessage {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  text?: String;
}

export interface ChatMessagePromise extends Promise<ChatMessage>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  chat: <T = ChatPromise>() => T;
  text: () => Promise<String>;
  author: <T = UserPromise>() => T;
  authorBot: <T = BotPromise>() => T;
  attachment: <T = ChatMessageAttachmentPromise>() => T;
}

export interface ChatMessageSubscription
  extends Promise<AsyncIterator<ChatMessage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  chat: <T = ChatSubscription>() => T;
  text: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
  authorBot: <T = BotSubscription>() => T;
  attachment: <T = ChatMessageAttachmentSubscription>() => T;
}

export interface ChatMessageNullablePromise
  extends Promise<ChatMessage | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  chat: <T = ChatPromise>() => T;
  text: () => Promise<String>;
  author: <T = UserPromise>() => T;
  authorBot: <T = BotPromise>() => T;
  attachment: <T = ChatMessageAttachmentPromise>() => T;
}

export interface Bot {
  id: ID_Output;
  name?: String;
}

export interface BotPromise extends Promise<Bot>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  chat: <T = ChatPromise>() => T;
}

export interface BotSubscription
  extends Promise<AsyncIterator<Bot>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  chat: <T = ChatSubscription>() => T;
}

export interface BotNullablePromise extends Promise<Bot | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  chat: <T = ChatPromise>() => T;
}

export interface ChatMessageAttachment {
  id: ID_Output;
  originalCalendarEntryId?: ID_Output;
  ownerId?: ID_Output;
}

export interface ChatMessageAttachmentPromise
  extends Promise<ChatMessageAttachment>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  calendarEntry: <T = CalendarEntryPromise>() => T;
  originalCalendarEntryId: () => Promise<ID_Output>;
  ownerId: () => Promise<ID_Output>;
  chatMessage: <T = ChatMessagePromise>() => T;
}

export interface ChatMessageAttachmentSubscription
  extends Promise<AsyncIterator<ChatMessageAttachment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  calendarEntry: <T = CalendarEntrySubscription>() => T;
  originalCalendarEntryId: () => Promise<AsyncIterator<ID_Output>>;
  ownerId: () => Promise<AsyncIterator<ID_Output>>;
  chatMessage: <T = ChatMessageSubscription>() => T;
}

export interface ChatMessageAttachmentNullablePromise
  extends Promise<ChatMessageAttachment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  calendarEntry: <T = CalendarEntryPromise>() => T;
  originalCalendarEntryId: () => Promise<ID_Output>;
  ownerId: () => Promise<ID_Output>;
  chatMessage: <T = ChatMessagePromise>() => T;
}

export interface CalendarEntry {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
  isDone?: Boolean;
  isRunning?: Boolean;
  trackingRequested?: Boolean;
}

export interface CalendarEntryPromise
  extends Promise<CalendarEntry>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  activity: <T = ActivityPromise>() => T;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  isDone: () => Promise<Boolean>;
  isRunning: () => Promise<Boolean>;
  trackingRequested: () => Promise<Boolean>;
  patient: <T = PatientPromise>() => T;
  sensorData: <T = FragmentableArray<SensorData>>(args?: {
    where?: SensorDataWhereInput;
    orderBy?: SensorDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CalendarEntrySubscription
  extends Promise<AsyncIterator<CalendarEntry>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  activity: <T = ActivitySubscription>() => T;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  isDone: () => Promise<AsyncIterator<Boolean>>;
  isRunning: () => Promise<AsyncIterator<Boolean>>;
  trackingRequested: () => Promise<AsyncIterator<Boolean>>;
  patient: <T = PatientSubscription>() => T;
  sensorData: <T = Promise<AsyncIterator<SensorDataSubscription>>>(args?: {
    where?: SensorDataWhereInput;
    orderBy?: SensorDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CalendarEntryNullablePromise
  extends Promise<CalendarEntry | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  activity: <T = ActivityPromise>() => T;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  isDone: () => Promise<Boolean>;
  isRunning: () => Promise<Boolean>;
  trackingRequested: () => Promise<Boolean>;
  patient: <T = PatientPromise>() => T;
  sensorData: <T = FragmentableArray<SensorData>>(args?: {
    where?: SensorDataWhereInput;
    orderBy?: SensorDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SensorData {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  type: String;
  x?: Float;
  y?: Float;
  z?: Float;
  alpha?: Float;
  beta?: Float;
  gamma?: Float;
}

export interface SensorDataPromise extends Promise<SensorData>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<String>;
  x: () => Promise<Float>;
  y: () => Promise<Float>;
  z: () => Promise<Float>;
  alpha: () => Promise<Float>;
  beta: () => Promise<Float>;
  gamma: () => Promise<Float>;
}

export interface SensorDataSubscription
  extends Promise<AsyncIterator<SensorData>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<String>>;
  x: () => Promise<AsyncIterator<Float>>;
  y: () => Promise<AsyncIterator<Float>>;
  z: () => Promise<AsyncIterator<Float>>;
  alpha: () => Promise<AsyncIterator<Float>>;
  beta: () => Promise<AsyncIterator<Float>>;
  gamma: () => Promise<AsyncIterator<Float>>;
}

export interface SensorDataNullablePromise
  extends Promise<SensorData | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<String>;
  x: () => Promise<Float>;
  y: () => Promise<Float>;
  z: () => Promise<Float>;
  alpha: () => Promise<Float>;
  beta: () => Promise<Float>;
  gamma: () => Promise<Float>;
}

export interface Questionnaires {
  id: ID_Output;
}

export interface QuestionnairesPromise
  extends Promise<Questionnaires>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  phq9s: <T = FragmentableArray<Phq9>>(args?: {
    where?: Phq9WhereInput;
    orderBy?: Phq9OrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  ipaqs: <T = FragmentableArray<Ipaq>>(args?: {
    where?: IpaqWhereInput;
    orderBy?: IpaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  patient: <T = PatientPromise>() => T;
}

export interface QuestionnairesSubscription
  extends Promise<AsyncIterator<Questionnaires>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  phq9s: <T = Promise<AsyncIterator<Phq9Subscription>>>(args?: {
    where?: Phq9WhereInput;
    orderBy?: Phq9OrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  ipaqs: <T = Promise<AsyncIterator<IpaqSubscription>>>(args?: {
    where?: IpaqWhereInput;
    orderBy?: IpaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  patient: <T = PatientSubscription>() => T;
}

export interface QuestionnairesNullablePromise
  extends Promise<Questionnaires | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  phq9s: <T = FragmentableArray<Phq9>>(args?: {
    where?: Phq9WhereInput;
    orderBy?: Phq9OrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  ipaqs: <T = FragmentableArray<Ipaq>>(args?: {
    where?: IpaqWhereInput;
    orderBy?: IpaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  patient: <T = PatientPromise>() => T;
}

export interface Phq9 {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  answers: Int[];
  score?: Int;
  isComplete?: Boolean;
  expiryDate?: DateTimeOutput;
}

export interface Phq9Promise extends Promise<Phq9>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  answers: () => Promise<Int[]>;
  score: () => Promise<Int>;
  isComplete: () => Promise<Boolean>;
  expiryDate: () => Promise<DateTimeOutput>;
  quests: <T = QuestionnairesPromise>() => T;
}

export interface Phq9Subscription
  extends Promise<AsyncIterator<Phq9>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  answers: () => Promise<AsyncIterator<Int[]>>;
  score: () => Promise<AsyncIterator<Int>>;
  isComplete: () => Promise<AsyncIterator<Boolean>>;
  expiryDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  quests: <T = QuestionnairesSubscription>() => T;
}

export interface Phq9NullablePromise
  extends Promise<Phq9 | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  answers: () => Promise<Int[]>;
  score: () => Promise<Int>;
  isComplete: () => Promise<Boolean>;
  expiryDate: () => Promise<DateTimeOutput>;
  quests: <T = QuestionnairesPromise>() => T;
}

export interface Ipaq {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  score?: Float;
  expiryDate?: DateTimeOutput;
  isComplete?: Boolean;
}

export interface IpaqPromise extends Promise<Ipaq>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  answers: <T = FragmentableArray<IpaqAnswers>>(args?: {
    where?: IpaqAnswersWhereInput;
    orderBy?: IpaqAnswersOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  score: () => Promise<Float>;
  expiryDate: () => Promise<DateTimeOutput>;
  isComplete: () => Promise<Boolean>;
  quests: <T = QuestionnairesPromise>() => T;
}

export interface IpaqSubscription
  extends Promise<AsyncIterator<Ipaq>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  answers: <T = Promise<AsyncIterator<IpaqAnswersSubscription>>>(args?: {
    where?: IpaqAnswersWhereInput;
    orderBy?: IpaqAnswersOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  score: () => Promise<AsyncIterator<Float>>;
  expiryDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  isComplete: () => Promise<AsyncIterator<Boolean>>;
  quests: <T = QuestionnairesSubscription>() => T;
}

export interface IpaqNullablePromise
  extends Promise<Ipaq | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  answers: <T = FragmentableArray<IpaqAnswers>>(args?: {
    where?: IpaqAnswersWhereInput;
    orderBy?: IpaqAnswersOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  score: () => Promise<Float>;
  expiryDate: () => Promise<DateTimeOutput>;
  isComplete: () => Promise<Boolean>;
  quests: <T = QuestionnairesPromise>() => T;
}

export interface IpaqAnswers {
  id: ID_Output;
  numDays?: Int;
  numHours?: Int;
  numMinutes?: Int;
}

export interface IpaqAnswersPromise extends Promise<IpaqAnswers>, Fragmentable {
  id: () => Promise<ID_Output>;
  numDays: () => Promise<Int>;
  numHours: () => Promise<Int>;
  numMinutes: () => Promise<Int>;
  quest: <T = IpaqPromise>() => T;
}

export interface IpaqAnswersSubscription
  extends Promise<AsyncIterator<IpaqAnswers>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  numDays: () => Promise<AsyncIterator<Int>>;
  numHours: () => Promise<AsyncIterator<Int>>;
  numMinutes: () => Promise<AsyncIterator<Int>>;
  quest: <T = IpaqSubscription>() => T;
}

export interface IpaqAnswersNullablePromise
  extends Promise<IpaqAnswers | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  numDays: () => Promise<Int>;
  numHours: () => Promise<Int>;
  numMinutes: () => Promise<Int>;
  quest: <T = IpaqPromise>() => T;
}

export interface FavoriteActivity {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  activityKey: String;
}

export interface FavoriteActivityPromise
  extends Promise<FavoriteActivity>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  activityKey: () => Promise<String>;
}

export interface FavoriteActivitySubscription
  extends Promise<AsyncIterator<FavoriteActivity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  activityKey: () => Promise<AsyncIterator<String>>;
}

export interface FavoriteActivityNullablePromise
  extends Promise<FavoriteActivity | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  activityKey: () => Promise<String>;
}

export interface Group {
  id: ID_Output;
  title: String;
  description: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface GroupPromise extends Promise<Group>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdBy: <T = UserPromise>() => T;
  challenge: <T = FragmentableArray<Challenge>>(args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GroupSubscription
  extends Promise<AsyncIterator<Group>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdBy: <T = UserSubscription>() => T;
  challenge: <T = Promise<AsyncIterator<ChallengeSubscription>>>(args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GroupNullablePromise
  extends Promise<Group | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdBy: <T = UserPromise>() => T;
  challenge: <T = FragmentableArray<Challenge>>(args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Category {
  id: ID_Output;
  title: String;
  description: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  challenge: <T = FragmentableArray<Challenge>>(args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  challenge: <T = Promise<AsyncIterator<ChallengeSubscription>>>(args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CategoryNullablePromise
  extends Promise<Category | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  challenge: <T = FragmentableArray<Challenge>>(args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Contribution {
  id: ID_Output;
  title: String;
  description?: String;
  image?: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface ContributionPromise
  extends Promise<Contribution>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  challengeID: <T = ChallengePromise>() => T;
  title: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdBy: <T = UserPromise>() => T;
}

export interface ContributionSubscription
  extends Promise<AsyncIterator<Contribution>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  challengeID: <T = ChallengeSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdBy: <T = UserSubscription>() => T;
}

export interface ContributionNullablePromise
  extends Promise<Contribution | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  challengeID: <T = ChallengePromise>() => T;
  title: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdBy: <T = UserPromise>() => T;
}

export interface Voting {
  id: ID_Output;
  title: String;
  description?: String;
  votedPoint?: Int;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface VotingPromise extends Promise<Voting>, Fragmentable {
  id: () => Promise<ID_Output>;
  challengeID: <T = ChallengePromise>() => T;
  contributionID: <T = ContributionPromise>() => T;
  title: () => Promise<String>;
  description: () => Promise<String>;
  votedPoint: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdBy: <T = UserPromise>() => T;
}

export interface VotingSubscription
  extends Promise<AsyncIterator<Voting>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  challengeID: <T = ChallengeSubscription>() => T;
  contributionID: <T = ContributionSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  votedPoint: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdBy: <T = UserSubscription>() => T;
}

export interface VotingNullablePromise
  extends Promise<Voting | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  challengeID: <T = ChallengePromise>() => T;
  contributionID: <T = ContributionPromise>() => T;
  title: () => Promise<String>;
  description: () => Promise<String>;
  votedPoint: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdBy: <T = UserPromise>() => T;
}

export interface AwardConnection {
  pageInfo: PageInfo;
  edges: AwardEdge[];
}

export interface AwardConnectionPromise
  extends Promise<AwardConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AwardEdge>>() => T;
  aggregate: <T = AggregateAwardPromise>() => T;
}

export interface AwardConnectionSubscription
  extends Promise<AsyncIterator<AwardConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AwardEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAwardSubscription>() => T;
}

export interface AwardEdge {
  node: Award;
  cursor: String;
}

export interface AwardEdgePromise extends Promise<AwardEdge>, Fragmentable {
  node: <T = AwardPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AwardEdgeSubscription
  extends Promise<AsyncIterator<AwardEdge>>,
    Fragmentable {
  node: <T = AwardSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAward {
  count: Int;
}

export interface AggregateAwardPromise
  extends Promise<AggregateAward>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAwardSubscription
  extends Promise<AsyncIterator<AggregateAward>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BotConnection {
  pageInfo: PageInfo;
  edges: BotEdge[];
}

export interface BotConnectionPromise
  extends Promise<BotConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BotEdge>>() => T;
  aggregate: <T = AggregateBotPromise>() => T;
}

export interface BotConnectionSubscription
  extends Promise<AsyncIterator<BotConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BotEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBotSubscription>() => T;
}

export interface BotEdge {
  node: Bot;
  cursor: String;
}

export interface BotEdgePromise extends Promise<BotEdge>, Fragmentable {
  node: <T = BotPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BotEdgeSubscription
  extends Promise<AsyncIterator<BotEdge>>,
    Fragmentable {
  node: <T = BotSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBot {
  count: Int;
}

export interface AggregateBotPromise
  extends Promise<AggregateBot>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBotSubscription
  extends Promise<AsyncIterator<AggregateBot>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BotSettings {
  id: ID_Output;
  updatedAt?: DateTimeOutput;
  botFirstGreetingText?: String;
  botAskCreateActivitiesMessage?: String;
  botActivityLessThanPlannedMessage?: String;
  botActivityLessThanPlannedWeekday?: Int;
  botAskStartChatMessage?: String;
}

export interface BotSettingsPromise extends Promise<BotSettings>, Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  botFirstGreetingText: () => Promise<String>;
  botFirstGreetingTextDelay: <T = TimeSpanPromise>() => T;
  botAskCreateActivitiesTime: <T = TimeSpanPromise>() => T;
  botAskCreateActivitiesMessage: () => Promise<String>;
  botActivityLessThanPlannedMessage: () => Promise<String>;
  botActivityLessThanPlannedWeekday: () => Promise<Int>;
  botAskStartChatIntervall: <T = TimeSpanPromise>() => T;
  botAskStartChatMessage: () => Promise<String>;
}

export interface BotSettingsSubscription
  extends Promise<AsyncIterator<BotSettings>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  botFirstGreetingText: () => Promise<AsyncIterator<String>>;
  botFirstGreetingTextDelay: <T = TimeSpanSubscription>() => T;
  botAskCreateActivitiesTime: <T = TimeSpanSubscription>() => T;
  botAskCreateActivitiesMessage: () => Promise<AsyncIterator<String>>;
  botActivityLessThanPlannedMessage: () => Promise<AsyncIterator<String>>;
  botActivityLessThanPlannedWeekday: () => Promise<AsyncIterator<Int>>;
  botAskStartChatIntervall: <T = TimeSpanSubscription>() => T;
  botAskStartChatMessage: () => Promise<AsyncIterator<String>>;
}

export interface BotSettingsNullablePromise
  extends Promise<BotSettings | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  botFirstGreetingText: () => Promise<String>;
  botFirstGreetingTextDelay: <T = TimeSpanPromise>() => T;
  botAskCreateActivitiesTime: <T = TimeSpanPromise>() => T;
  botAskCreateActivitiesMessage: () => Promise<String>;
  botActivityLessThanPlannedMessage: () => Promise<String>;
  botActivityLessThanPlannedWeekday: () => Promise<Int>;
  botAskStartChatIntervall: <T = TimeSpanPromise>() => T;
  botAskStartChatMessage: () => Promise<String>;
}

export interface TimeSpan {
  id: ID_Output;
  updatedAt?: DateTimeOutput;
  days: Int;
  hours: Int;
  minutes: Int;
  seconds: Int;
}

export interface TimeSpanPromise extends Promise<TimeSpan>, Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  days: () => Promise<Int>;
  hours: () => Promise<Int>;
  minutes: () => Promise<Int>;
  seconds: () => Promise<Int>;
}

export interface TimeSpanSubscription
  extends Promise<AsyncIterator<TimeSpan>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  days: () => Promise<AsyncIterator<Int>>;
  hours: () => Promise<AsyncIterator<Int>>;
  minutes: () => Promise<AsyncIterator<Int>>;
  seconds: () => Promise<AsyncIterator<Int>>;
}

export interface TimeSpanNullablePromise
  extends Promise<TimeSpan | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  days: () => Promise<Int>;
  hours: () => Promise<Int>;
  minutes: () => Promise<Int>;
  seconds: () => Promise<Int>;
}

export interface BotSettingsConnection {
  pageInfo: PageInfo;
  edges: BotSettingsEdge[];
}

export interface BotSettingsConnectionPromise
  extends Promise<BotSettingsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BotSettingsEdge>>() => T;
  aggregate: <T = AggregateBotSettingsPromise>() => T;
}

export interface BotSettingsConnectionSubscription
  extends Promise<AsyncIterator<BotSettingsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BotSettingsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBotSettingsSubscription>() => T;
}

export interface BotSettingsEdge {
  node: BotSettings;
  cursor: String;
}

export interface BotSettingsEdgePromise
  extends Promise<BotSettingsEdge>,
    Fragmentable {
  node: <T = BotSettingsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BotSettingsEdgeSubscription
  extends Promise<AsyncIterator<BotSettingsEdge>>,
    Fragmentable {
  node: <T = BotSettingsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBotSettings {
  count: Int;
}

export interface AggregateBotSettingsPromise
  extends Promise<AggregateBotSettings>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBotSettingsSubscription
  extends Promise<AsyncIterator<AggregateBotSettings>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BuddyConnection {
  pageInfo: PageInfo;
  edges: BuddyEdge[];
}

export interface BuddyConnectionPromise
  extends Promise<BuddyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BuddyEdge>>() => T;
  aggregate: <T = AggregateBuddyPromise>() => T;
}

export interface BuddyConnectionSubscription
  extends Promise<AsyncIterator<BuddyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BuddyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBuddySubscription>() => T;
}

export interface BuddyEdge {
  node: Buddy;
  cursor: String;
}

export interface BuddyEdgePromise extends Promise<BuddyEdge>, Fragmentable {
  node: <T = BuddyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BuddyEdgeSubscription
  extends Promise<AsyncIterator<BuddyEdge>>,
    Fragmentable {
  node: <T = BuddySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBuddy {
  count: Int;
}

export interface AggregateBuddyPromise
  extends Promise<AggregateBuddy>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBuddySubscription
  extends Promise<AsyncIterator<AggregateBuddy>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BuddyRequest {
  id: ID_Output;
  createdAt: DateTimeOutput;
  state?: BuddyRequestState;
}

export interface BuddyRequestPromise
  extends Promise<BuddyRequest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  from: <T = PatientPromise>() => T;
  to: <T = PatientPromise>() => T;
  state: () => Promise<BuddyRequestState>;
}

export interface BuddyRequestSubscription
  extends Promise<AsyncIterator<BuddyRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  from: <T = PatientSubscription>() => T;
  to: <T = PatientSubscription>() => T;
  state: () => Promise<AsyncIterator<BuddyRequestState>>;
}

export interface BuddyRequestNullablePromise
  extends Promise<BuddyRequest | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  from: <T = PatientPromise>() => T;
  to: <T = PatientPromise>() => T;
  state: () => Promise<BuddyRequestState>;
}

export interface BuddyRequestConnection {
  pageInfo: PageInfo;
  edges: BuddyRequestEdge[];
}

export interface BuddyRequestConnectionPromise
  extends Promise<BuddyRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BuddyRequestEdge>>() => T;
  aggregate: <T = AggregateBuddyRequestPromise>() => T;
}

export interface BuddyRequestConnectionSubscription
  extends Promise<AsyncIterator<BuddyRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BuddyRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBuddyRequestSubscription>() => T;
}

export interface BuddyRequestEdge {
  node: BuddyRequest;
  cursor: String;
}

export interface BuddyRequestEdgePromise
  extends Promise<BuddyRequestEdge>,
    Fragmentable {
  node: <T = BuddyRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BuddyRequestEdgeSubscription
  extends Promise<AsyncIterator<BuddyRequestEdge>>,
    Fragmentable {
  node: <T = BuddyRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBuddyRequest {
  count: Int;
}

export interface AggregateBuddyRequestPromise
  extends Promise<AggregateBuddyRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBuddyRequestSubscription
  extends Promise<AsyncIterator<AggregateBuddyRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CalendarEntryConnection {
  pageInfo: PageInfo;
  edges: CalendarEntryEdge[];
}

export interface CalendarEntryConnectionPromise
  extends Promise<CalendarEntryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CalendarEntryEdge>>() => T;
  aggregate: <T = AggregateCalendarEntryPromise>() => T;
}

export interface CalendarEntryConnectionSubscription
  extends Promise<AsyncIterator<CalendarEntryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CalendarEntryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCalendarEntrySubscription>() => T;
}

export interface CalendarEntryEdge {
  node: CalendarEntry;
  cursor: String;
}

export interface CalendarEntryEdgePromise
  extends Promise<CalendarEntryEdge>,
    Fragmentable {
  node: <T = CalendarEntryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CalendarEntryEdgeSubscription
  extends Promise<AsyncIterator<CalendarEntryEdge>>,
    Fragmentable {
  node: <T = CalendarEntrySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCalendarEntry {
  count: Int;
}

export interface AggregateCalendarEntryPromise
  extends Promise<AggregateCalendarEntry>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCalendarEntrySubscription
  extends Promise<AsyncIterator<AggregateCalendarEntry>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChallengeConnection {
  pageInfo: PageInfo;
  edges: ChallengeEdge[];
}

export interface ChallengeConnectionPromise
  extends Promise<ChallengeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChallengeEdge>>() => T;
  aggregate: <T = AggregateChallengePromise>() => T;
}

export interface ChallengeConnectionSubscription
  extends Promise<AsyncIterator<ChallengeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChallengeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChallengeSubscription>() => T;
}

export interface ChallengeEdge {
  node: Challenge;
  cursor: String;
}

export interface ChallengeEdgePromise
  extends Promise<ChallengeEdge>,
    Fragmentable {
  node: <T = ChallengePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChallengeEdgeSubscription
  extends Promise<AsyncIterator<ChallengeEdge>>,
    Fragmentable {
  node: <T = ChallengeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChallenge {
  count: Int;
}

export interface AggregateChallengePromise
  extends Promise<AggregateChallenge>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChallengeSubscription
  extends Promise<AsyncIterator<AggregateChallenge>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChallengeCategory {
  id: ID_Output;
}

export interface ChallengeCategoryPromise
  extends Promise<ChallengeCategory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  challegeId: <T = ChallengePromise>() => T;
  categoryID: <T = GroupPromise>() => T;
}

export interface ChallengeCategorySubscription
  extends Promise<AsyncIterator<ChallengeCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  challegeId: <T = ChallengeSubscription>() => T;
  categoryID: <T = GroupSubscription>() => T;
}

export interface ChallengeCategoryNullablePromise
  extends Promise<ChallengeCategory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  challegeId: <T = ChallengePromise>() => T;
  categoryID: <T = GroupPromise>() => T;
}

export interface ChallengeCategoryConnection {
  pageInfo: PageInfo;
  edges: ChallengeCategoryEdge[];
}

export interface ChallengeCategoryConnectionPromise
  extends Promise<ChallengeCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChallengeCategoryEdge>>() => T;
  aggregate: <T = AggregateChallengeCategoryPromise>() => T;
}

export interface ChallengeCategoryConnectionSubscription
  extends Promise<AsyncIterator<ChallengeCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChallengeCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChallengeCategorySubscription>() => T;
}

export interface ChallengeCategoryEdge {
  node: ChallengeCategory;
  cursor: String;
}

export interface ChallengeCategoryEdgePromise
  extends Promise<ChallengeCategoryEdge>,
    Fragmentable {
  node: <T = ChallengeCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChallengeCategoryEdgeSubscription
  extends Promise<AsyncIterator<ChallengeCategoryEdge>>,
    Fragmentable {
  node: <T = ChallengeCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChallengeCategory {
  count: Int;
}

export interface AggregateChallengeCategoryPromise
  extends Promise<AggregateChallengeCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChallengeCategorySubscription
  extends Promise<AsyncIterator<AggregateChallengeCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChallengeGroup {
  id: ID_Output;
}

export interface ChallengeGroupPromise
  extends Promise<ChallengeGroup>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  challegeId: <T = ChallengePromise>() => T;
  groupID: <T = GroupPromise>() => T;
}

export interface ChallengeGroupSubscription
  extends Promise<AsyncIterator<ChallengeGroup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  challegeId: <T = ChallengeSubscription>() => T;
  groupID: <T = GroupSubscription>() => T;
}

export interface ChallengeGroupNullablePromise
  extends Promise<ChallengeGroup | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  challegeId: <T = ChallengePromise>() => T;
  groupID: <T = GroupPromise>() => T;
}

export interface ChallengeGroupConnection {
  pageInfo: PageInfo;
  edges: ChallengeGroupEdge[];
}

export interface ChallengeGroupConnectionPromise
  extends Promise<ChallengeGroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChallengeGroupEdge>>() => T;
  aggregate: <T = AggregateChallengeGroupPromise>() => T;
}

export interface ChallengeGroupConnectionSubscription
  extends Promise<AsyncIterator<ChallengeGroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChallengeGroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChallengeGroupSubscription>() => T;
}

export interface ChallengeGroupEdge {
  node: ChallengeGroup;
  cursor: String;
}

export interface ChallengeGroupEdgePromise
  extends Promise<ChallengeGroupEdge>,
    Fragmentable {
  node: <T = ChallengeGroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChallengeGroupEdgeSubscription
  extends Promise<AsyncIterator<ChallengeGroupEdge>>,
    Fragmentable {
  node: <T = ChallengeGroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChallengeGroup {
  count: Int;
}

export interface AggregateChallengeGroupPromise
  extends Promise<AggregateChallengeGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChallengeGroupSubscription
  extends Promise<AsyncIterator<AggregateChallengeGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChatConnection {
  pageInfo: PageInfo;
  edges: ChatEdge[];
}

export interface ChatConnectionPromise
  extends Promise<ChatConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChatEdge>>() => T;
  aggregate: <T = AggregateChatPromise>() => T;
}

export interface ChatConnectionSubscription
  extends Promise<AsyncIterator<ChatConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChatEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChatSubscription>() => T;
}

export interface ChatEdge {
  node: Chat;
  cursor: String;
}

export interface ChatEdgePromise extends Promise<ChatEdge>, Fragmentable {
  node: <T = ChatPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChatEdgeSubscription
  extends Promise<AsyncIterator<ChatEdge>>,
    Fragmentable {
  node: <T = ChatSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChat {
  count: Int;
}

export interface AggregateChatPromise
  extends Promise<AggregateChat>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChatSubscription
  extends Promise<AsyncIterator<AggregateChat>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChatMessageConnection {
  pageInfo: PageInfo;
  edges: ChatMessageEdge[];
}

export interface ChatMessageConnectionPromise
  extends Promise<ChatMessageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChatMessageEdge>>() => T;
  aggregate: <T = AggregateChatMessagePromise>() => T;
}

export interface ChatMessageConnectionSubscription
  extends Promise<AsyncIterator<ChatMessageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChatMessageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChatMessageSubscription>() => T;
}

export interface ChatMessageEdge {
  node: ChatMessage;
  cursor: String;
}

export interface ChatMessageEdgePromise
  extends Promise<ChatMessageEdge>,
    Fragmentable {
  node: <T = ChatMessagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChatMessageEdgeSubscription
  extends Promise<AsyncIterator<ChatMessageEdge>>,
    Fragmentable {
  node: <T = ChatMessageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChatMessage {
  count: Int;
}

export interface AggregateChatMessagePromise
  extends Promise<AggregateChatMessage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChatMessageSubscription
  extends Promise<AsyncIterator<AggregateChatMessage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChatMessageAttachmentConnection {
  pageInfo: PageInfo;
  edges: ChatMessageAttachmentEdge[];
}

export interface ChatMessageAttachmentConnectionPromise
  extends Promise<ChatMessageAttachmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChatMessageAttachmentEdge>>() => T;
  aggregate: <T = AggregateChatMessageAttachmentPromise>() => T;
}

export interface ChatMessageAttachmentConnectionSubscription
  extends Promise<AsyncIterator<ChatMessageAttachmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ChatMessageAttachmentEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateChatMessageAttachmentSubscription>() => T;
}

export interface ChatMessageAttachmentEdge {
  node: ChatMessageAttachment;
  cursor: String;
}

export interface ChatMessageAttachmentEdgePromise
  extends Promise<ChatMessageAttachmentEdge>,
    Fragmentable {
  node: <T = ChatMessageAttachmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChatMessageAttachmentEdgeSubscription
  extends Promise<AsyncIterator<ChatMessageAttachmentEdge>>,
    Fragmentable {
  node: <T = ChatMessageAttachmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChatMessageAttachment {
  count: Int;
}

export interface AggregateChatMessageAttachmentPromise
  extends Promise<AggregateChatMessageAttachment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChatMessageAttachmentSubscription
  extends Promise<AsyncIterator<AggregateChatMessageAttachment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContributionConnection {
  pageInfo: PageInfo;
  edges: ContributionEdge[];
}

export interface ContributionConnectionPromise
  extends Promise<ContributionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContributionEdge>>() => T;
  aggregate: <T = AggregateContributionPromise>() => T;
}

export interface ContributionConnectionSubscription
  extends Promise<AsyncIterator<ContributionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContributionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContributionSubscription>() => T;
}

export interface ContributionEdge {
  node: Contribution;
  cursor: String;
}

export interface ContributionEdgePromise
  extends Promise<ContributionEdge>,
    Fragmentable {
  node: <T = ContributionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContributionEdgeSubscription
  extends Promise<AsyncIterator<ContributionEdge>>,
    Fragmentable {
  node: <T = ContributionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContribution {
  count: Int;
}

export interface AggregateContributionPromise
  extends Promise<AggregateContribution>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContributionSubscription
  extends Promise<AsyncIterator<AggregateContribution>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FavoriteActivityConnection {
  pageInfo: PageInfo;
  edges: FavoriteActivityEdge[];
}

export interface FavoriteActivityConnectionPromise
  extends Promise<FavoriteActivityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FavoriteActivityEdge>>() => T;
  aggregate: <T = AggregateFavoriteActivityPromise>() => T;
}

export interface FavoriteActivityConnectionSubscription
  extends Promise<AsyncIterator<FavoriteActivityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FavoriteActivityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFavoriteActivitySubscription>() => T;
}

export interface FavoriteActivityEdge {
  node: FavoriteActivity;
  cursor: String;
}

export interface FavoriteActivityEdgePromise
  extends Promise<FavoriteActivityEdge>,
    Fragmentable {
  node: <T = FavoriteActivityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FavoriteActivityEdgeSubscription
  extends Promise<AsyncIterator<FavoriteActivityEdge>>,
    Fragmentable {
  node: <T = FavoriteActivitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFavoriteActivity {
  count: Int;
}

export interface AggregateFavoriteActivityPromise
  extends Promise<AggregateFavoriteActivity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFavoriteActivitySubscription
  extends Promise<AsyncIterator<AggregateFavoriteActivity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GlobalSettings {
  id: ID_Output;
  updatedAt?: DateTimeOutput;
  matchingPercentageCap?: Int;
  defaultActivityTimeMinutesPerWeek?: Int;
  minimumActivityTimeMinutes?: Int;
  maximumActivityTimeMinutes?: Int;
  ipaqGroupLowMax?: Int;
  ipaqGroupModerateMax?: Int;
  ipaqGroupHighMax?: Int;
  phqGroupLowMin?: Int;
  phqGroupLowMax?: Int;
}

export interface GlobalSettingsPromise
  extends Promise<GlobalSettings>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  matchingPercentageCap: () => Promise<Int>;
  matchingTimeout: <T = TimeSpanPromise>() => T;
  defaultActivityTimeMinutesPerWeek: () => Promise<Int>;
  minimumActivityTimeMinutes: () => Promise<Int>;
  maximumActivityTimeMinutes: () => Promise<Int>;
  ipaqGroupLowMax: () => Promise<Int>;
  ipaqGroupModerateMax: () => Promise<Int>;
  ipaqGroupHighMax: () => Promise<Int>;
  phqGroupLowMin: () => Promise<Int>;
  phqGroupLowMax: () => Promise<Int>;
  botSettings: <T = BotSettingsPromise>() => T;
  webPushSettings: <T = WebPushSettingsPromise>() => T;
}

export interface GlobalSettingsSubscription
  extends Promise<AsyncIterator<GlobalSettings>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  matchingPercentageCap: () => Promise<AsyncIterator<Int>>;
  matchingTimeout: <T = TimeSpanSubscription>() => T;
  defaultActivityTimeMinutesPerWeek: () => Promise<AsyncIterator<Int>>;
  minimumActivityTimeMinutes: () => Promise<AsyncIterator<Int>>;
  maximumActivityTimeMinutes: () => Promise<AsyncIterator<Int>>;
  ipaqGroupLowMax: () => Promise<AsyncIterator<Int>>;
  ipaqGroupModerateMax: () => Promise<AsyncIterator<Int>>;
  ipaqGroupHighMax: () => Promise<AsyncIterator<Int>>;
  phqGroupLowMin: () => Promise<AsyncIterator<Int>>;
  phqGroupLowMax: () => Promise<AsyncIterator<Int>>;
  botSettings: <T = BotSettingsSubscription>() => T;
  webPushSettings: <T = WebPushSettingsSubscription>() => T;
}

export interface GlobalSettingsNullablePromise
  extends Promise<GlobalSettings | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  matchingPercentageCap: () => Promise<Int>;
  matchingTimeout: <T = TimeSpanPromise>() => T;
  defaultActivityTimeMinutesPerWeek: () => Promise<Int>;
  minimumActivityTimeMinutes: () => Promise<Int>;
  maximumActivityTimeMinutes: () => Promise<Int>;
  ipaqGroupLowMax: () => Promise<Int>;
  ipaqGroupModerateMax: () => Promise<Int>;
  ipaqGroupHighMax: () => Promise<Int>;
  phqGroupLowMin: () => Promise<Int>;
  phqGroupLowMax: () => Promise<Int>;
  botSettings: <T = BotSettingsPromise>() => T;
  webPushSettings: <T = WebPushSettingsPromise>() => T;
}

export interface WebPushSettings {
  id: ID_Output;
  updatedAt?: DateTimeOutput;
  webPushIpaqReminderMessage?: String;
  webPushPhqReminderMessage?: String;
  webPushIncomingBuddyRequestMessage?: String;
  webPushIncomingRequestNoResponseMessage?: String;
  webPushIncomingRequestNotAnsweredMessage?: String;
  webPushNotEnoughActivitiesMessage?: String;
  webPushNotEnoughActivitiesWeekday?: Int;
  webPushNotEnoughActivitiesBuddyMessage?: String;
  webPushNotEnoughActivitiesBuddyWeekday?: Int;
  webPushToManyActivitiesMessage?: String;
  webPushToManyActivitiesWeekday?: Int;
  webPushToManyActivitiesBuddyMessage?: String;
  webPushActivityMissedBuddyMessage?: String;
}

export interface WebPushSettingsPromise
  extends Promise<WebPushSettings>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  webPushIpaqReminderIntervall: <T = TimeSpanPromise>() => T;
  webPushIpaqReminderIntervallFollowUp: <T = TimeSpanPromise>() => T;
  webPushIpaqReminderMessage: () => Promise<String>;
  webPushPhqReminderIntervall: <T = TimeSpanPromise>() => T;
  webPushPhqReminderIntervallFollowUp: <T = TimeSpanPromise>() => T;
  webPushPhqReminderMessage: () => Promise<String>;
  webPushIncomingBuddyRequestMessage: () => Promise<String>;
  webPushIncomingBuddyRequestDelay: <T = TimeSpanPromise>() => T;
  webPushIncomingRequestNoResponseMessage: () => Promise<String>;
  webPushIncomingRequestNoResponseIntervall: <T = TimeSpanPromise>() => T;
  webPushIncomingRequestNoResponseFollowupIntervall: <
    T = TimeSpanPromise
  >() => T;
  webPushIncomingRequestNotAnsweredMessage: () => Promise<String>;
  webPushIncomingRequestNotAnsweredIntervall: <T = TimeSpanPromise>() => T;
  webPushNotEnoughActivitiesMessage: () => Promise<String>;
  webPushNotEnoughActivitiesWeekday: () => Promise<Int>;
  webPushNotEnoughActivitiesBuddyMessage: () => Promise<String>;
  webPushNotEnoughActivitiesBuddyWeekday: () => Promise<Int>;
  webPushToManyActivitiesMessage: () => Promise<String>;
  webPushToManyActivitiesWeekday: () => Promise<Int>;
  webPushToManyActivitiesBuddyMessage: () => Promise<String>;
  webPushToManyActivitiesBuddyDelay: <T = TimeSpanPromise>() => T;
  webPushActivityMissedBuddyMessage: () => Promise<String>;
  webPushActivityMissedBuddyDelay: <T = TimeSpanPromise>() => T;
}

export interface WebPushSettingsSubscription
  extends Promise<AsyncIterator<WebPushSettings>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  webPushIpaqReminderIntervall: <T = TimeSpanSubscription>() => T;
  webPushIpaqReminderIntervallFollowUp: <T = TimeSpanSubscription>() => T;
  webPushIpaqReminderMessage: () => Promise<AsyncIterator<String>>;
  webPushPhqReminderIntervall: <T = TimeSpanSubscription>() => T;
  webPushPhqReminderIntervallFollowUp: <T = TimeSpanSubscription>() => T;
  webPushPhqReminderMessage: () => Promise<AsyncIterator<String>>;
  webPushIncomingBuddyRequestMessage: () => Promise<AsyncIterator<String>>;
  webPushIncomingBuddyRequestDelay: <T = TimeSpanSubscription>() => T;
  webPushIncomingRequestNoResponseMessage: () => Promise<AsyncIterator<String>>;
  webPushIncomingRequestNoResponseIntervall: <T = TimeSpanSubscription>() => T;
  webPushIncomingRequestNoResponseFollowupIntervall: <
    T = TimeSpanSubscription
  >() => T;
  webPushIncomingRequestNotAnsweredMessage: () => Promise<
    AsyncIterator<String>
  >;
  webPushIncomingRequestNotAnsweredIntervall: <T = TimeSpanSubscription>() => T;
  webPushNotEnoughActivitiesMessage: () => Promise<AsyncIterator<String>>;
  webPushNotEnoughActivitiesWeekday: () => Promise<AsyncIterator<Int>>;
  webPushNotEnoughActivitiesBuddyMessage: () => Promise<AsyncIterator<String>>;
  webPushNotEnoughActivitiesBuddyWeekday: () => Promise<AsyncIterator<Int>>;
  webPushToManyActivitiesMessage: () => Promise<AsyncIterator<String>>;
  webPushToManyActivitiesWeekday: () => Promise<AsyncIterator<Int>>;
  webPushToManyActivitiesBuddyMessage: () => Promise<AsyncIterator<String>>;
  webPushToManyActivitiesBuddyDelay: <T = TimeSpanSubscription>() => T;
  webPushActivityMissedBuddyMessage: () => Promise<AsyncIterator<String>>;
  webPushActivityMissedBuddyDelay: <T = TimeSpanSubscription>() => T;
}

export interface WebPushSettingsNullablePromise
  extends Promise<WebPushSettings | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  webPushIpaqReminderIntervall: <T = TimeSpanPromise>() => T;
  webPushIpaqReminderIntervallFollowUp: <T = TimeSpanPromise>() => T;
  webPushIpaqReminderMessage: () => Promise<String>;
  webPushPhqReminderIntervall: <T = TimeSpanPromise>() => T;
  webPushPhqReminderIntervallFollowUp: <T = TimeSpanPromise>() => T;
  webPushPhqReminderMessage: () => Promise<String>;
  webPushIncomingBuddyRequestMessage: () => Promise<String>;
  webPushIncomingBuddyRequestDelay: <T = TimeSpanPromise>() => T;
  webPushIncomingRequestNoResponseMessage: () => Promise<String>;
  webPushIncomingRequestNoResponseIntervall: <T = TimeSpanPromise>() => T;
  webPushIncomingRequestNoResponseFollowupIntervall: <
    T = TimeSpanPromise
  >() => T;
  webPushIncomingRequestNotAnsweredMessage: () => Promise<String>;
  webPushIncomingRequestNotAnsweredIntervall: <T = TimeSpanPromise>() => T;
  webPushNotEnoughActivitiesMessage: () => Promise<String>;
  webPushNotEnoughActivitiesWeekday: () => Promise<Int>;
  webPushNotEnoughActivitiesBuddyMessage: () => Promise<String>;
  webPushNotEnoughActivitiesBuddyWeekday: () => Promise<Int>;
  webPushToManyActivitiesMessage: () => Promise<String>;
  webPushToManyActivitiesWeekday: () => Promise<Int>;
  webPushToManyActivitiesBuddyMessage: () => Promise<String>;
  webPushToManyActivitiesBuddyDelay: <T = TimeSpanPromise>() => T;
  webPushActivityMissedBuddyMessage: () => Promise<String>;
  webPushActivityMissedBuddyDelay: <T = TimeSpanPromise>() => T;
}

export interface GlobalSettingsConnection {
  pageInfo: PageInfo;
  edges: GlobalSettingsEdge[];
}

export interface GlobalSettingsConnectionPromise
  extends Promise<GlobalSettingsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GlobalSettingsEdge>>() => T;
  aggregate: <T = AggregateGlobalSettingsPromise>() => T;
}

export interface GlobalSettingsConnectionSubscription
  extends Promise<AsyncIterator<GlobalSettingsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GlobalSettingsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGlobalSettingsSubscription>() => T;
}

export interface GlobalSettingsEdge {
  node: GlobalSettings;
  cursor: String;
}

export interface GlobalSettingsEdgePromise
  extends Promise<GlobalSettingsEdge>,
    Fragmentable {
  node: <T = GlobalSettingsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GlobalSettingsEdgeSubscription
  extends Promise<AsyncIterator<GlobalSettingsEdge>>,
    Fragmentable {
  node: <T = GlobalSettingsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGlobalSettings {
  count: Int;
}

export interface AggregateGlobalSettingsPromise
  extends Promise<AggregateGlobalSettings>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGlobalSettingsSubscription
  extends Promise<AsyncIterator<AggregateGlobalSettings>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GroupConnection {
  pageInfo: PageInfo;
  edges: GroupEdge[];
}

export interface GroupConnectionPromise
  extends Promise<GroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GroupEdge>>() => T;
  aggregate: <T = AggregateGroupPromise>() => T;
}

export interface GroupConnectionSubscription
  extends Promise<AsyncIterator<GroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGroupSubscription>() => T;
}

export interface GroupEdge {
  node: Group;
  cursor: String;
}

export interface GroupEdgePromise extends Promise<GroupEdge>, Fragmentable {
  node: <T = GroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GroupEdgeSubscription
  extends Promise<AsyncIterator<GroupEdge>>,
    Fragmentable {
  node: <T = GroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGroup {
  count: Int;
}

export interface AggregateGroupPromise
  extends Promise<AggregateGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGroupSubscription
  extends Promise<AsyncIterator<AggregateGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GroupColor {
  id: ID_Output;
  color: String;
}

export interface GroupColorPromise extends Promise<GroupColor>, Fragmentable {
  id: () => Promise<ID_Output>;
  group: <T = GroupPromise>() => T;
  color: () => Promise<String>;
}

export interface GroupColorSubscription
  extends Promise<AsyncIterator<GroupColor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  group: <T = GroupSubscription>() => T;
  color: () => Promise<AsyncIterator<String>>;
}

export interface GroupColorNullablePromise
  extends Promise<GroupColor | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  group: <T = GroupPromise>() => T;
  color: () => Promise<String>;
}

export interface GroupColorConnection {
  pageInfo: PageInfo;
  edges: GroupColorEdge[];
}

export interface GroupColorConnectionPromise
  extends Promise<GroupColorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GroupColorEdge>>() => T;
  aggregate: <T = AggregateGroupColorPromise>() => T;
}

export interface GroupColorConnectionSubscription
  extends Promise<AsyncIterator<GroupColorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GroupColorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGroupColorSubscription>() => T;
}

export interface GroupColorEdge {
  node: GroupColor;
  cursor: String;
}

export interface GroupColorEdgePromise
  extends Promise<GroupColorEdge>,
    Fragmentable {
  node: <T = GroupColorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GroupColorEdgeSubscription
  extends Promise<AsyncIterator<GroupColorEdge>>,
    Fragmentable {
  node: <T = GroupColorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGroupColor {
  count: Int;
}

export interface AggregateGroupColorPromise
  extends Promise<AggregateGroupColor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGroupColorSubscription
  extends Promise<AsyncIterator<AggregateGroupColor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Initiator {
  id: ID_Output;
  title: String;
  description: String;
}

export interface InitiatorPromise extends Promise<Initiator>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
}

export interface InitiatorSubscription
  extends Promise<AsyncIterator<Initiator>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface InitiatorNullablePromise
  extends Promise<Initiator | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
}

export interface InitiatorConnection {
  pageInfo: PageInfo;
  edges: InitiatorEdge[];
}

export interface InitiatorConnectionPromise
  extends Promise<InitiatorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InitiatorEdge>>() => T;
  aggregate: <T = AggregateInitiatorPromise>() => T;
}

export interface InitiatorConnectionSubscription
  extends Promise<AsyncIterator<InitiatorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InitiatorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInitiatorSubscription>() => T;
}

export interface InitiatorEdge {
  node: Initiator;
  cursor: String;
}

export interface InitiatorEdgePromise
  extends Promise<InitiatorEdge>,
    Fragmentable {
  node: <T = InitiatorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InitiatorEdgeSubscription
  extends Promise<AsyncIterator<InitiatorEdge>>,
    Fragmentable {
  node: <T = InitiatorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInitiator {
  count: Int;
}

export interface AggregateInitiatorPromise
  extends Promise<AggregateInitiator>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInitiatorSubscription
  extends Promise<AsyncIterator<AggregateInitiator>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface IpaqConnection {
  pageInfo: PageInfo;
  edges: IpaqEdge[];
}

export interface IpaqConnectionPromise
  extends Promise<IpaqConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<IpaqEdge>>() => T;
  aggregate: <T = AggregateIpaqPromise>() => T;
}

export interface IpaqConnectionSubscription
  extends Promise<AsyncIterator<IpaqConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<IpaqEdgeSubscription>>>() => T;
  aggregate: <T = AggregateIpaqSubscription>() => T;
}

export interface IpaqEdge {
  node: Ipaq;
  cursor: String;
}

export interface IpaqEdgePromise extends Promise<IpaqEdge>, Fragmentable {
  node: <T = IpaqPromise>() => T;
  cursor: () => Promise<String>;
}

export interface IpaqEdgeSubscription
  extends Promise<AsyncIterator<IpaqEdge>>,
    Fragmentable {
  node: <T = IpaqSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateIpaq {
  count: Int;
}

export interface AggregateIpaqPromise
  extends Promise<AggregateIpaq>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateIpaqSubscription
  extends Promise<AsyncIterator<AggregateIpaq>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface IpaqAnswersConnection {
  pageInfo: PageInfo;
  edges: IpaqAnswersEdge[];
}

export interface IpaqAnswersConnectionPromise
  extends Promise<IpaqAnswersConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<IpaqAnswersEdge>>() => T;
  aggregate: <T = AggregateIpaqAnswersPromise>() => T;
}

export interface IpaqAnswersConnectionSubscription
  extends Promise<AsyncIterator<IpaqAnswersConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<IpaqAnswersEdgeSubscription>>>() => T;
  aggregate: <T = AggregateIpaqAnswersSubscription>() => T;
}

export interface IpaqAnswersEdge {
  node: IpaqAnswers;
  cursor: String;
}

export interface IpaqAnswersEdgePromise
  extends Promise<IpaqAnswersEdge>,
    Fragmentable {
  node: <T = IpaqAnswersPromise>() => T;
  cursor: () => Promise<String>;
}

export interface IpaqAnswersEdgeSubscription
  extends Promise<AsyncIterator<IpaqAnswersEdge>>,
    Fragmentable {
  node: <T = IpaqAnswersSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateIpaqAnswers {
  count: Int;
}

export interface AggregateIpaqAnswersPromise
  extends Promise<AggregateIpaqAnswers>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateIpaqAnswersSubscription
  extends Promise<AsyncIterator<AggregateIpaqAnswers>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface JoinedChallenges {
  id: ID_Output;
}

export interface JoinedChallengesPromise
  extends Promise<JoinedChallenges>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userId: <T = UserPromise>() => T;
  challegeId: <T = ChallengePromise>() => T;
}

export interface JoinedChallengesSubscription
  extends Promise<AsyncIterator<JoinedChallenges>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userId: <T = UserSubscription>() => T;
  challegeId: <T = ChallengeSubscription>() => T;
}

export interface JoinedChallengesNullablePromise
  extends Promise<JoinedChallenges | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userId: <T = UserPromise>() => T;
  challegeId: <T = ChallengePromise>() => T;
}

export interface JoinedChallengesConnection {
  pageInfo: PageInfo;
  edges: JoinedChallengesEdge[];
}

export interface JoinedChallengesConnectionPromise
  extends Promise<JoinedChallengesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<JoinedChallengesEdge>>() => T;
  aggregate: <T = AggregateJoinedChallengesPromise>() => T;
}

export interface JoinedChallengesConnectionSubscription
  extends Promise<AsyncIterator<JoinedChallengesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<JoinedChallengesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateJoinedChallengesSubscription>() => T;
}

export interface JoinedChallengesEdge {
  node: JoinedChallenges;
  cursor: String;
}

export interface JoinedChallengesEdgePromise
  extends Promise<JoinedChallengesEdge>,
    Fragmentable {
  node: <T = JoinedChallengesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface JoinedChallengesEdgeSubscription
  extends Promise<AsyncIterator<JoinedChallengesEdge>>,
    Fragmentable {
  node: <T = JoinedChallengesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateJoinedChallenges {
  count: Int;
}

export interface AggregateJoinedChallengesPromise
  extends Promise<AggregateJoinedChallenges>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateJoinedChallengesSubscription
  extends Promise<AsyncIterator<AggregateJoinedChallenges>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PatientConnection {
  pageInfo: PageInfo;
  edges: PatientEdge[];
}

export interface PatientConnectionPromise
  extends Promise<PatientConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PatientEdge>>() => T;
  aggregate: <T = AggregatePatientPromise>() => T;
}

export interface PatientConnectionSubscription
  extends Promise<AsyncIterator<PatientConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PatientEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePatientSubscription>() => T;
}

export interface PatientEdge {
  node: Patient;
  cursor: String;
}

export interface PatientEdgePromise extends Promise<PatientEdge>, Fragmentable {
  node: <T = PatientPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PatientEdgeSubscription
  extends Promise<AsyncIterator<PatientEdge>>,
    Fragmentable {
  node: <T = PatientSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePatient {
  count: Int;
}

export interface AggregatePatientPromise
  extends Promise<AggregatePatient>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePatientSubscription
  extends Promise<AsyncIterator<AggregatePatient>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PatientProfileInfoConnection {
  pageInfo: PageInfo;
  edges: PatientProfileInfoEdge[];
}

export interface PatientProfileInfoConnectionPromise
  extends Promise<PatientProfileInfoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PatientProfileInfoEdge>>() => T;
  aggregate: <T = AggregatePatientProfileInfoPromise>() => T;
}

export interface PatientProfileInfoConnectionSubscription
  extends Promise<AsyncIterator<PatientProfileInfoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<PatientProfileInfoEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregatePatientProfileInfoSubscription>() => T;
}

export interface PatientProfileInfoEdge {
  node: PatientProfileInfo;
  cursor: String;
}

export interface PatientProfileInfoEdgePromise
  extends Promise<PatientProfileInfoEdge>,
    Fragmentable {
  node: <T = PatientProfileInfoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PatientProfileInfoEdgeSubscription
  extends Promise<AsyncIterator<PatientProfileInfoEdge>>,
    Fragmentable {
  node: <T = PatientProfileInfoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePatientProfileInfo {
  count: Int;
}

export interface AggregatePatientProfileInfoPromise
  extends Promise<AggregatePatientProfileInfo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePatientProfileInfoSubscription
  extends Promise<AsyncIterator<AggregatePatientProfileInfo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Phq9Connection {
  pageInfo: PageInfo;
  edges: Phq9Edge[];
}

export interface Phq9ConnectionPromise
  extends Promise<Phq9Connection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<Phq9Edge>>() => T;
  aggregate: <T = AggregatePhq9Promise>() => T;
}

export interface Phq9ConnectionSubscription
  extends Promise<AsyncIterator<Phq9Connection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Phq9EdgeSubscription>>>() => T;
  aggregate: <T = AggregatePhq9Subscription>() => T;
}

export interface Phq9Edge {
  node: Phq9;
  cursor: String;
}

export interface Phq9EdgePromise extends Promise<Phq9Edge>, Fragmentable {
  node: <T = Phq9Promise>() => T;
  cursor: () => Promise<String>;
}

export interface Phq9EdgeSubscription
  extends Promise<AsyncIterator<Phq9Edge>>,
    Fragmentable {
  node: <T = Phq9Subscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePhq9 {
  count: Int;
}

export interface AggregatePhq9Promise
  extends Promise<AggregatePhq9>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePhq9Subscription
  extends Promise<AsyncIterator<AggregatePhq9>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProfileActivityConnection {
  pageInfo: PageInfo;
  edges: ProfileActivityEdge[];
}

export interface ProfileActivityConnectionPromise
  extends Promise<ProfileActivityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProfileActivityEdge>>() => T;
  aggregate: <T = AggregateProfileActivityPromise>() => T;
}

export interface ProfileActivityConnectionSubscription
  extends Promise<AsyncIterator<ProfileActivityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProfileActivityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProfileActivitySubscription>() => T;
}

export interface ProfileActivityEdge {
  node: ProfileActivity;
  cursor: String;
}

export interface ProfileActivityEdgePromise
  extends Promise<ProfileActivityEdge>,
    Fragmentable {
  node: <T = ProfileActivityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProfileActivityEdgeSubscription
  extends Promise<AsyncIterator<ProfileActivityEdge>>,
    Fragmentable {
  node: <T = ProfileActivitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProfileActivity {
  count: Int;
}

export interface AggregateProfileActivityPromise
  extends Promise<AggregateProfileActivity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProfileActivitySubscription
  extends Promise<AsyncIterator<AggregateProfileActivity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionnairesConnection {
  pageInfo: PageInfo;
  edges: QuestionnairesEdge[];
}

export interface QuestionnairesConnectionPromise
  extends Promise<QuestionnairesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionnairesEdge>>() => T;
  aggregate: <T = AggregateQuestionnairesPromise>() => T;
}

export interface QuestionnairesConnectionSubscription
  extends Promise<AsyncIterator<QuestionnairesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuestionnairesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuestionnairesSubscription>() => T;
}

export interface QuestionnairesEdge {
  node: Questionnaires;
  cursor: String;
}

export interface QuestionnairesEdgePromise
  extends Promise<QuestionnairesEdge>,
    Fragmentable {
  node: <T = QuestionnairesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionnairesEdgeSubscription
  extends Promise<AsyncIterator<QuestionnairesEdge>>,
    Fragmentable {
  node: <T = QuestionnairesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQuestionnaires {
  count: Int;
}

export interface AggregateQuestionnairesPromise
  extends Promise<AggregateQuestionnaires>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionnairesSubscription
  extends Promise<AsyncIterator<AggregateQuestionnaires>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduledTask {
  id: ID_Output;
  updatedAt?: DateTimeOutput;
  scheduledFor?: DateTimeOutput;
  taskType: TaskTypes;
  userId?: ID_Output;
  chatId?: ID_Output;
  buddyRequestId?: ID_Output;
}

export interface ScheduledTaskPromise
  extends Promise<ScheduledTask>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  scheduledFor: () => Promise<DateTimeOutput>;
  taskType: () => Promise<TaskTypes>;
  userId: () => Promise<ID_Output>;
  chatId: () => Promise<ID_Output>;
  buddyRequestId: () => Promise<ID_Output>;
}

export interface ScheduledTaskSubscription
  extends Promise<AsyncIterator<ScheduledTask>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  scheduledFor: () => Promise<AsyncIterator<DateTimeOutput>>;
  taskType: () => Promise<AsyncIterator<TaskTypes>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
  chatId: () => Promise<AsyncIterator<ID_Output>>;
  buddyRequestId: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ScheduledTaskNullablePromise
  extends Promise<ScheduledTask | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  scheduledFor: () => Promise<DateTimeOutput>;
  taskType: () => Promise<TaskTypes>;
  userId: () => Promise<ID_Output>;
  chatId: () => Promise<ID_Output>;
  buddyRequestId: () => Promise<ID_Output>;
}

export interface ScheduledTaskConnection {
  pageInfo: PageInfo;
  edges: ScheduledTaskEdge[];
}

export interface ScheduledTaskConnectionPromise
  extends Promise<ScheduledTaskConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ScheduledTaskEdge>>() => T;
  aggregate: <T = AggregateScheduledTaskPromise>() => T;
}

export interface ScheduledTaskConnectionSubscription
  extends Promise<AsyncIterator<ScheduledTaskConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ScheduledTaskEdgeSubscription>>>() => T;
  aggregate: <T = AggregateScheduledTaskSubscription>() => T;
}

export interface ScheduledTaskEdge {
  node: ScheduledTask;
  cursor: String;
}

export interface ScheduledTaskEdgePromise
  extends Promise<ScheduledTaskEdge>,
    Fragmentable {
  node: <T = ScheduledTaskPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduledTaskEdgeSubscription
  extends Promise<AsyncIterator<ScheduledTaskEdge>>,
    Fragmentable {
  node: <T = ScheduledTaskSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateScheduledTask {
  count: Int;
}

export interface AggregateScheduledTaskPromise
  extends Promise<AggregateScheduledTask>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduledTaskSubscription
  extends Promise<AsyncIterator<AggregateScheduledTask>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SensorDataConnection {
  pageInfo: PageInfo;
  edges: SensorDataEdge[];
}

export interface SensorDataConnectionPromise
  extends Promise<SensorDataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SensorDataEdge>>() => T;
  aggregate: <T = AggregateSensorDataPromise>() => T;
}

export interface SensorDataConnectionSubscription
  extends Promise<AsyncIterator<SensorDataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SensorDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSensorDataSubscription>() => T;
}

export interface SensorDataEdge {
  node: SensorData;
  cursor: String;
}

export interface SensorDataEdgePromise
  extends Promise<SensorDataEdge>,
    Fragmentable {
  node: <T = SensorDataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SensorDataEdgeSubscription
  extends Promise<AsyncIterator<SensorDataEdge>>,
    Fragmentable {
  node: <T = SensorDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSensorData {
  count: Int;
}

export interface AggregateSensorDataPromise
  extends Promise<AggregateSensorData>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSensorDataSubscription
  extends Promise<AsyncIterator<AggregateSensorData>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TimeSpanConnection {
  pageInfo: PageInfo;
  edges: TimeSpanEdge[];
}

export interface TimeSpanConnectionPromise
  extends Promise<TimeSpanConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TimeSpanEdge>>() => T;
  aggregate: <T = AggregateTimeSpanPromise>() => T;
}

export interface TimeSpanConnectionSubscription
  extends Promise<AsyncIterator<TimeSpanConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TimeSpanEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTimeSpanSubscription>() => T;
}

export interface TimeSpanEdge {
  node: TimeSpan;
  cursor: String;
}

export interface TimeSpanEdgePromise
  extends Promise<TimeSpanEdge>,
    Fragmentable {
  node: <T = TimeSpanPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TimeSpanEdgeSubscription
  extends Promise<AsyncIterator<TimeSpanEdge>>,
    Fragmentable {
  node: <T = TimeSpanSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTimeSpan {
  count: Int;
}

export interface AggregateTimeSpanPromise
  extends Promise<AggregateTimeSpan>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTimeSpanSubscription
  extends Promise<AsyncIterator<AggregateTimeSpan>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserSettingsConnection {
  pageInfo: PageInfo;
  edges: UserSettingsEdge[];
}

export interface UserSettingsConnectionPromise
  extends Promise<UserSettingsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserSettingsEdge>>() => T;
  aggregate: <T = AggregateUserSettingsPromise>() => T;
}

export interface UserSettingsConnectionSubscription
  extends Promise<AsyncIterator<UserSettingsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserSettingsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSettingsSubscription>() => T;
}

export interface UserSettingsEdge {
  node: UserSettings;
  cursor: String;
}

export interface UserSettingsEdgePromise
  extends Promise<UserSettingsEdge>,
    Fragmentable {
  node: <T = UserSettingsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserSettingsEdgeSubscription
  extends Promise<AsyncIterator<UserSettingsEdge>>,
    Fragmentable {
  node: <T = UserSettingsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserSettings {
  count: Int;
}

export interface AggregateUserSettingsPromise
  extends Promise<AggregateUserSettings>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSettingsSubscription
  extends Promise<AsyncIterator<AggregateUserSettings>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VotingConnection {
  pageInfo: PageInfo;
  edges: VotingEdge[];
}

export interface VotingConnectionPromise
  extends Promise<VotingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VotingEdge>>() => T;
  aggregate: <T = AggregateVotingPromise>() => T;
}

export interface VotingConnectionSubscription
  extends Promise<AsyncIterator<VotingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VotingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVotingSubscription>() => T;
}

export interface VotingEdge {
  node: Voting;
  cursor: String;
}

export interface VotingEdgePromise extends Promise<VotingEdge>, Fragmentable {
  node: <T = VotingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VotingEdgeSubscription
  extends Promise<AsyncIterator<VotingEdge>>,
    Fragmentable {
  node: <T = VotingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVoting {
  count: Int;
}

export interface AggregateVotingPromise
  extends Promise<AggregateVoting>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVotingSubscription
  extends Promise<AsyncIterator<AggregateVoting>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WebPushNotificationConnection {
  pageInfo: PageInfo;
  edges: WebPushNotificationEdge[];
}

export interface WebPushNotificationConnectionPromise
  extends Promise<WebPushNotificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WebPushNotificationEdge>>() => T;
  aggregate: <T = AggregateWebPushNotificationPromise>() => T;
}

export interface WebPushNotificationConnectionSubscription
  extends Promise<AsyncIterator<WebPushNotificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<WebPushNotificationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateWebPushNotificationSubscription>() => T;
}

export interface WebPushNotificationEdge {
  node: WebPushNotification;
  cursor: String;
}

export interface WebPushNotificationEdgePromise
  extends Promise<WebPushNotificationEdge>,
    Fragmentable {
  node: <T = WebPushNotificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WebPushNotificationEdgeSubscription
  extends Promise<AsyncIterator<WebPushNotificationEdge>>,
    Fragmentable {
  node: <T = WebPushNotificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWebPushNotification {
  count: Int;
}

export interface AggregateWebPushNotificationPromise
  extends Promise<AggregateWebPushNotification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWebPushNotificationSubscription
  extends Promise<AsyncIterator<AggregateWebPushNotification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WebPushSettingsConnection {
  pageInfo: PageInfo;
  edges: WebPushSettingsEdge[];
}

export interface WebPushSettingsConnectionPromise
  extends Promise<WebPushSettingsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WebPushSettingsEdge>>() => T;
  aggregate: <T = AggregateWebPushSettingsPromise>() => T;
}

export interface WebPushSettingsConnectionSubscription
  extends Promise<AsyncIterator<WebPushSettingsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WebPushSettingsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWebPushSettingsSubscription>() => T;
}

export interface WebPushSettingsEdge {
  node: WebPushSettings;
  cursor: String;
}

export interface WebPushSettingsEdgePromise
  extends Promise<WebPushSettingsEdge>,
    Fragmentable {
  node: <T = WebPushSettingsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WebPushSettingsEdgeSubscription
  extends Promise<AsyncIterator<WebPushSettingsEdge>>,
    Fragmentable {
  node: <T = WebPushSettingsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWebPushSettings {
  count: Int;
}

export interface AggregateWebPushSettingsPromise
  extends Promise<AggregateWebPushSettings>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWebPushSettingsSubscription
  extends Promise<AsyncIterator<AggregateWebPushSettings>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ActivitySubscriptionPayload {
  mutation: MutationType;
  node: Activity;
  updatedFields: String[];
  previousValues: ActivityPreviousValues;
}

export interface ActivitySubscriptionPayloadPromise
  extends Promise<ActivitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActivityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActivityPreviousValuesPromise>() => T;
}

export interface ActivitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActivitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActivitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActivityPreviousValuesSubscription>() => T;
}

export interface ActivityPreviousValues {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  key: String;
  titel?: String;
  description?: String;
  grade?: ActivityGrade;
  icon?: String;
  tags: String[];
  isCustom?: Boolean;
  color?: String;
}

export interface ActivityPreviousValuesPromise
  extends Promise<ActivityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  key: () => Promise<String>;
  titel: () => Promise<String>;
  description: () => Promise<String>;
  grade: () => Promise<ActivityGrade>;
  icon: () => Promise<String>;
  tags: () => Promise<String[]>;
  isCustom: () => Promise<Boolean>;
  color: () => Promise<String>;
}

export interface ActivityPreviousValuesSubscription
  extends Promise<AsyncIterator<ActivityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  key: () => Promise<AsyncIterator<String>>;
  titel: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  grade: () => Promise<AsyncIterator<ActivityGrade>>;
  icon: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
  isCustom: () => Promise<AsyncIterator<Boolean>>;
  color: () => Promise<AsyncIterator<String>>;
}

export interface AwardSubscriptionPayload {
  mutation: MutationType;
  node: Award;
  updatedFields: String[];
  previousValues: AwardPreviousValues;
}

export interface AwardSubscriptionPayloadPromise
  extends Promise<AwardSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AwardPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AwardPreviousValuesPromise>() => T;
}

export interface AwardSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AwardSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AwardSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AwardPreviousValuesSubscription>() => T;
}

export interface AwardPreviousValues {
  id: ID_Output;
  status?: AwardVT;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface AwardPreviousValuesPromise
  extends Promise<AwardPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<AwardVT>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AwardPreviousValuesSubscription
  extends Promise<AsyncIterator<AwardPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<AwardVT>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BotSubscriptionPayload {
  mutation: MutationType;
  node: Bot;
  updatedFields: String[];
  previousValues: BotPreviousValues;
}

export interface BotSubscriptionPayloadPromise
  extends Promise<BotSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BotPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BotPreviousValuesPromise>() => T;
}

export interface BotSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BotSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BotSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BotPreviousValuesSubscription>() => T;
}

export interface BotPreviousValues {
  id: ID_Output;
  name?: String;
}

export interface BotPreviousValuesPromise
  extends Promise<BotPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface BotPreviousValuesSubscription
  extends Promise<AsyncIterator<BotPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface BotSettingsSubscriptionPayload {
  mutation: MutationType;
  node: BotSettings;
  updatedFields: String[];
  previousValues: BotSettingsPreviousValues;
}

export interface BotSettingsSubscriptionPayloadPromise
  extends Promise<BotSettingsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BotSettingsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BotSettingsPreviousValuesPromise>() => T;
}

export interface BotSettingsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BotSettingsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BotSettingsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BotSettingsPreviousValuesSubscription>() => T;
}

export interface BotSettingsPreviousValues {
  id: ID_Output;
  updatedAt?: DateTimeOutput;
  botFirstGreetingText?: String;
  botAskCreateActivitiesMessage?: String;
  botActivityLessThanPlannedMessage?: String;
  botActivityLessThanPlannedWeekday?: Int;
  botAskStartChatMessage?: String;
}

export interface BotSettingsPreviousValuesPromise
  extends Promise<BotSettingsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  botFirstGreetingText: () => Promise<String>;
  botAskCreateActivitiesMessage: () => Promise<String>;
  botActivityLessThanPlannedMessage: () => Promise<String>;
  botActivityLessThanPlannedWeekday: () => Promise<Int>;
  botAskStartChatMessage: () => Promise<String>;
}

export interface BotSettingsPreviousValuesSubscription
  extends Promise<AsyncIterator<BotSettingsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  botFirstGreetingText: () => Promise<AsyncIterator<String>>;
  botAskCreateActivitiesMessage: () => Promise<AsyncIterator<String>>;
  botActivityLessThanPlannedMessage: () => Promise<AsyncIterator<String>>;
  botActivityLessThanPlannedWeekday: () => Promise<AsyncIterator<Int>>;
  botAskStartChatMessage: () => Promise<AsyncIterator<String>>;
}

export interface BuddySubscriptionPayload {
  mutation: MutationType;
  node: Buddy;
  updatedFields: String[];
  previousValues: BuddyPreviousValues;
}

export interface BuddySubscriptionPayloadPromise
  extends Promise<BuddySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BuddyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BuddyPreviousValuesPromise>() => T;
}

export interface BuddySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BuddySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BuddySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BuddyPreviousValuesSubscription>() => T;
}

export interface BuddyPreviousValues {
  id: ID_Output;
}

export interface BuddyPreviousValuesPromise
  extends Promise<BuddyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface BuddyPreviousValuesSubscription
  extends Promise<AsyncIterator<BuddyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface BuddyRequestSubscriptionPayload {
  mutation: MutationType;
  node: BuddyRequest;
  updatedFields: String[];
  previousValues: BuddyRequestPreviousValues;
}

export interface BuddyRequestSubscriptionPayloadPromise
  extends Promise<BuddyRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BuddyRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BuddyRequestPreviousValuesPromise>() => T;
}

export interface BuddyRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BuddyRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BuddyRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BuddyRequestPreviousValuesSubscription>() => T;
}

export interface BuddyRequestPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  state?: BuddyRequestState;
}

export interface BuddyRequestPreviousValuesPromise
  extends Promise<BuddyRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  state: () => Promise<BuddyRequestState>;
}

export interface BuddyRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<BuddyRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  state: () => Promise<AsyncIterator<BuddyRequestState>>;
}

export interface CalendarEntrySubscriptionPayload {
  mutation: MutationType;
  node: CalendarEntry;
  updatedFields: String[];
  previousValues: CalendarEntryPreviousValues;
}

export interface CalendarEntrySubscriptionPayloadPromise
  extends Promise<CalendarEntrySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CalendarEntryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CalendarEntryPreviousValuesPromise>() => T;
}

export interface CalendarEntrySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CalendarEntrySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CalendarEntrySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CalendarEntryPreviousValuesSubscription>() => T;
}

export interface CalendarEntryPreviousValues {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
  isDone?: Boolean;
  isRunning?: Boolean;
  trackingRequested?: Boolean;
}

export interface CalendarEntryPreviousValuesPromise
  extends Promise<CalendarEntryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  isDone: () => Promise<Boolean>;
  isRunning: () => Promise<Boolean>;
  trackingRequested: () => Promise<Boolean>;
}

export interface CalendarEntryPreviousValuesSubscription
  extends Promise<AsyncIterator<CalendarEntryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  isDone: () => Promise<AsyncIterator<Boolean>>;
  isRunning: () => Promise<AsyncIterator<Boolean>>;
  trackingRequested: () => Promise<AsyncIterator<Boolean>>;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface CategoryPreviousValues {
  id: ID_Output;
  title: String;
  description: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ChallengeSubscriptionPayload {
  mutation: MutationType;
  node: Challenge;
  updatedFields: String[];
  previousValues: ChallengePreviousValues;
}

export interface ChallengeSubscriptionPayloadPromise
  extends Promise<ChallengeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChallengePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChallengePreviousValuesPromise>() => T;
}

export interface ChallengeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChallengeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChallengeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChallengePreviousValuesSubscription>() => T;
}

export interface ChallengePreviousValues {
  id: ID_Output;
  title: String;
  description: String;
  image: String;
  premium?: String;
  timeEnd?: DateTimeOutput;
  emailSend?: String;
  status?: StatusChallegen;
  initiator: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface ChallengePreviousValuesPromise
  extends Promise<ChallengePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  premium: () => Promise<String>;
  timeEnd: () => Promise<DateTimeOutput>;
  emailSend: () => Promise<String>;
  status: () => Promise<StatusChallegen>;
  initiator: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ChallengePreviousValuesSubscription
  extends Promise<AsyncIterator<ChallengePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  premium: () => Promise<AsyncIterator<String>>;
  timeEnd: () => Promise<AsyncIterator<DateTimeOutput>>;
  emailSend: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<StatusChallegen>>;
  initiator: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ChallengeCategorySubscriptionPayload {
  mutation: MutationType;
  node: ChallengeCategory;
  updatedFields: String[];
  previousValues: ChallengeCategoryPreviousValues;
}

export interface ChallengeCategorySubscriptionPayloadPromise
  extends Promise<ChallengeCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChallengeCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChallengeCategoryPreviousValuesPromise>() => T;
}

export interface ChallengeCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChallengeCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChallengeCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChallengeCategoryPreviousValuesSubscription>() => T;
}

export interface ChallengeCategoryPreviousValues {
  id: ID_Output;
}

export interface ChallengeCategoryPreviousValuesPromise
  extends Promise<ChallengeCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ChallengeCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<ChallengeCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ChallengeGroupSubscriptionPayload {
  mutation: MutationType;
  node: ChallengeGroup;
  updatedFields: String[];
  previousValues: ChallengeGroupPreviousValues;
}

export interface ChallengeGroupSubscriptionPayloadPromise
  extends Promise<ChallengeGroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChallengeGroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChallengeGroupPreviousValuesPromise>() => T;
}

export interface ChallengeGroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChallengeGroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChallengeGroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChallengeGroupPreviousValuesSubscription>() => T;
}

export interface ChallengeGroupPreviousValues {
  id: ID_Output;
}

export interface ChallengeGroupPreviousValuesPromise
  extends Promise<ChallengeGroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ChallengeGroupPreviousValuesSubscription
  extends Promise<AsyncIterator<ChallengeGroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ChatSubscriptionPayload {
  mutation: MutationType;
  node: Chat;
  updatedFields: String[];
  previousValues: ChatPreviousValues;
}

export interface ChatSubscriptionPayloadPromise
  extends Promise<ChatSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChatPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChatPreviousValuesPromise>() => T;
}

export interface ChatSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChatSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChatSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChatPreviousValuesSubscription>() => T;
}

export interface ChatPreviousValues {
  id: ID_Output;
}

export interface ChatPreviousValuesPromise
  extends Promise<ChatPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ChatPreviousValuesSubscription
  extends Promise<AsyncIterator<ChatPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ChatMessageSubscriptionPayload {
  mutation: MutationType;
  node: ChatMessage;
  updatedFields: String[];
  previousValues: ChatMessagePreviousValues;
}

export interface ChatMessageSubscriptionPayloadPromise
  extends Promise<ChatMessageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChatMessagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChatMessagePreviousValuesPromise>() => T;
}

export interface ChatMessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChatMessageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChatMessageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChatMessagePreviousValuesSubscription>() => T;
}

export interface ChatMessagePreviousValues {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  text?: String;
}

export interface ChatMessagePreviousValuesPromise
  extends Promise<ChatMessagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
}

export interface ChatMessagePreviousValuesSubscription
  extends Promise<AsyncIterator<ChatMessagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface ChatMessageAttachmentSubscriptionPayload {
  mutation: MutationType;
  node: ChatMessageAttachment;
  updatedFields: String[];
  previousValues: ChatMessageAttachmentPreviousValues;
}

export interface ChatMessageAttachmentSubscriptionPayloadPromise
  extends Promise<ChatMessageAttachmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChatMessageAttachmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChatMessageAttachmentPreviousValuesPromise>() => T;
}

export interface ChatMessageAttachmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChatMessageAttachmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChatMessageAttachmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChatMessageAttachmentPreviousValuesSubscription>() => T;
}

export interface ChatMessageAttachmentPreviousValues {
  id: ID_Output;
  originalCalendarEntryId?: ID_Output;
  ownerId?: ID_Output;
}

export interface ChatMessageAttachmentPreviousValuesPromise
  extends Promise<ChatMessageAttachmentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  originalCalendarEntryId: () => Promise<ID_Output>;
  ownerId: () => Promise<ID_Output>;
}

export interface ChatMessageAttachmentPreviousValuesSubscription
  extends Promise<AsyncIterator<ChatMessageAttachmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  originalCalendarEntryId: () => Promise<AsyncIterator<ID_Output>>;
  ownerId: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ContributionSubscriptionPayload {
  mutation: MutationType;
  node: Contribution;
  updatedFields: String[];
  previousValues: ContributionPreviousValues;
}

export interface ContributionSubscriptionPayloadPromise
  extends Promise<ContributionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContributionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContributionPreviousValuesPromise>() => T;
}

export interface ContributionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContributionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContributionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContributionPreviousValuesSubscription>() => T;
}

export interface ContributionPreviousValues {
  id: ID_Output;
  title: String;
  description?: String;
  image?: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface ContributionPreviousValuesPromise
  extends Promise<ContributionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ContributionPreviousValuesSubscription
  extends Promise<AsyncIterator<ContributionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FavoriteActivitySubscriptionPayload {
  mutation: MutationType;
  node: FavoriteActivity;
  updatedFields: String[];
  previousValues: FavoriteActivityPreviousValues;
}

export interface FavoriteActivitySubscriptionPayloadPromise
  extends Promise<FavoriteActivitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FavoriteActivityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FavoriteActivityPreviousValuesPromise>() => T;
}

export interface FavoriteActivitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FavoriteActivitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FavoriteActivitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FavoriteActivityPreviousValuesSubscription>() => T;
}

export interface FavoriteActivityPreviousValues {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  activityKey: String;
}

export interface FavoriteActivityPreviousValuesPromise
  extends Promise<FavoriteActivityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  activityKey: () => Promise<String>;
}

export interface FavoriteActivityPreviousValuesSubscription
  extends Promise<AsyncIterator<FavoriteActivityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  activityKey: () => Promise<AsyncIterator<String>>;
}

export interface GlobalSettingsSubscriptionPayload {
  mutation: MutationType;
  node: GlobalSettings;
  updatedFields: String[];
  previousValues: GlobalSettingsPreviousValues;
}

export interface GlobalSettingsSubscriptionPayloadPromise
  extends Promise<GlobalSettingsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GlobalSettingsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GlobalSettingsPreviousValuesPromise>() => T;
}

export interface GlobalSettingsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GlobalSettingsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GlobalSettingsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GlobalSettingsPreviousValuesSubscription>() => T;
}

export interface GlobalSettingsPreviousValues {
  id: ID_Output;
  updatedAt?: DateTimeOutput;
  matchingPercentageCap?: Int;
  defaultActivityTimeMinutesPerWeek?: Int;
  minimumActivityTimeMinutes?: Int;
  maximumActivityTimeMinutes?: Int;
  ipaqGroupLowMax?: Int;
  ipaqGroupModerateMax?: Int;
  ipaqGroupHighMax?: Int;
  phqGroupLowMin?: Int;
  phqGroupLowMax?: Int;
}

export interface GlobalSettingsPreviousValuesPromise
  extends Promise<GlobalSettingsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  matchingPercentageCap: () => Promise<Int>;
  defaultActivityTimeMinutesPerWeek: () => Promise<Int>;
  minimumActivityTimeMinutes: () => Promise<Int>;
  maximumActivityTimeMinutes: () => Promise<Int>;
  ipaqGroupLowMax: () => Promise<Int>;
  ipaqGroupModerateMax: () => Promise<Int>;
  ipaqGroupHighMax: () => Promise<Int>;
  phqGroupLowMin: () => Promise<Int>;
  phqGroupLowMax: () => Promise<Int>;
}

export interface GlobalSettingsPreviousValuesSubscription
  extends Promise<AsyncIterator<GlobalSettingsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  matchingPercentageCap: () => Promise<AsyncIterator<Int>>;
  defaultActivityTimeMinutesPerWeek: () => Promise<AsyncIterator<Int>>;
  minimumActivityTimeMinutes: () => Promise<AsyncIterator<Int>>;
  maximumActivityTimeMinutes: () => Promise<AsyncIterator<Int>>;
  ipaqGroupLowMax: () => Promise<AsyncIterator<Int>>;
  ipaqGroupModerateMax: () => Promise<AsyncIterator<Int>>;
  ipaqGroupHighMax: () => Promise<AsyncIterator<Int>>;
  phqGroupLowMin: () => Promise<AsyncIterator<Int>>;
  phqGroupLowMax: () => Promise<AsyncIterator<Int>>;
}

export interface GroupSubscriptionPayload {
  mutation: MutationType;
  node: Group;
  updatedFields: String[];
  previousValues: GroupPreviousValues;
}

export interface GroupSubscriptionPayloadPromise
  extends Promise<GroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GroupPreviousValuesPromise>() => T;
}

export interface GroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GroupPreviousValuesSubscription>() => T;
}

export interface GroupPreviousValues {
  id: ID_Output;
  title: String;
  description: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface GroupPreviousValuesPromise
  extends Promise<GroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GroupPreviousValuesSubscription
  extends Promise<AsyncIterator<GroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GroupColorSubscriptionPayload {
  mutation: MutationType;
  node: GroupColor;
  updatedFields: String[];
  previousValues: GroupColorPreviousValues;
}

export interface GroupColorSubscriptionPayloadPromise
  extends Promise<GroupColorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GroupColorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GroupColorPreviousValuesPromise>() => T;
}

export interface GroupColorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GroupColorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GroupColorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GroupColorPreviousValuesSubscription>() => T;
}

export interface GroupColorPreviousValues {
  id: ID_Output;
  color: String;
}

export interface GroupColorPreviousValuesPromise
  extends Promise<GroupColorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  color: () => Promise<String>;
}

export interface GroupColorPreviousValuesSubscription
  extends Promise<AsyncIterator<GroupColorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  color: () => Promise<AsyncIterator<String>>;
}

export interface InitiatorSubscriptionPayload {
  mutation: MutationType;
  node: Initiator;
  updatedFields: String[];
  previousValues: InitiatorPreviousValues;
}

export interface InitiatorSubscriptionPayloadPromise
  extends Promise<InitiatorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InitiatorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InitiatorPreviousValuesPromise>() => T;
}

export interface InitiatorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InitiatorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InitiatorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InitiatorPreviousValuesSubscription>() => T;
}

export interface InitiatorPreviousValues {
  id: ID_Output;
  title: String;
  description: String;
}

export interface InitiatorPreviousValuesPromise
  extends Promise<InitiatorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
}

export interface InitiatorPreviousValuesSubscription
  extends Promise<AsyncIterator<InitiatorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface IpaqSubscriptionPayload {
  mutation: MutationType;
  node: Ipaq;
  updatedFields: String[];
  previousValues: IpaqPreviousValues;
}

export interface IpaqSubscriptionPayloadPromise
  extends Promise<IpaqSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = IpaqPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = IpaqPreviousValuesPromise>() => T;
}

export interface IpaqSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<IpaqSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = IpaqSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = IpaqPreviousValuesSubscription>() => T;
}

export interface IpaqPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  score?: Float;
  expiryDate?: DateTimeOutput;
  isComplete?: Boolean;
}

export interface IpaqPreviousValuesPromise
  extends Promise<IpaqPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  score: () => Promise<Float>;
  expiryDate: () => Promise<DateTimeOutput>;
  isComplete: () => Promise<Boolean>;
}

export interface IpaqPreviousValuesSubscription
  extends Promise<AsyncIterator<IpaqPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  score: () => Promise<AsyncIterator<Float>>;
  expiryDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  isComplete: () => Promise<AsyncIterator<Boolean>>;
}

export interface IpaqAnswersSubscriptionPayload {
  mutation: MutationType;
  node: IpaqAnswers;
  updatedFields: String[];
  previousValues: IpaqAnswersPreviousValues;
}

export interface IpaqAnswersSubscriptionPayloadPromise
  extends Promise<IpaqAnswersSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = IpaqAnswersPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = IpaqAnswersPreviousValuesPromise>() => T;
}

export interface IpaqAnswersSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<IpaqAnswersSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = IpaqAnswersSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = IpaqAnswersPreviousValuesSubscription>() => T;
}

export interface IpaqAnswersPreviousValues {
  id: ID_Output;
  numDays?: Int;
  numHours?: Int;
  numMinutes?: Int;
}

export interface IpaqAnswersPreviousValuesPromise
  extends Promise<IpaqAnswersPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  numDays: () => Promise<Int>;
  numHours: () => Promise<Int>;
  numMinutes: () => Promise<Int>;
}

export interface IpaqAnswersPreviousValuesSubscription
  extends Promise<AsyncIterator<IpaqAnswersPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  numDays: () => Promise<AsyncIterator<Int>>;
  numHours: () => Promise<AsyncIterator<Int>>;
  numMinutes: () => Promise<AsyncIterator<Int>>;
}

export interface JoinedChallengesSubscriptionPayload {
  mutation: MutationType;
  node: JoinedChallenges;
  updatedFields: String[];
  previousValues: JoinedChallengesPreviousValues;
}

export interface JoinedChallengesSubscriptionPayloadPromise
  extends Promise<JoinedChallengesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = JoinedChallengesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = JoinedChallengesPreviousValuesPromise>() => T;
}

export interface JoinedChallengesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<JoinedChallengesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = JoinedChallengesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = JoinedChallengesPreviousValuesSubscription>() => T;
}

export interface JoinedChallengesPreviousValues {
  id: ID_Output;
}

export interface JoinedChallengesPreviousValuesPromise
  extends Promise<JoinedChallengesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface JoinedChallengesPreviousValuesSubscription
  extends Promise<AsyncIterator<JoinedChallengesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface PatientSubscriptionPayload {
  mutation: MutationType;
  node: Patient;
  updatedFields: String[];
  previousValues: PatientPreviousValues;
}

export interface PatientSubscriptionPayloadPromise
  extends Promise<PatientSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PatientPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PatientPreviousValuesPromise>() => T;
}

export interface PatientSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PatientSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PatientSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PatientPreviousValuesSubscription>() => T;
}

export interface PatientPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  verificationCode: String;
  verified?: Boolean;
  online?: Boolean;
  activeMinutesPerWeek?: Int;
}

export interface PatientPreviousValuesPromise
  extends Promise<PatientPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  verificationCode: () => Promise<String>;
  verified: () => Promise<Boolean>;
  online: () => Promise<Boolean>;
  activeMinutesPerWeek: () => Promise<Int>;
}

export interface PatientPreviousValuesSubscription
  extends Promise<AsyncIterator<PatientPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  verificationCode: () => Promise<AsyncIterator<String>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  online: () => Promise<AsyncIterator<Boolean>>;
  activeMinutesPerWeek: () => Promise<AsyncIterator<Int>>;
}

export interface PatientProfileInfoSubscriptionPayload {
  mutation: MutationType;
  node: PatientProfileInfo;
  updatedFields: String[];
  previousValues: PatientProfileInfoPreviousValues;
}

export interface PatientProfileInfoSubscriptionPayloadPromise
  extends Promise<PatientProfileInfoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PatientProfileInfoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PatientProfileInfoPreviousValuesPromise>() => T;
}

export interface PatientProfileInfoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PatientProfileInfoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PatientProfileInfoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PatientProfileInfoPreviousValuesSubscription>() => T;
}

export interface PatientProfileInfoPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  birthday?: DateTimeOutput;
  gender?: Gender;
  sameGender?: Boolean;
  hideGender?: Boolean;
  meetingDesired?: Boolean;
  avatar: String;
}

export interface PatientProfileInfoPreviousValuesPromise
  extends Promise<PatientProfileInfoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  birthday: () => Promise<DateTimeOutput>;
  gender: () => Promise<Gender>;
  sameGender: () => Promise<Boolean>;
  hideGender: () => Promise<Boolean>;
  meetingDesired: () => Promise<Boolean>;
  avatar: () => Promise<String>;
}

export interface PatientProfileInfoPreviousValuesSubscription
  extends Promise<AsyncIterator<PatientProfileInfoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  sameGender: () => Promise<AsyncIterator<Boolean>>;
  hideGender: () => Promise<AsyncIterator<Boolean>>;
  meetingDesired: () => Promise<AsyncIterator<Boolean>>;
  avatar: () => Promise<AsyncIterator<String>>;
}

export interface Phq9SubscriptionPayload {
  mutation: MutationType;
  node: Phq9;
  updatedFields: String[];
  previousValues: Phq9PreviousValues;
}

export interface Phq9SubscriptionPayloadPromise
  extends Promise<Phq9SubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Phq9Promise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = Phq9PreviousValuesPromise>() => T;
}

export interface Phq9SubscriptionPayloadSubscription
  extends Promise<AsyncIterator<Phq9SubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = Phq9Subscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = Phq9PreviousValuesSubscription>() => T;
}

export interface Phq9PreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  answers: Int[];
  score?: Int;
  isComplete?: Boolean;
  expiryDate?: DateTimeOutput;
}

export interface Phq9PreviousValuesPromise
  extends Promise<Phq9PreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  answers: () => Promise<Int[]>;
  score: () => Promise<Int>;
  isComplete: () => Promise<Boolean>;
  expiryDate: () => Promise<DateTimeOutput>;
}

export interface Phq9PreviousValuesSubscription
  extends Promise<AsyncIterator<Phq9PreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  answers: () => Promise<AsyncIterator<Int[]>>;
  score: () => Promise<AsyncIterator<Int>>;
  isComplete: () => Promise<AsyncIterator<Boolean>>;
  expiryDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProfileActivitySubscriptionPayload {
  mutation: MutationType;
  node: ProfileActivity;
  updatedFields: String[];
  previousValues: ProfileActivityPreviousValues;
}

export interface ProfileActivitySubscriptionPayloadPromise
  extends Promise<ProfileActivitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProfileActivityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProfileActivityPreviousValuesPromise>() => T;
}

export interface ProfileActivitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProfileActivitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProfileActivitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProfileActivityPreviousValuesSubscription>() => T;
}

export interface ProfileActivityPreviousValues {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  key: String;
  icon: String;
  titel: String;
}

export interface ProfileActivityPreviousValuesPromise
  extends Promise<ProfileActivityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  key: () => Promise<String>;
  icon: () => Promise<String>;
  titel: () => Promise<String>;
}

export interface ProfileActivityPreviousValuesSubscription
  extends Promise<AsyncIterator<ProfileActivityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  key: () => Promise<AsyncIterator<String>>;
  icon: () => Promise<AsyncIterator<String>>;
  titel: () => Promise<AsyncIterator<String>>;
}

export interface QuestionnairesSubscriptionPayload {
  mutation: MutationType;
  node: Questionnaires;
  updatedFields: String[];
  previousValues: QuestionnairesPreviousValues;
}

export interface QuestionnairesSubscriptionPayloadPromise
  extends Promise<QuestionnairesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionnairesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionnairesPreviousValuesPromise>() => T;
}

export interface QuestionnairesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionnairesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionnairesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionnairesPreviousValuesSubscription>() => T;
}

export interface QuestionnairesPreviousValues {
  id: ID_Output;
}

export interface QuestionnairesPreviousValuesPromise
  extends Promise<QuestionnairesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface QuestionnairesPreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionnairesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ScheduledTaskSubscriptionPayload {
  mutation: MutationType;
  node: ScheduledTask;
  updatedFields: String[];
  previousValues: ScheduledTaskPreviousValues;
}

export interface ScheduledTaskSubscriptionPayloadPromise
  extends Promise<ScheduledTaskSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScheduledTaskPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScheduledTaskPreviousValuesPromise>() => T;
}

export interface ScheduledTaskSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduledTaskSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduledTaskSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ScheduledTaskPreviousValuesSubscription>() => T;
}

export interface ScheduledTaskPreviousValues {
  id: ID_Output;
  updatedAt?: DateTimeOutput;
  scheduledFor?: DateTimeOutput;
  taskType: TaskTypes;
  userId?: ID_Output;
  chatId?: ID_Output;
  buddyRequestId?: ID_Output;
}

export interface ScheduledTaskPreviousValuesPromise
  extends Promise<ScheduledTaskPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  scheduledFor: () => Promise<DateTimeOutput>;
  taskType: () => Promise<TaskTypes>;
  userId: () => Promise<ID_Output>;
  chatId: () => Promise<ID_Output>;
  buddyRequestId: () => Promise<ID_Output>;
}

export interface ScheduledTaskPreviousValuesSubscription
  extends Promise<AsyncIterator<ScheduledTaskPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  scheduledFor: () => Promise<AsyncIterator<DateTimeOutput>>;
  taskType: () => Promise<AsyncIterator<TaskTypes>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
  chatId: () => Promise<AsyncIterator<ID_Output>>;
  buddyRequestId: () => Promise<AsyncIterator<ID_Output>>;
}

export interface SensorDataSubscriptionPayload {
  mutation: MutationType;
  node: SensorData;
  updatedFields: String[];
  previousValues: SensorDataPreviousValues;
}

export interface SensorDataSubscriptionPayloadPromise
  extends Promise<SensorDataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SensorDataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SensorDataPreviousValuesPromise>() => T;
}

export interface SensorDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SensorDataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SensorDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SensorDataPreviousValuesSubscription>() => T;
}

export interface SensorDataPreviousValues {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  type: String;
  x?: Float;
  y?: Float;
  z?: Float;
  alpha?: Float;
  beta?: Float;
  gamma?: Float;
}

export interface SensorDataPreviousValuesPromise
  extends Promise<SensorDataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<String>;
  x: () => Promise<Float>;
  y: () => Promise<Float>;
  z: () => Promise<Float>;
  alpha: () => Promise<Float>;
  beta: () => Promise<Float>;
  gamma: () => Promise<Float>;
}

export interface SensorDataPreviousValuesSubscription
  extends Promise<AsyncIterator<SensorDataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<String>>;
  x: () => Promise<AsyncIterator<Float>>;
  y: () => Promise<AsyncIterator<Float>>;
  z: () => Promise<AsyncIterator<Float>>;
  alpha: () => Promise<AsyncIterator<Float>>;
  beta: () => Promise<AsyncIterator<Float>>;
  gamma: () => Promise<AsyncIterator<Float>>;
}

export interface TimeSpanSubscriptionPayload {
  mutation: MutationType;
  node: TimeSpan;
  updatedFields: String[];
  previousValues: TimeSpanPreviousValues;
}

export interface TimeSpanSubscriptionPayloadPromise
  extends Promise<TimeSpanSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TimeSpanPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TimeSpanPreviousValuesPromise>() => T;
}

export interface TimeSpanSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TimeSpanSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TimeSpanSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TimeSpanPreviousValuesSubscription>() => T;
}

export interface TimeSpanPreviousValues {
  id: ID_Output;
  updatedAt?: DateTimeOutput;
  days: Int;
  hours: Int;
  minutes: Int;
  seconds: Int;
}

export interface TimeSpanPreviousValuesPromise
  extends Promise<TimeSpanPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  days: () => Promise<Int>;
  hours: () => Promise<Int>;
  minutes: () => Promise<Int>;
  seconds: () => Promise<Int>;
}

export interface TimeSpanPreviousValuesSubscription
  extends Promise<AsyncIterator<TimeSpanPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  days: () => Promise<AsyncIterator<Int>>;
  hours: () => Promise<AsyncIterator<Int>>;
  minutes: () => Promise<AsyncIterator<Int>>;
  seconds: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  username: String;
  password?: String;
  role: UserRole;
  lastActive?: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<UserRole>;
  lastActive: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRole>>;
  lastActive: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSettingsSubscriptionPayload {
  mutation: MutationType;
  node: UserSettings;
  updatedFields: String[];
  previousValues: UserSettingsPreviousValues;
}

export interface UserSettingsSubscriptionPayloadPromise
  extends Promise<UserSettingsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserSettingsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserSettingsPreviousValuesPromise>() => T;
}

export interface UserSettingsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSettingsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSettingsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserSettingsPreviousValuesSubscription>() => T;
}

export interface UserSettingsPreviousValues {
  id: ID_Output;
  themeName?: String;
}

export interface UserSettingsPreviousValuesPromise
  extends Promise<UserSettingsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  themeName: () => Promise<String>;
}

export interface UserSettingsPreviousValuesSubscription
  extends Promise<AsyncIterator<UserSettingsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  themeName: () => Promise<AsyncIterator<String>>;
}

export interface VotingSubscriptionPayload {
  mutation: MutationType;
  node: Voting;
  updatedFields: String[];
  previousValues: VotingPreviousValues;
}

export interface VotingSubscriptionPayloadPromise
  extends Promise<VotingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VotingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VotingPreviousValuesPromise>() => T;
}

export interface VotingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VotingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VotingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VotingPreviousValuesSubscription>() => T;
}

export interface VotingPreviousValues {
  id: ID_Output;
  title: String;
  description?: String;
  votedPoint?: Int;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface VotingPreviousValuesPromise
  extends Promise<VotingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  votedPoint: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface VotingPreviousValuesSubscription
  extends Promise<AsyncIterator<VotingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  votedPoint: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface WebPushNotificationSubscriptionPayload {
  mutation: MutationType;
  node: WebPushNotification;
  updatedFields: String[];
  previousValues: WebPushNotificationPreviousValues;
}

export interface WebPushNotificationSubscriptionPayloadPromise
  extends Promise<WebPushNotificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WebPushNotificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WebPushNotificationPreviousValuesPromise>() => T;
}

export interface WebPushNotificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WebPushNotificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WebPushNotificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WebPushNotificationPreviousValuesSubscription>() => T;
}

export interface WebPushNotificationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  notificationInformation: Json;
}

export interface WebPushNotificationPreviousValuesPromise
  extends Promise<WebPushNotificationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  notificationInformation: () => Promise<Json>;
}

export interface WebPushNotificationPreviousValuesSubscription
  extends Promise<AsyncIterator<WebPushNotificationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  notificationInformation: () => Promise<AsyncIterator<Json>>;
}

export interface WebPushSettingsSubscriptionPayload {
  mutation: MutationType;
  node: WebPushSettings;
  updatedFields: String[];
  previousValues: WebPushSettingsPreviousValues;
}

export interface WebPushSettingsSubscriptionPayloadPromise
  extends Promise<WebPushSettingsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WebPushSettingsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WebPushSettingsPreviousValuesPromise>() => T;
}

export interface WebPushSettingsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WebPushSettingsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WebPushSettingsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WebPushSettingsPreviousValuesSubscription>() => T;
}

export interface WebPushSettingsPreviousValues {
  id: ID_Output;
  updatedAt?: DateTimeOutput;
  webPushIpaqReminderMessage?: String;
  webPushPhqReminderMessage?: String;
  webPushIncomingBuddyRequestMessage?: String;
  webPushIncomingRequestNoResponseMessage?: String;
  webPushIncomingRequestNotAnsweredMessage?: String;
  webPushNotEnoughActivitiesMessage?: String;
  webPushNotEnoughActivitiesWeekday?: Int;
  webPushNotEnoughActivitiesBuddyMessage?: String;
  webPushNotEnoughActivitiesBuddyWeekday?: Int;
  webPushToManyActivitiesMessage?: String;
  webPushToManyActivitiesWeekday?: Int;
  webPushToManyActivitiesBuddyMessage?: String;
  webPushActivityMissedBuddyMessage?: String;
}

export interface WebPushSettingsPreviousValuesPromise
  extends Promise<WebPushSettingsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  webPushIpaqReminderMessage: () => Promise<String>;
  webPushPhqReminderMessage: () => Promise<String>;
  webPushIncomingBuddyRequestMessage: () => Promise<String>;
  webPushIncomingRequestNoResponseMessage: () => Promise<String>;
  webPushIncomingRequestNotAnsweredMessage: () => Promise<String>;
  webPushNotEnoughActivitiesMessage: () => Promise<String>;
  webPushNotEnoughActivitiesWeekday: () => Promise<Int>;
  webPushNotEnoughActivitiesBuddyMessage: () => Promise<String>;
  webPushNotEnoughActivitiesBuddyWeekday: () => Promise<Int>;
  webPushToManyActivitiesMessage: () => Promise<String>;
  webPushToManyActivitiesWeekday: () => Promise<Int>;
  webPushToManyActivitiesBuddyMessage: () => Promise<String>;
  webPushActivityMissedBuddyMessage: () => Promise<String>;
}

export interface WebPushSettingsPreviousValuesSubscription
  extends Promise<AsyncIterator<WebPushSettingsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  webPushIpaqReminderMessage: () => Promise<AsyncIterator<String>>;
  webPushPhqReminderMessage: () => Promise<AsyncIterator<String>>;
  webPushIncomingBuddyRequestMessage: () => Promise<AsyncIterator<String>>;
  webPushIncomingRequestNoResponseMessage: () => Promise<AsyncIterator<String>>;
  webPushIncomingRequestNotAnsweredMessage: () => Promise<
    AsyncIterator<String>
  >;
  webPushNotEnoughActivitiesMessage: () => Promise<AsyncIterator<String>>;
  webPushNotEnoughActivitiesWeekday: () => Promise<AsyncIterator<Int>>;
  webPushNotEnoughActivitiesBuddyMessage: () => Promise<AsyncIterator<String>>;
  webPushNotEnoughActivitiesBuddyWeekday: () => Promise<AsyncIterator<Int>>;
  webPushToManyActivitiesMessage: () => Promise<AsyncIterator<String>>;
  webPushToManyActivitiesWeekday: () => Promise<AsyncIterator<Int>>;
  webPushToManyActivitiesBuddyMessage: () => Promise<AsyncIterator<String>>;
  webPushActivityMissedBuddyMessage: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

export type Json = any;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "WebPushNotification",
    embedded: false
  },
  {
    name: "UserSettings",
    embedded: false
  },
  {
    name: "Patient",
    embedded: false
  },
  {
    name: "PatientProfileInfo",
    embedded: false
  },
  {
    name: "BuddyRequest",
    embedded: false
  },
  {
    name: "Buddy",
    embedded: false
  },
  {
    name: "Chat",
    embedded: false
  },
  {
    name: "ChatMessage",
    embedded: false
  },
  {
    name: "ChatMessageAttachment",
    embedded: false
  },
  {
    name: "Bot",
    embedded: false
  },
  {
    name: "ScheduledTask",
    embedded: false
  },
  {
    name: "Questionnaires",
    embedded: false
  },
  {
    name: "Phq9",
    embedded: false
  },
  {
    name: "Ipaq",
    embedded: false
  },
  {
    name: "IpaqAnswers",
    embedded: false
  },
  {
    name: "ProfileActivity",
    embedded: false
  },
  {
    name: "Activity",
    embedded: false
  },
  {
    name: "FavoriteActivity",
    embedded: false
  },
  {
    name: "CalendarEntry",
    embedded: false
  },
  {
    name: "SensorData",
    embedded: false
  },
  {
    name: "Group",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "Challenge",
    embedded: false
  },
  {
    name: "ChallengeGroup",
    embedded: false
  },
  {
    name: "ChallengeCategory",
    embedded: false
  },
  {
    name: "JoinedChallenges",
    embedded: false
  },
  {
    name: "Initiator",
    embedded: false
  },
  {
    name: "Voting",
    embedded: false
  },
  {
    name: "Contribution",
    embedded: false
  },
  {
    name: "GroupColor",
    embedded: false
  },
  {
    name: "Award",
    embedded: false
  },
  {
    name: "UserRole",
    embedded: false
  },
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "BuddyRequestState",
    embedded: false
  },
  {
    name: "TaskTypes",
    embedded: false
  },
  {
    name: "ActivityGrade",
    embedded: false
  },
  {
    name: "StatusChallegen",
    embedded: false
  },
  {
    name: "AwardVT",
    embedded: false
  },
  {
    name: "GlobalSettings",
    embedded: false
  },
  {
    name: "BotSettings",
    embedded: false
  },
  {
    name: "WebPushSettings",
    embedded: false
  },
  {
    name: "TimeSpan",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_MANAGEMENT_API_SECRET"]}`
});
export const prisma = new Prisma();
